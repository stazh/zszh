import { d as dom, P as Polymer, h as html, a as PaperButtonBehavior, t as translate, i as initTranslation, g as get$1, I as IronControlState, b as IronButtonState, c as PaperRippleBehavior, e as IronMenuBehavior, f as IronResizableBehavior, j as IronMenuBehaviorImpl, k as IronSelectableBehavior, l as afterNextRender, D as Debouncer, m as animationFrame, n as enqueueDebouncer, G as GestureEventListeners, o as PolymerElement, p as addListener, r as resetMouseCanceller, N as NeonAnimationRunnerBehavior, q as NeonAnimatableBehavior, s as NeonAnimationBehavior, u as IronValidatableBehavior, v as PaperInputBehavior, w as IronFormElementBehavior } from './paper-checkbox-ea000977.js';
import { u as unsafeHTML, p as pbHotkeys, P as PaperItemBehavior, E as ElementMixin, T as ThemableMixin } from './pb-message-a461d7ee.js';
import { L as LitElement, h as html$1, r as resolveURL, c as css, p as pbMixin, a as cmpVersion, b as clearPageEvents, m as minVersion } from './pb-mixin-ae9e2885.js';
import './es-global-bridge-6abe3a88.js';
import './iron-form-ee64c98d.js';

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll
 * events from a designated scroll target.
 *
 * Elements that consume this behavior can override the `_scrollHandler`
 * method to add logic on the scroll event.
 *
 * @demo demo/scrolling-region.html Scrolling Region
 * @demo demo/document.html Document Element
 * @polymerBehavior
 */

const IronScrollTargetBehavior = {
  properties: {
    /**
     * Specifies the element that will handle the scroll event
     * on the behalf of the current element. This is typically a reference to an
     *element, but there are a few more posibilities:
     *
     * ### Elements id
     *
     *```html
     * <div id="scrollable-element" style="overflow: auto;">
     *  <x-element scroll-target="scrollable-element">
     *    <!-- Content-->
     *  </x-element>
     * </div>
     *```
     * In this case, the `scrollTarget` will point to the outer div element.
     *
     * ### Document scrolling
     *
     * For document scrolling, you can use the reserved word `document`:
     *
     *```html
     * <x-element scroll-target="document">
     *   <!-- Content -->
     * </x-element>
     *```
     *
     * ### Elements reference
     *
     *```js
     * appHeader.scrollTarget = document.querySelector('#scrollable-element');
     *```
     *
     * @type {HTMLElement}
     * @default document
     */
    scrollTarget: {
      type: HTMLElement,
      value: function () {
        return this._defaultScrollTarget;
      }
    }
  },
  observers: ['_scrollTargetChanged(scrollTarget, isAttached)'],

  /**
   * True if the event listener should be installed.
   */
  _shouldHaveListener: true,
  _scrollTargetChanged: function (scrollTarget, isAttached) {
    console.log("_scrollTargetChanged");
    if (this._oldScrollTarget) {
      this._toggleScrollListener(false, this._oldScrollTarget);

      this._oldScrollTarget = null;
    }

    if (!isAttached) {
      return;
    } // Support element id references


    if (scrollTarget === 'document') {
      this.scrollTarget = this._doc;
    } else if (typeof scrollTarget === 'string') {
      var domHost = this.domHost;
      this.scrollTarget = domHost && domHost.$ ? domHost.$[scrollTarget] : dom(this.ownerDocument).querySelector('#' + scrollTarget);
    } else if (this._isValidScrollTarget()) {
      this._oldScrollTarget = scrollTarget;

      this._toggleScrollListener(this._shouldHaveListener, scrollTarget);
    }
  },

  /**
   * Runs on every scroll event. Consumer of this behavior may override this
   * method.
   *
   * @protected
   */
  _scrollHandler: function scrollHandler() {},

  /**
   * The default scroll target. Consumers of this behavior may want to customize
   * the default scroll target.
   *
   * @type {Element}
   */
  get _defaultScrollTarget() {
    return this._doc;
  },

  /**
   * Shortcut for the document element
   *
   * @type {Element}
   */
  get _doc() {
    return this.ownerDocument.documentElement;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled
   * upward.
   *
   * @type {number}
   */
  get _scrollTop() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
    }

    return 0;
  },

  /**
   * Gets the number of pixels that the content of an element is scrolled to the
   * left.
   *
   * @type {number}
   */
  get _scrollLeft() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
    }

    return 0;
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled
   * upward.
   *
   * @type {number}
   */
  set _scrollTop(top) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(window.pageXOffset, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Sets the number of pixels that the content of an element is scrolled to the
   * left.
   *
   * @type {number}
   */
  set _scrollLeft(left) {
    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, window.pageYOffset);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
    }
  },

  /**
   * Scrolls the content to a particular place.
   *
   * @method scroll
   * @param {number|!{left: number, top: number}} leftOrOptions The left position or scroll options
   * @param {number=} top The top position
   * @return {void}
   */
  scroll: function (leftOrOptions, top) {
    var left;

    if (typeof leftOrOptions === 'object') {
      left = leftOrOptions.left;
      top = leftOrOptions.top;
    } else {
      left = leftOrOptions;
    }

    left = left || 0;
    top = top || 0;

    if (this.scrollTarget === this._doc) {
      window.scrollTo(left, top);
    } else if (this._isValidScrollTarget()) {
      this.scrollTarget.scrollLeft = left;
      this.scrollTarget.scrollTop = top;
    }
  },

  /**
   * Gets the width of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetWidth() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
    }

    return 0;
  },

  /**
   * Gets the height of the scroll target.
   *
   * @type {number}
   */
  get _scrollTargetHeight() {
    if (this._isValidScrollTarget()) {
      return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
    }

    return 0;
  },

  /**
   * Returns true if the scroll target is a valid HTMLElement.
   *
   * @return {boolean}
   */
  _isValidScrollTarget: function () {
    return this.scrollTarget instanceof HTMLElement;
  },
  _toggleScrollListener: function (yes, scrollTarget) {
    var eventTarget = scrollTarget === this._doc ? window : scrollTarget;

    if (yes) {
      if (!this._boundScrollHandler) {
        this._boundScrollHandler = this._scrollHandler.bind(this);
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      }
    } else {
      if (this._boundScrollHandler) {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
        this._boundScrollHandler = null;
      }
    }
  },

  /**
   * Enables or disables the scroll event listener.
   *
   * @param {boolean} yes True to add the event, False to remove it.
   */
  toggleScrollListener: function (yes) {
    this._shouldHaveListener = yes;

    this._toggleScrollListener(yes, this.scrollTarget);
  }
};

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const _scrollEffects = {};
/**
 * Registers a scroll effect to be used in elements that implement the
 * `Polymer.AppScrollEffectsBehavior` behavior.
 *
 * @param {string} effectName The effect name.
 * @param {Object} effectDef The effect definition.
 */

const registerEffect = function registerEffect(effectName, effectDef) {
  if (_scrollEffects[effectName] != null) {
    throw new Error('effect `' + effectName + '` is already registered.');
  }

  _scrollEffects[effectName] = effectDef;
};

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * `Polymer.AppScrollEffectsBehavior` provides an interface that allows an
 * element to use scrolls effects.
 *
 * ### Importing the app-layout effects
 *
 * app-layout provides a set of scroll effects that can be used by explicitly
 * importing `app-scroll-effects.js`:
 *
 * ```js
 * import '@polymer/app-layout/app-scroll-effects/app-scroll-effects.js';
 * ```
 *
 * The scroll effects can also be used by individually importing
 * `@polymer/app-layout/app-scroll-effects/effects/[effectName].js`. For
 * example:
 *
 * ```js
 * import '@polymer/app-layout/app-scroll-effects/effects/waterfall.js';
 * ```
 *
 * ### Consuming effects
 *
 * Effects can be consumed via the `effects` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"></app-header>
 * ```
 *
 * ### Creating scroll effects
 *
 * You may want to create a custom scroll effect if you need to modify the CSS
 * of an element based on the scroll position.
 *
 * A scroll effect definition is an object with `setUp()`, `tearDown()` and
 * `run()` functions.
 *
 * To register the effect, you can use
 * `Polymer.AppLayout.registerEffect(effectName, effectDef)` For example, let's
 * define an effect that resizes the header's logo:
 *
 * ```js
 * Polymer.AppLayout.registerEffect('resizable-logo', {
 *   setUp: function(config) {
 *     // the effect's config is passed to the setUp.
 *     this._fxResizeLogo = { logo: Polymer.dom(this).querySelector('[logo]') };
 *   },
 *
 *   run: function(progress) {
 *      // the progress of the effect
 *      this.transform('scale3d(' + progress + ', '+ progress +', 1)',
 * this._fxResizeLogo.logo);
 *   },
 *
 *   tearDown: function() {
 *      // clean up and reset of states
 *      delete this._fxResizeLogo;
 *   }
 * });
 * ```
 * Now, you can consume the effect:
 *
 * ```html
 * <app-header id="appHeader" effects="resizable-logo">
 *   <img logo src="logo.svg">
 * </app-header>
 * ```
 *
 * ### Imperative API
 *
 * ```js
 * var logoEffect = appHeader.createEffect('resizable-logo', effectConfig);
 * // run the effect: logoEffect.run(progress);
 * // tear down the effect: logoEffect.tearDown();
 * ```
 *
 * ### Configuring effects
 *
 * For effects installed via the `effects` property, their configuration can be
 * set via the `effectsConfig` property. For example:
 *
 * ```html
 * <app-header effects="waterfall"
 *   effects-config='{"waterfall": {"startsAt": 0, "endsAt": 0.5}}'>
 * </app-header>
 * ```
 *
 * All effects have a `startsAt` and `endsAt` config property. They specify at
 * what point the effect should start and end. This value goes from 0 to 1
 * inclusive.
 *
 * @polymerBehavior
 */

const AppScrollEffectsBehavior = [IronScrollTargetBehavior, {
  properties: {
    /**
     * A space-separated list of the effects names that will be triggered when
     * the user scrolls. e.g. `waterfall parallax-background` installs the
     * `waterfall` and `parallax-background`.
     */
    effects: {
      type: String
    },

    /**
     * An object that configurates the effects installed via the `effects`
     * property. e.g.
     * ```js
     *  element.effectsConfig = {
     *   "blend-background": {
     *     "startsAt": 0.5
     *   }
     * };
     * ```
     * Every effect has at least two config properties: `startsAt` and
     * `endsAt`. These properties indicate when the event should start and end
     * respectively and relative to the overall element progress. So for
     * example, if `blend-background` starts at `0.5`, the effect will only
     * start once the current element reaches 0.5 of its progress. In this
     * context, the progress is a value in the range of `[0, 1]` that
     * indicates where this element is on the screen relative to the viewport.
     */
    effectsConfig: {
      type: Object,
      value: function () {
        return {};
      }
    },

    /**
     * Disables CSS transitions and scroll effects on the element.
     */
    disabled: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    },

    /**
     * Allows to set a `scrollTop` threshold. When greater than 0,
     * `thresholdTriggered` is true only when the scroll target's `scrollTop`
     * has reached this value.
     *
     * For example, if `threshold = 100`, `thresholdTriggered` is true when
     * the `scrollTop` is at least `100`.
     */
    threshold: {
      type: Number,
      value: 0
    },

    /**
     * True if the `scrollTop` threshold (set in `scrollTopThreshold`) has
     * been reached.
     */
    thresholdTriggered: {
      type: Boolean,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    }
  },
  observers: ['_effectsChanged(effects, effectsConfig, isAttached)'],

  /**
   * Updates the scroll state. This method should be overridden
   * by the consumer of this behavior.
   *
   * @method _updateScrollState
   * @param {number} scrollTop
   */
  _updateScrollState: function (scrollTop) {},

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport. This method should be
   * overridden by the consumer of this behavior.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function () {
    return false;
  },

  /**
   * Returns true if there's content below the current element. This method
   * should be overridden by the consumer of this behavior.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function () {
    return false;
  },

  /**
   * List of effects handlers that will take place during scroll.
   *
   * @type {Array<Function>}
   */
  _effectsRunFn: null,

  /**
   * List of the effects definitions installed via the `effects` property.
   *
   * @type {Array<Object>}
   */
  _effects: null,

  /**
   * The clamped value of `_scrollTop`.
   * @type number
   */
  get _clampedScrollTop() {
    return Math.max(0, this._scrollTop);
  },

  attached: function () {
    this._scrollStateChanged();
  },
  detached: function () {
    this._tearDownEffects();
  },

  /**
   * Creates an effect object from an effect's name that can be used to run
   * effects programmatically.
   *
   * @method createEffect
   * @param {string} effectName The effect's name registered via `Polymer.AppLayout.registerEffect`.
   * @param {Object=} effectConfig The effect config object. (Optional)
   * @return {Object} An effect object with the following functions:
   *
   *  * `effect.setUp()`, Sets up the requirements for the effect.
   *       This function is called automatically before the `effect` function
   * returns.
   *  * `effect.run(progress, y)`, Runs the effect given a `progress`.
   *  * `effect.tearDown()`, Cleans up any DOM nodes or element references
   * used by the effect.
   *
   * Example:
   * ```js
   * var parallax = element.createEffect('parallax-background');
   * // runs the effect
   * parallax.run(0.5, 0);
   * ```
   */
  createEffect: function (effectName, effectConfig) {
    var effectDef = _scrollEffects[effectName];

    if (!effectDef) {
      throw new ReferenceError(this._getUndefinedMsg(effectName));
    }

    var prop = this._boundEffect(effectDef, effectConfig || {});

    prop.setUp();
    return prop;
  },

  /**
   * Called when `effects` or `effectsConfig` changes.
   */
  _effectsChanged: function (effects, effectsConfig, isAttached) {
    this._tearDownEffects();

    if (!effects || !isAttached) {
      return;
    }

    effects.split(' ').forEach(function (effectName) {
      var effectDef;

      if (effectName !== '') {
        if (effectDef = _scrollEffects[effectName]) {
          this._effects.push(this._boundEffect(effectDef, effectsConfig[effectName]));
        } else {
          console.warn(this._getUndefinedMsg(effectName));
        }
      }
    }, this);

    this._setUpEffect();
  },

  /**
   * Forces layout
   */
  _layoutIfDirty: function () {
    return this.offsetWidth;
  },

  /**
   * Returns an effect object bound to the current context.
   *
   * @param {Object} effectDef
   * @param {Object=} effectsConfig The effect config object if the effect accepts config values. (Optional)
   */
  _boundEffect: function (effectDef, effectsConfig) {
    effectsConfig = effectsConfig || {};
    var startsAt = parseFloat(effectsConfig.startsAt || 0);
    var endsAt = parseFloat(effectsConfig.endsAt || 1);
    var deltaS = endsAt - startsAt;

    var noop = function () {}; // fast path if possible


    var runFn = startsAt === 0 && endsAt === 1 ? effectDef.run : function (progress, y) {
      effectDef.run.call(this, Math.max(0, (progress - startsAt) / deltaS), y);
    };
    return {
      setUp: effectDef.setUp ? effectDef.setUp.bind(this, effectsConfig) : noop,
      run: effectDef.run ? runFn.bind(this) : noop,
      tearDown: effectDef.tearDown ? effectDef.tearDown.bind(this) : noop
    };
  },

  /**
   * Sets up the effects.
   */
  _setUpEffect: function () {
    if (this.isAttached && this._effects) {
      this._effectsRunFn = [];

      this._effects.forEach(function (effectDef) {
        // install the effect only if no error was reported
        if (effectDef.setUp() !== false) {
          this._effectsRunFn.push(effectDef.run);
        }
      }, this);
    }
  },

  /**
   * Tears down the effects.
   */
  _tearDownEffects: function () {
    if (this._effects) {
      this._effects.forEach(function (effectDef) {
        effectDef.tearDown();
      });
    }

    this._effectsRunFn = [];
    this._effects = [];
  },

  /**
   * Runs the effects.
   *
   * @param {number} p The progress
   * @param {number} y The top position of the current element relative to the viewport.
   */
  _runEffects: function (p, y) {
    if (this._effectsRunFn) {
      this._effectsRunFn.forEach(function (run) {
        run(p, y);
      });
    }
  },

  /**
   * Overrides the `_scrollHandler`.
   */
  _scrollHandler: function () {
    this._scrollStateChanged();
  },
  _scrollStateChanged: function () {
    if (!this.disabled) {
      var scrollTop = this._clampedScrollTop;

      this._updateScrollState(scrollTop);

      if (this.threshold > 0) {
        this._setThresholdTriggered(scrollTop >= this.threshold);
      }
    }
  },

  /**
   * Override this method to return a reference to a node in the local DOM.
   * The node is consumed by a scroll effect.
   *
   * @param {string} id The id for the node.
   */
  _getDOMRef: function (id) {
    console.warn('_getDOMRef', '`' + id + '` is undefined');
  },
  _getUndefinedMsg: function (effectName) {
    return 'Scroll effect `' + effectName + '` is undefined. ' + 'Did you forget to import app-layout/app-scroll-effects/effects/' + effectName + '.html ?';
  }
}];

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * While scrolling down, fade in the rear background layer and fade out the
 * front background layer (opacity interpolated based on scroll position).
 */

registerEffect('blend-background', {
  /** @this {BlendBackground} */
  setUp: function setUp() {
    var fx = {};
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.transform = 'translateZ(0)';
    fx.backgroundRearLayer.style.opacity = 0;
    this._fxBlendBackground = fx;
  },

  /** @this {BlendBackground} */
  run: function run(p, y) {
    var fx = this._fxBlendBackground;
    fx.backgroundFrontLayer.style.opacity = 1 - p;
    fx.backgroundRearLayer.style.opacity = p;
  },

  /** @this {BlendBackground} */
  tearDown: function tearDown() {
    delete this._fxBlendBackground;
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Upon scrolling past a threshold, fade in the rear background layer and fade
 * out the front background layer (opacity CSS transitioned over time).
 */

registerEffect('fade-background', {
  /** @this {FadeBackground} */
  setUp: function setUp(config) {
    var fx = {};
    var duration = config.duration || '0.5s';
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.backgroundFrontLayer.style.willChange = 'opacity';
    fx.backgroundFrontLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundFrontLayer.style.transitionProperty = 'opacity';
    fx.backgroundFrontLayer.style.transitionDuration = duration;
    fx.backgroundRearLayer.style.willChange = 'opacity';
    fx.backgroundRearLayer.style.webkitTransform = 'translateZ(0)';
    fx.backgroundRearLayer.style.transitionProperty = 'opacity';
    fx.backgroundRearLayer.style.transitionDuration = duration;
    this._fxFadeBackground = fx;
  },

  /** @this {FadeBackground} */
  run: function run(p, y) {
    var fx = this._fxFadeBackground;

    if (p >= 1) {
      fx.backgroundFrontLayer.style.opacity = 0;
      fx.backgroundRearLayer.style.opacity = 1;
    } else {
      fx.backgroundFrontLayer.style.opacity = 1;
      fx.backgroundRearLayer.style.opacity = 0;
    }
  },

  /** @this {FadeBackground} */
  tearDown: function tearDown() {
    delete this._fxFadeBackground;
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Toggles the shadow property in app-header when content is scrolled to create
 * a sense of depth between the element and the content underneath.
 */

registerEffect('waterfall', {
  /** @this {Waterfall} */
  run: function run() {
    this.shadow = this.isOnScreen() && this.isContentBelow();
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

function interpolate(progress, points, fn, ctx) {
  fn.apply(ctx, points.map(function (point) {
    return point[0] + (point[1] - point[0]) * progress;
  }));
}
/**
 * Transform the font size of a designated title element between two values
 * based on the scroll position.
 */


registerEffect('resize-title', {
  /** @this {ResizeTitle} */
  setUp: function setUp() {
    var title = this._getDOMRef('mainTitle');

    var condensedTitle = this._getDOMRef('condensedTitle');

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-title`: undefined `condensed-title`');
      return false;
    }

    if (!title) {
      console.warn('Scroll effect `resize-title`: undefined `main-title`');
      return false;
    }

    condensedTitle.style.willChange = 'opacity';
    condensedTitle.style.webkitTransform = 'translateZ(0)';
    condensedTitle.style.transform = 'translateZ(0)';
    condensedTitle.style.webkitTransformOrigin = 'left top';
    condensedTitle.style.transformOrigin = 'left top';
    title.style.willChange = 'opacity';
    title.style.webkitTransformOrigin = 'left top';
    title.style.transformOrigin = 'left top';
    title.style.webkitTransform = 'translateZ(0)';
    title.style.transform = 'translateZ(0)';
    var titleClientRect = title.getBoundingClientRect();
    var condensedTitleClientRect = condensedTitle.getBoundingClientRect();
    var fx = {};
    fx.scale = parseInt(window.getComputedStyle(condensedTitle)['font-size'], 10) / parseInt(window.getComputedStyle(title)['font-size'], 10);
    fx.titleDX = titleClientRect.left - condensedTitleClientRect.left;
    fx.titleDY = titleClientRect.top - condensedTitleClientRect.top;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeTitle = fx;
  },

  /** @this {ResizeTitle} */
  run: function run(p, y) {
    var fx = this._fxResizeTitle;

    if (!this.condenses) {
      y = 0;
    }

    if (p >= 1) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }

    interpolate(Math.min(1, p), [[1, fx.scale], [0, -fx.titleDX], [y, y - fx.titleDY]], function (scale, translateX, translateY) {
      this.transform('translate(' + translateX + 'px, ' + translateY + 'px) ' + 'scale3d(' + scale + ', ' + scale + ', 1)', fx.title);
    }, this);
  },

  /** @this {ResizeTitle} */
  tearDown: function tearDown() {
    delete this._fxResizeTitle;
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Vertically translate the background based on a factor of the scroll position.
 */

registerEffect('parallax-background', {
  /**
   * @param {{scalar: string}} config
   * @this {ParallaxBackground}
   */
  setUp: function setUp(config) {
    var fx = {};
    var scalar = parseFloat(config.scalar);
    fx.background = this._getDOMRef('background');
    fx.backgroundFrontLayer = this._getDOMRef('backgroundFrontLayer');
    fx.backgroundRearLayer = this._getDOMRef('backgroundRearLayer');
    fx.deltaBg = fx.backgroundFrontLayer.offsetHeight - fx.background.offsetHeight;

    if (fx.deltaBg === 0) {
      if (isNaN(scalar)) {
        scalar = 0.8;
      }

      fx.deltaBg = (this._dHeight || 0) * scalar;
    } else {
      if (isNaN(scalar)) {
        scalar = 1;
      }

      fx.deltaBg = fx.deltaBg * scalar;
    }

    this._fxParallaxBackground = fx;
  },

  /** @this {ParallaxBackground} */
  run: function run(p, y) {
    var fx = this._fxParallaxBackground;
    this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundFrontLayer);

    if (fx.backgroundRearLayer) {
      this.transform('translate3d(0px, ' + fx.deltaBg * Math.min(1, p) + 'px, 0px)', fx.backgroundRearLayer);
    }
  },

  /** @this {ParallaxBackground} */
  tearDown: function tearDown() {
    delete this._fxParallaxBackground;
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Shorthand for the waterfall, resize-title, blend-background, and
 * parallax-background effects.
 */

registerEffect('material', {
  /** @this {Material} */
  setUp: function setUp() {
    this.effects = 'waterfall resize-title blend-background parallax-background';
    return false;
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Upon scrolling past a threshold, CSS transition the font size of a designated
 * title element between two values.
 */

registerEffect('resize-snapped-title', {
  /** @this {ResizeSnappedTitle} */
  setUp: function setUp(config) {
    var title = this._getDOMRef('mainTitle');

    var condensedTitle = this._getDOMRef('condensedTitle');

    var duration = config.duration || '0.2s';
    var fx = {};

    if (!condensedTitle) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `condensed-title`');
      return false;
    }

    if (!title) {
      console.warn('Scroll effect `resize-snapped-title`: undefined `main-title`');
      return false;
    }

    title.style.transitionProperty = 'opacity';
    title.style.transitionDuration = duration;
    condensedTitle.style.transitionProperty = 'opacity';
    condensedTitle.style.transitionDuration = duration;
    fx.condensedTitle = condensedTitle;
    fx.title = title;
    this._fxResizeSnappedTitle = fx;
  },

  /** @this {ResizeSnappedTitle} */
  run: function run(p, y) {
    var fx = this._fxResizeSnappedTitle;

    if (p > 0) {
      fx.title.style.opacity = 0;
      fx.condensedTitle.style.opacity = 1;
    } else {
      fx.title.style.opacity = 1;
      fx.condensedTitle.style.opacity = 0;
    }
  },

  /** @this {ResizeSnappedTitle} */
  tearDown: function tearDown() {
    var fx = this._fxResizeSnappedTitle;
    fx.title.style.transition = '';
    fx.condensedTitle.style.transition = '';
    delete this._fxResizeSnappedTitle;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
Material design:
[Tooltips](https://www.google.com/design/spec/components/tooltips.html)
`<paper-tooltip>` is a label that appears on hover and focus when the user
hovers over an element with the cursor or with the keyboard. It will be centered
to an anchor element specified in the `for` attribute, or, if that doesn't
exist, centered to the parent node containing it.
Example:
    <div style="display:inline-block">
      <button>Click me!</button>
      <paper-tooltip>Tooltip text</paper-tooltip>
    </div>
    <div>
      <button id="btn">Click me!</button>
      <paper-tooltip for="btn">Tooltip text</paper-tooltip>
    </div>
The tooltip can be positioned on the top|bottom|left|right of the anchor using
the `position` attribute. The default position is bottom.
    <paper-tooltip for="btn" position="left">Tooltip text</paper-tooltip>
    <paper-tooltip for="btn" position="top">Tooltip text</paper-tooltip>

### Styling
The following custom properties and mixins are available for styling:
Custom property | Description | Default
----------------|-------------|----------
`--paper-tooltip-background` | The background color of the tooltip | `#616161`
`--paper-tooltip-opacity` | The opacity of the tooltip | `0.9`
`--paper-tooltip-text-color` | The text color of the tooltip | `white`
`--paper-tooltip` | Mixin applied to the tooltip | `{}`
`--paper-tooltip-delay-in` | Delay before tooltip starts to fade in | `500`
`--paper-tooltip-delay-out` | Delay before tooltip starts to fade out | `0`
`--paper-tooltip-duration-in` | Timing for animation when showing tooltip | `500`
`--paper-tooltip-duration-out` | Timing for animation when hiding tooltip | `0`
`--paper-tooltip-animation` | Mixin applied to the tooltip animation | `{}`
@group Paper Elements
@element paper-tooltip
@demo demo/index.html
*/

Polymer({
  _template: html`
    <style>
      :host {
        display: block;
        position: absolute;
        outline: none;
        z-index: 1002;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: default;
      }

      #tooltip {
        display: block;
        outline: none;
        @apply --paper-font-common-base;
        font-size: 10px;
        line-height: 1;
        background-color: var(--paper-tooltip-background, #616161);
        color: var(--paper-tooltip-text-color, white);
        padding: 8px;
        border-radius: 2px;
        @apply --paper-tooltip;
      }

      @keyframes keyFrameScaleUp {
        0% {
          transform: scale(0.0);
        }
        100% {
          transform: scale(1.0);
        }
      }

      @keyframes keyFrameScaleDown {
        0% {
          transform: scale(1.0);
        }
        100% {
          transform: scale(0.0);
        }
      }

      @keyframes keyFrameFadeInOpacity {
        0% {
          opacity: 0;
        }
        100% {
          opacity: var(--paper-tooltip-opacity, 0.9);
        }
      }

      @keyframes keyFrameFadeOutOpacity {
        0% {
          opacity: var(--paper-tooltip-opacity, 0.9);
        }
        100% {
          opacity: 0;
        }
      }

      @keyframes keyFrameSlideDownIn {
        0% {
          transform: translateY(-2000px);
          opacity: 0;
        }
        10% {
          opacity: 0.2;
        }
        100% {
          transform: translateY(0);
          opacity: var(--paper-tooltip-opacity, 0.9);
        }
      }

      @keyframes keyFrameSlideDownOut {
        0% {
          transform: translateY(0);
          opacity: var(--paper-tooltip-opacity, 0.9);
        }
        10% {
          opacity: 0.2;
        }
        100% {
          transform: translateY(-2000px);
          opacity: 0;
        }
      }

      .fade-in-animation {
        opacity: 0;
        animation-delay: var(--paper-tooltip-delay-in, 500ms);
        animation-name: keyFrameFadeInOpacity;
        animation-iteration-count: 1;
        animation-timing-function: ease-in;
        animation-duration: var(--paper-tooltip-duration-in, 500ms);
        animation-fill-mode: forwards;
        @apply --paper-tooltip-animation;
      }

      .fade-out-animation {
        opacity: var(--paper-tooltip-opacity, 0.9);
        animation-delay: var(--paper-tooltip-delay-out, 0ms);
        animation-name: keyFrameFadeOutOpacity;
        animation-iteration-count: 1;
        animation-timing-function: ease-in;
        animation-duration: var(--paper-tooltip-duration-out, 500ms);
        animation-fill-mode: forwards;
        @apply --paper-tooltip-animation;
      }

      .scale-up-animation {
        transform: scale(0);
        opacity: var(--paper-tooltip-opacity, 0.9);
        animation-delay: var(--paper-tooltip-delay-in, 500ms);
        animation-name: keyFrameScaleUp;
        animation-iteration-count: 1;
        animation-timing-function: ease-in;
        animation-duration: var(--paper-tooltip-duration-in, 500ms);
        animation-fill-mode: forwards;
        @apply --paper-tooltip-animation;
      }

      .scale-down-animation {
        transform: scale(1);
        opacity: var(--paper-tooltip-opacity, 0.9);
        animation-delay: var(--paper-tooltip-delay-out, 500ms);
        animation-name: keyFrameScaleDown;
        animation-iteration-count: 1;
        animation-timing-function: ease-in;
        animation-duration: var(--paper-tooltip-duration-out, 500ms);
        animation-fill-mode: forwards;
        @apply --paper-tooltip-animation;
      }

      .slide-down-animation {
        transform: translateY(-2000px);
        opacity: 0;
        animation-delay: var(--paper-tooltip-delay-out, 500ms);
        animation-name: keyFrameSlideDownIn;
        animation-iteration-count: 1;
        animation-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
        animation-duration: var(--paper-tooltip-duration-out, 500ms);
        animation-fill-mode: forwards;
        @apply --paper-tooltip-animation;
      }

      .slide-down-animation-out {
        transform: translateY(0);
        opacity: var(--paper-tooltip-opacity, 0.9);
        animation-delay: var(--paper-tooltip-delay-out, 500ms);
        animation-name: keyFrameSlideDownOut;
        animation-iteration-count: 1;
        animation-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
        animation-duration: var(--paper-tooltip-duration-out, 500ms);
        animation-fill-mode: forwards;
        @apply --paper-tooltip-animation;
      }

      .cancel-animation {
        animation-delay: -30s !important;
      }

      /* Thanks IE 10. */

      .hidden {
        display: none !important;
      }
    </style>

    <div id="tooltip" class="hidden">
      <slot></slot>
    </div>
`,
  is: 'paper-tooltip',
  hostAttributes: {
    role: 'tooltip',
    tabindex: -1
  },
  properties: {
    /**
     * The id of the element that the tooltip is anchored to. This element
     * must be a sibling of the tooltip. If this property is not set,
     * then the tooltip will be centered to the parent node containing it.
     */
    for: {
      type: String,
      observer: '_findTarget'
    },

    /**
     * Set this to true if you want to manually control when the tooltip
     * is shown or hidden.
     */
    manualMode: {
      type: Boolean,
      value: false,
      observer: '_manualModeChanged'
    },

    /**
     * Positions the tooltip to the top, right, bottom, left of its content.
     */
    position: {
      type: String,
      value: 'bottom'
    },

    /**
     * If true, no parts of the tooltip will ever be shown offscreen.
     */
    fitToVisibleBounds: {
      type: Boolean,
      value: false
    },

    /**
     * The spacing between the top of the tooltip and the element it is
     * anchored to.
     */
    offset: {
      type: Number,
      value: 14
    },

    /**
     * This property is deprecated, but left over so that it doesn't
     * break exiting code. Please use `offset` instead. If both `offset` and
     * `marginTop` are provided, `marginTop` will be ignored.
     * @deprecated since version 1.0.3
     */
    marginTop: {
      type: Number,
      value: 14
    },

    /**
     * The delay that will be applied before the `entry` animation is
     * played when showing the tooltip.
     */
    animationDelay: {
      type: Number,
      value: 500,
      observer: '_delayChange'
    },

    /**
     * The animation that will be played on entry.  This replaces the
     * deprecated animationConfig.  Entries here will override the
     * animationConfig settings.  You can enter your own animation
     * by setting it to the css class name.
     */
    animationEntry: {
      type: String,
      value: ''
    },

    /**
     * The animation that will be played on exit.  This replaces the
     * deprecated animationConfig.  Entries here will override the
     * animationConfig settings.  You can enter your own animation
     * by setting it to the css class name.
     */
    animationExit: {
      type: String,
      value: ''
    },

    /**
     * This property is deprecated.  Use --paper-tooltip-animation to change the
     * animation. The entry and exit animations that will be played when showing
     * and hiding the tooltip. If you want to override this, you must ensure
     * that your animationConfig has the exact format below.
     * @deprecated since version
     *
     * The entry and exit animations that will be played when showing and
     * hiding the tooltip. If you want to override this, you must ensure
     * that your animationConfig has the exact format below.
     */
    animationConfig: {
      type: Object,
      value: function () {
        return {
          'entry': [{
            name: 'fade-in-animation',
            node: this,
            timing: {
              delay: 0
            }
          }],
          'exit': [{
            name: 'fade-out-animation',
            node: this
          }]
        };
      }
    },
    _showing: {
      type: Boolean,
      value: false
    }
  },
  listeners: {
    'webkitAnimationEnd': '_onAnimationEnd'
  },

  /**
   * Returns the target element that this tooltip is anchored to. It is
   * either the element given by the `for` attribute, or the immediate parent
   * of the tooltip.
   *
   * @type {Node}
   */
  get target() {
    var parentNode = dom(this).parentNode; // If the parentNode is a document fragment, then we need to use the host.

    var ownerRoot = dom(this).getOwnerRoot();
    var target;

    if (this.for) {
      target = dom(ownerRoot).querySelector('#' + this.for);
    } else {
      target = parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE ? ownerRoot.host : parentNode;
    }

    return target;
  },

  /**
   * @return {void}
   */
  attached: function () {
    this._findTarget();
  },

  /**
   * @return {void}
   */
  detached: function () {
    if (!this.manualMode) this._removeListeners();
  },

  /**
   * Replaces Neon-Animation playAnimation - just calls show and hide.
   * @deprecated Use show and hide instead.
   * @param {string} type Either `entry` or `exit`
   */
  playAnimation: function (type) {
    if (type === 'entry') {
      this.show();
    } else if (type === 'exit') {
      this.hide();
    }
  },

  /**
   * Cancels the animation and either fully shows or fully hides tooltip
   */
  cancelAnimation: function () {
    // Short-cut and cancel all animations and hide
    this.$.tooltip.classList.add('cancel-animation');
  },

  /**
   * Shows the tooltip programatically
   * @return {void}
   */
  show: function () {
    // If the tooltip is already showing, there's nothing to do.
    if (this._showing) return;

    if (dom(this).textContent.trim() === '') {
      // Check if effective children are also empty
      var allChildrenEmpty = true;
      var effectiveChildren = dom(this).getEffectiveChildNodes();

      for (var i = 0; i < effectiveChildren.length; i++) {
        if (effectiveChildren[i].textContent.trim() !== '') {
          allChildrenEmpty = false;
          break;
        }
      }

      if (allChildrenEmpty) {
        return;
      }
    }

    this._showing = true;
    this.$.tooltip.classList.remove('hidden');
    this.$.tooltip.classList.remove('cancel-animation');
    this.$.tooltip.classList.remove(this._getAnimationType('exit'));
    this.updatePosition();
    this._animationPlaying = true;
    this.$.tooltip.classList.add(this._getAnimationType('entry'));
  },

  /**
   * Hides the tooltip programatically
   * @return {void}
   */
  hide: function () {
    // If the tooltip is already hidden, there's nothing to do.
    if (!this._showing) {
      return;
    } // If the entry animation is still playing, don't try to play the exit
    // animation since this will reset the opacity to 1. Just end the animation.


    if (this._animationPlaying) {
      this._showing = false;

      this._cancelAnimation();

      return;
    } else {
      // Play Exit Animation
      this._onAnimationFinish();
    }

    this._showing = false;
    this._animationPlaying = true;
  },

  /**
   * @return {void}
   */
  updatePosition: function () {
    if (!this._target || !this.offsetParent) return;
    var offset = this.offset; // If a marginTop has been provided by the user (pre 1.0.3), use it.

    if (this.marginTop != 14 && this.offset == 14) offset = this.marginTop;
    var parentRect = this.offsetParent.getBoundingClientRect();

    var targetRect = this._target.getBoundingClientRect();

    var thisRect = this.getBoundingClientRect();
    var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;
    var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;
    var targetLeft = targetRect.left - parentRect.left;
    var targetTop = targetRect.top - parentRect.top;
    var tooltipLeft, tooltipTop;

    switch (this.position) {
      case 'top':
        tooltipLeft = targetLeft + horizontalCenterOffset;
        tooltipTop = targetTop - thisRect.height - offset;
        break;

      case 'bottom':
        tooltipLeft = targetLeft + horizontalCenterOffset;
        tooltipTop = targetTop + targetRect.height + offset;
        break;

      case 'left':
        tooltipLeft = targetLeft - thisRect.width - offset;
        tooltipTop = targetTop + verticalCenterOffset;
        break;

      case 'right':
        tooltipLeft = targetLeft + targetRect.width + offset;
        tooltipTop = targetTop + verticalCenterOffset;
        break;
    } // TODO(noms): This should use IronFitBehavior if possible.


    if (this.fitToVisibleBounds) {
      // Clip the left/right side
      if (parentRect.left + tooltipLeft + thisRect.width > window.innerWidth) {
        this.style.right = '0px';
        this.style.left = 'auto';
      } else {
        this.style.left = Math.max(0, tooltipLeft) + 'px';
        this.style.right = 'auto';
      } // Clip the top/bottom side.


      if (parentRect.top + tooltipTop + thisRect.height > window.innerHeight) {
        this.style.bottom = parentRect.height - targetTop + offset + 'px';
        this.style.top = 'auto';
      } else {
        this.style.top = Math.max(-parentRect.top, tooltipTop) + 'px';
        this.style.bottom = 'auto';
      }
    } else {
      this.style.left = tooltipLeft + 'px';
      this.style.top = tooltipTop + 'px';
    }
  },
  _addListeners: function () {
    if (this._target) {
      this.listen(this._target, 'mouseenter', 'show');
      this.listen(this._target, 'focus', 'show');
      this.listen(this._target, 'mouseleave', 'hide');
      this.listen(this._target, 'blur', 'hide');
      this.listen(this._target, 'tap', 'hide');
    }

    this.listen(this.$.tooltip, 'animationend', '_onAnimationEnd');
    this.listen(this, 'mouseenter', 'hide');
  },
  _findTarget: function () {
    if (!this.manualMode) this._removeListeners();
    this._target = this.target;
    if (!this.manualMode) this._addListeners();
  },
  _delayChange: function (newValue) {
    // Only Update delay if different value set
    if (newValue !== 500) {
      this.updateStyles({
        '--paper-tooltip-delay-in': newValue + 'ms'
      });
    }
  },
  _manualModeChanged: function () {
    if (this.manualMode) this._removeListeners();else this._addListeners();
  },
  _cancelAnimation: function () {
    // Short-cut and cancel all animations and hide
    this.$.tooltip.classList.remove(this._getAnimationType('entry'));
    this.$.tooltip.classList.remove(this._getAnimationType('exit'));
    this.$.tooltip.classList.remove('cancel-animation');
    this.$.tooltip.classList.add('hidden');
  },
  _onAnimationFinish: function () {
    if (this._showing) {
      this.$.tooltip.classList.remove(this._getAnimationType('entry'));
      this.$.tooltip.classList.remove('cancel-animation');
      this.$.tooltip.classList.add(this._getAnimationType('exit'));
    }
  },
  _onAnimationEnd: function () {
    // If no longer showing add class hidden to completely hide tooltip
    this._animationPlaying = false;

    if (!this._showing) {
      this.$.tooltip.classList.remove(this._getAnimationType('exit'));
      this.$.tooltip.classList.add('hidden');
    }
  },
  _getAnimationType: function (type) {
    // These properties have priority over animationConfig values
    if (type === 'entry' && this.animationEntry !== '') {
      return this.animationEntry;
    }

    if (type === 'exit' && this.animationExit !== '') {
      return this.animationExit;
    } // If no results then return the legacy value from animationConfig


    if (this.animationConfig[type] && typeof this.animationConfig[type][0].name === 'string') {
      // Checking Timing and Update if necessary - Legacy for animationConfig
      if (this.animationConfig[type][0].timing && this.animationConfig[type][0].timing.delay && this.animationConfig[type][0].timing.delay !== 0) {
        var timingDelay = this.animationConfig[type][0].timing.delay; // Has Timing Change - Update CSS

        if (type === 'entry') {
          this.updateStyles({
            '--paper-tooltip-delay-in': timingDelay + 'ms'
          });
        } else if (type === 'exit') {
          this.updateStyles({
            '--paper-tooltip-delay-out': timingDelay + 'ms'
          });
        }
      }

      return this.animationConfig[type][0].name;
    }
  },
  _removeListeners: function () {
    if (this._target) {
      this.unlisten(this._target, 'mouseenter', 'show');
      this.unlisten(this._target, 'focus', 'show');
      this.unlisten(this._target, 'mouseleave', 'hide');
      this.unlisten(this._target, 'blur', 'hide');
      this.unlisten(this._target, 'tap', 'hide');
    }

    this.unlisten(this.$.tooltip, 'animationend', '_onAnimationEnd');
    this.unlisten(this, 'mouseenter', 'hide');
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template = html`
  <style include="paper-material-styles">
    :host {
      @apply --layout-vertical;
      @apply --layout-center-center;

      background: var(--paper-fab-background, var(--accent-color));
      border-radius: 50%;
      box-sizing: border-box;
      color: var(--text-primary-color);
      cursor: pointer;
      height: 56px;
      min-width: 0;
      outline: none;
      padding: 16px;
      position: relative;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      width: 56px;
      z-index: 0;

      /* NOTE: Both values are needed, since some phones require the value \`transparent\`. */
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      -webkit-tap-highlight-color: transparent;

      @apply --paper-fab;
    }

    [hidden] {
      display: none !important;
    }

    :host([mini]) {
      width: 40px;
      height: 40px;
      padding: 8px;

      @apply --paper-fab-mini;
    }

    :host([disabled]) {
      color: var(--paper-fab-disabled-text, var(--paper-grey-500));
      background: var(--paper-fab-disabled-background, var(--paper-grey-300));

      @apply --paper-fab-disabled;
    }

    iron-icon {
      @apply --paper-fab-iron-icon;
    }

    span {
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center;

      @apply --paper-fab-label;
    }

    :host(.keyboard-focus) {
      background: var(--paper-fab-keyboard-focus-background, var(--paper-pink-900));
    }

    :host([elevation="1"]) {
      @apply --paper-material-elevation-1;
    }

    :host([elevation="2"]) {
      @apply --paper-material-elevation-2;
    }

    :host([elevation="3"]) {
      @apply --paper-material-elevation-3;
    }

    :host([elevation="4"]) {
      @apply --paper-material-elevation-4;
    }

    :host([elevation="5"]) {
      @apply --paper-material-elevation-5;
    }
  </style>

  <iron-icon id="icon" hidden\$="{{!_computeIsIconFab(icon, src)}}" src="[[src]]" icon="[[icon]]"></iron-icon>
  <span hidden\$="{{_computeIsIconFab(icon, src)}}">{{label}}</span>
`;
template.setAttribute('strip-whitespace', '');
/**
Material design: [Floating Action
Button](https://www.google.com/design/spec/components/buttons-floating-action-button.html)

`paper-fab` is a floating action button. It contains an image placed in the
center and comes in two sizes: regular size and a smaller size by applying the
attribute `mini`. When the user touches the button, a ripple effect emanates
from the center of the button.

You may import `iron-icons` to use with this element, or provide a URL to a
custom icon. See `iron-iconset` for more information about how to use a custom
icon set.

Example:

    <script type="module">
      import '@polymer/iron-icons/iron-icons.js';
    </script>

    <paper-fab icon="add"></paper-fab>
    <paper-fab mini icon="favorite"></paper-fab>
    <paper-fab src="star.png"></paper-fab>


### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-fab-background` | The background color of the button | `--accent-color`
`--paper-fab-keyboard-focus-background` | The background color of the button when focused | `--paper-pink-900`
`--paper-fab-disabled-background` | The background color of the button when it's disabled | `--paper-grey-300`
`--paper-fab-disabled-text` | The text color of the button when it's disabled | `--paper-grey-500`
`--paper-fab` | Mixin applied to the button | `{}`
`--paper-fab-mini` | Mixin applied to a mini button | `{}`
`--paper-fab-disabled` | Mixin applied to a disabled button | `{}`
`--paper-fab-iron-icon` | Mixin applied to the iron-icon within the button | `{}`
`--paper-fab-label` | Mixin applied to the label within the button | `{}`

@group Paper Elements
@demo demo/index.html
*/

Polymer({
  _template: template,
  is: 'paper-fab',
  behaviors: [PaperButtonBehavior],
  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String,
      value: ''
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String,
      value: ''
    },

    /**
     * Set this to true to style this is a "mini" FAB.
     */
    mini: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The label displayed in the badge. The label is centered, and ideally
     * should have very few characters.
     */
    label: {
      type: String,
      observer: '_labelChanged'
    }
  },
  _labelChanged: function () {
    this.setAttribute('aria-label', this.label);
  },
  _computeIsIconFab: function (icon, src) {
    return icon.length > 0 || src.length > 0;
  }
});

/* **********************************************
     Begin prism-core.js
********************************************** */
/// <reference lib="WebWorker"/>
var _self = typeof window !== 'undefined' ? window // if in browser
: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
: {} // if in node js
;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */


var Prism$1 = function (_self) {
  // Private helper vars
  var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  var uniqueId = 0; // The grammar object for plaintext

  var plainTextGrammar = {};
  var _ = {
    /**
     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
     * additional languages or plugins yourself.
     *
     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
     *
     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.manual = true;
     * // add a new <script> to load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    manual: _self.Prism && _self.Prism.manual,
    disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

    /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */
    util: {
      encode: function encode(tokens) {
        if (tokens instanceof Token) {
          return new Token(tokens.type, encode(tokens.content), tokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(encode);
        } else {
          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
        }
      },

      /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */
      type: function (o) {
        return Object.prototype.toString.call(o).slice(8, -1);
      },

      /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */
      objId: function (obj) {
        if (!obj['__id']) {
          Object.defineProperty(obj, '__id', {
            value: ++uniqueId
          });
        }

        return obj['__id'];
      },

      /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */
      clone: function deepClone(o, visited) {
        visited = visited || {};
        var clone;
        var id;

        switch (_.util.type(o)) {
          case 'Object':
            id = _.util.objId(o);

            if (visited[id]) {
              return visited[id];
            }

            clone = {};
            visited[id] = clone;

            for (var key in o) {
              if (o.hasOwnProperty(key)) {
                clone[key] = deepClone(o[key], visited);
              }
            }

            return clone;

          case 'Array':
            id = _.util.objId(o);

            if (visited[id]) {
              return visited[id];
            }

            clone = [];
            visited[id] = clone;
            o.forEach(function (v, i) {
              clone[i] = deepClone(v, visited);
            });
            return clone;

          default:
            return o;
        }
      },

      /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */
      getLanguage: function (element) {
        while (element && !lang.test(element.className)) {
          element = element.parentElement;
        }

        if (element) {
          return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
        }

        return 'none';
      },

      /**
       * Returns the script element that is currently executing.
       *
       * This does __not__ work for line script element.
       *
       * @returns {HTMLScriptElement | null}
       */
      currentScript: function () {
        if (typeof document === 'undefined') {
          return null;
        }

        if ('currentScript' in document && 1 < 2
        /* hack to trip TS' flow analysis */
        ) {
          return document.currentScript;
        } // IE11 workaround
        // we'll get the src of the current script by parsing IE11's error stack trace
        // this will not work for inline scripts


        try {
          throw new Error();
        } catch (err) {
          // Get file src url from stack. Specifically works with the format of stack traces in IE.
          // A stack will look like this:
          //
          // Error
          //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
          //    at Global code (http://localhost/components/prism-core.js:606:1)
          var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];

          if (src) {
            var scripts = document.getElementsByTagName('script');

            for (var i in scripts) {
              if (scripts[i].src == src) {
                return scripts[i];
              }
            }
          }

          return null;
        }
      },

      /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */
      isActive: function (element, className, defaultActivation) {
        var no = 'no-' + className;

        while (element) {
          var classList = element.classList;

          if (classList.contains(className)) {
            return true;
          }

          if (classList.contains(no)) {
            return false;
          }

          element = element.parentElement;
        }

        return !!defaultActivation;
      }
    },

    /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */
    languages: {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,

      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: function (id, redef) {
        var lang = _.util.clone(_.languages[id]);

        for (var key in redef) {
          lang[key] = redef[key];
        }

        return lang;
      },

      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: function (inside, before, insert, root) {
        root = root || _.languages;
        var grammar = root[inside];
        /** @type {Grammar} */

        var ret = {};

        for (var token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            } // Do not insert token which also occur in insert. See #1525


            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }

        var old = root[inside];
        root[inside] = ret; // Update references in other language definitions

        _.languages.DFS(_.languages, function (key, value) {
          if (value === old && key != inside) {
            this[key] = ret;
          }
        });

        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o, callback, type, visited) {
        visited = visited || {};
        var objId = _.util.objId;

        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);
            var property = o[i];

            var propertyType = _.util.type(property);

            if (propertyType === 'Object' && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === 'Array' && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i, visited);
            }
          }
        }
      }
    },
    plugins: {},

    /**
     * This is the most high-level function in Prisms API.
     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
     * each one of them.
     *
     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
     *
     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
     * @memberof Prism
     * @public
     */
    highlightAll: function (async, callback) {
      _.highlightAllUnder(document, async, callback);
    },

    /**
     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
     * {@link Prism.highlightElement} on each one of them.
     *
     * The following hooks will be run:
     * 1. `before-highlightall`
     * 2. `before-all-elements-highlight`
     * 3. All hooks of {@link Prism.highlightElement} for each element.
     *
     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
     * @memberof Prism
     * @public
     */
    highlightAllUnder: function (container, async, callback) {
      var env = {
        callback: callback,
        container: container,
        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      };

      _.hooks.run('before-highlightall', env);

      env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

      _.hooks.run('before-all-elements-highlight', env);

      for (var i = 0, element; element = env.elements[i++];) {
        _.highlightElement(element, async === true, env.callback);
      }
    },

    /**
     * Highlights the code inside a single element.
     *
     * The following hooks will be run:
     * 1. `before-sanity-check`
     * 2. `before-highlight`
     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
     * 4. `before-insert`
     * 5. `after-highlight`
     * 6. `complete`
     *
     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
     * the element's language.
     *
     * @param {Element} element The element containing the code.
     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
     *
     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
     * asynchronous highlighting to work. You can build your own bundle on the
     * [Download page](https://prismjs.com/download.html).
     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
     * @memberof Prism
     * @public
     */
    highlightElement: function (element, async, callback) {
      // Find language
      var language = _.util.getLanguage(element);

      var grammar = _.languages[language]; // Set language on the element, if not present

      element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language; // Set language on the parent, for styling

      var parent = element.parentElement;

      if (parent && parent.nodeName.toLowerCase() === 'pre') {
        parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
      }

      var code = element.textContent;
      var env = {
        element: element,
        language: language,
        grammar: grammar,
        code: code
      };

      function insertHighlightedCode(highlightedCode) {
        env.highlightedCode = highlightedCode;

        _.hooks.run('before-insert', env);

        env.element.innerHTML = env.highlightedCode;

        _.hooks.run('after-highlight', env);

        _.hooks.run('complete', env);

        callback && callback.call(env.element);
      }

      _.hooks.run('before-sanity-check', env); // plugins may change/add the parent/element


      parent = env.element.parentElement;

      if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
        parent.setAttribute('tabindex', '0');
      }

      if (!env.code) {
        _.hooks.run('complete', env);

        callback && callback.call(env.element);
        return;
      }

      _.hooks.run('before-highlight', env);

      if (!env.grammar) {
        insertHighlightedCode(_.util.encode(env.code));
        return;
      }

      if (async && _self.Worker) {
        var worker = new Worker(_.filename);

        worker.onmessage = function (evt) {
          insertHighlightedCode(evt.data);
        };

        worker.postMessage(JSON.stringify({
          language: env.language,
          code: env.code,
          immediateClose: true
        }));
      } else {
        insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
      }
    },

    /**
     * Low-level function, only use if you know what youre doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */
    highlight: function (text, grammar, language) {
      var env = {
        code: text,
        grammar: grammar,
        language: language
      };

      _.hooks.run('before-tokenize', env);

      env.tokens = _.tokenize(env.code, env.grammar);

      _.hooks.run('after-tokenize', env);

      return Token.stringify(_.util.encode(env.tokens), env.language);
    },

    /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */
    tokenize: function (text, grammar) {
      var rest = grammar.rest;

      if (rest) {
        for (var token in rest) {
          grammar[token] = rest[token];
        }

        delete grammar.rest;
      }

      var tokenList = new LinkedList();
      addAfter(tokenList, tokenList.head, text);
      matchGrammar(text, tokenList, grammar, tokenList.head, 0);
      return toArray(tokenList);
    },

    /**
     * @namespace
     * @memberof Prism
     * @public
     */
    hooks: {
      all: {},

      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function (name, callback) {
        var hooks = _.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },

      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function (name, env) {
        var callbacks = _.hooks.all[name];

        if (!callbacks || !callbacks.length) {
          return;
        }

        for (var i = 0, callback; callback = callbacks[i++];) {
          callback(env);
        }
      }
    },
    Token: Token
  };
  _self.Prism = _; // Typescript note:
  // The following can be used to import the Token type in JSDoc:
  //
  //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

  /**
   * Creates a new token.
   *
   * @param {string} type See {@link Token#type type}
   * @param {string | TokenStream} content See {@link Token#content content}
   * @param {string|string[]} [alias] The alias(es) of the token.
   * @param {string} [matchedStr=""] A copy of the full string this token was created from.
   * @class
   * @global
   * @public
   */

  function Token(type, content, alias, matchedStr) {
    /**
     * The type of the token.
     *
     * This is usually the key of a pattern in a {@link Grammar}.
     *
     * @type {string}
     * @see GrammarToken
     * @public
     */
    this.type = type;
    /**
     * The strings or tokens contained by this token.
     *
     * This will be a token stream if the pattern matched also defined an `inside` grammar.
     *
     * @type {string | TokenStream}
     * @public
     */

    this.content = content;
    /**
     * The alias(es) of the token.
     *
     * @type {string|string[]}
     * @see GrammarToken
     * @public
     */

    this.alias = alias; // Copy of the full string this token was created from

    this.length = (matchedStr || '').length | 0;
  }
  /**
   * A token stream is an array of strings and {@link Token Token} objects.
   *
   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
   * them.
   *
   * 1. No adjacent strings.
   * 2. No empty strings.
   *
   *    The only exception here is the token stream that only contains the empty string and nothing else.
   *
   * @typedef {Array<string | Token>} TokenStream
   * @global
   * @public
   */

  /**
   * Converts the given token or token stream to an HTML representation.
   *
   * The following hooks will be run:
   * 1. `wrap`: On each {@link Token}.
   *
   * @param {string | Token | TokenStream} o The token or token stream to be converted.
   * @param {string} language The name of current language.
   * @returns {string} The HTML representation of the token or token stream.
   * @memberof Token
   * @static
   */


  Token.stringify = function stringify(o, language) {
    if (typeof o == 'string') {
      return o;
    }

    if (Array.isArray(o)) {
      var s = '';
      o.forEach(function (e) {
        s += stringify(e, language);
      });
      return s;
    }

    var env = {
      type: o.type,
      content: stringify(o.content, language),
      tag: 'span',
      classes: ['token', o.type],
      attributes: {},
      language: language
    };
    var aliases = o.alias;

    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }

    _.hooks.run('wrap', env);

    var attributes = '';

    for (var name in env.attributes) {
      attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    }

    return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
  };
  /**
   * @param {RegExp} pattern
   * @param {number} pos
   * @param {string} text
   * @param {boolean} lookbehind
   * @returns {RegExpExecArray | null}
   */


  function matchPattern(pattern, pos, text, lookbehind) {
    pattern.lastIndex = pos;
    var match = pattern.exec(text);

    if (match && lookbehind && match[1]) {
      // change the match to remove the text matched by the Prism lookbehind group
      var lookbehindLength = match[1].length;
      match.index += lookbehindLength;
      match[0] = match[0].slice(lookbehindLength);
    }

    return match;
  }
  /**
   * @param {string} text
   * @param {LinkedList<string | Token>} tokenList
   * @param {any} grammar
   * @param {LinkedListNode<string | Token>} startNode
   * @param {number} startPos
   * @param {RematchOptions} [rematch]
   * @returns {void}
   * @private
   *
   * @typedef RematchOptions
   * @property {string} cause
   * @property {number} reach
   */


  function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
    for (var token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }

      var patterns = grammar[token];
      patterns = Array.isArray(patterns) ? patterns : [patterns];

      for (var j = 0; j < patterns.length; ++j) {
        if (rematch && rematch.cause == token + ',' + j) {
          return;
        }

        var patternObj = patterns[j];
        var inside = patternObj.inside;
        var lookbehind = !!patternObj.lookbehind;
        var greedy = !!patternObj.greedy;
        var alias = patternObj.alias;

        if (greedy && !patternObj.pattern.global) {
          // Without the global flag, lastIndex won't work
          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
          patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
        }
        /** @type {RegExp} */


        var pattern = patternObj.pattern || patternObj;

        for ( // iterate the token list and keep track of the current token/string position
        var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
          if (rematch && pos >= rematch.reach) {
            break;
          }

          var str = currentNode.value;

          if (tokenList.length > text.length) {
            // Something went terribly wrong, ABORT, ABORT!
            return;
          }

          if (str instanceof Token) {
            continue;
          }

          var removeCount = 1; // this is the to parameter of removeBetween

          var match;

          if (greedy) {
            match = matchPattern(pattern, pos, text, lookbehind);

            if (!match) {
              break;
            }

            var from = match.index;
            var to = match.index + match[0].length;
            var p = pos; // find the node that contains the match

            p += currentNode.value.length;

            while (from >= p) {
              currentNode = currentNode.next;
              p += currentNode.value.length;
            } // adjust pos (and p)


            p -= currentNode.value.length;
            pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid

            if (currentNode.value instanceof Token) {
              continue;
            } // find the last node which is affected by this match


            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {
              removeCount++;
              p += k.value.length;
            }

            removeCount--; // replace with the new match

            str = text.slice(pos, p);
            match.index -= pos;
          } else {
            match = matchPattern(pattern, 0, str, lookbehind);

            if (!match) {
              continue;
            }
          } // eslint-disable-next-line no-redeclare


          var from = match.index;
          var matchStr = match[0];
          var before = str.slice(0, from);
          var after = str.slice(from + matchStr.length);
          var reach = pos + str.length;

          if (rematch && reach > rematch.reach) {
            rematch.reach = reach;
          }

          var removeFrom = currentNode.prev;

          if (before) {
            removeFrom = addAfter(tokenList, removeFrom, before);
            pos += before.length;
          }

          removeRange(tokenList, removeFrom, removeCount);
          var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
          currentNode = addAfter(tokenList, removeFrom, wrapped);

          if (after) {
            addAfter(tokenList, currentNode, after);
          }

          if (removeCount > 1) {
            // at least one Token object was removed, so we have to do some rematching
            // this can only happen if the current pattern is greedy

            /** @type {RematchOptions} */
            var nestedRematch = {
              cause: token + ',' + j,
              reach: reach
            };
            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch); // the reach might have been extended because of the rematching

            if (rematch && nestedRematch.reach > rematch.reach) {
              rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
  }
  /**
   * @typedef LinkedListNode
   * @property {T} value
   * @property {LinkedListNode<T> | null} prev The previous node.
   * @property {LinkedListNode<T> | null} next The next node.
   * @template T
   * @private
   */

  /**
   * @template T
   * @private
   */


  function LinkedList() {
    /** @type {LinkedListNode<T>} */
    var head = {
      value: null,
      prev: null,
      next: null
    };
    /** @type {LinkedListNode<T>} */

    var tail = {
      value: null,
      prev: head,
      next: null
    };
    head.next = tail;
    /** @type {LinkedListNode<T>} */

    this.head = head;
    /** @type {LinkedListNode<T>} */

    this.tail = tail;
    this.length = 0;
  }
  /**
   * Adds a new node with the given value to the list.
   *
   * @param {LinkedList<T>} list
   * @param {LinkedListNode<T>} node
   * @param {T} value
   * @returns {LinkedListNode<T>} The added node.
   * @template T
   */


  function addAfter(list, node, value) {
    // assumes that node != list.tail && values.length >= 0
    var next = node.next;
    var newNode = {
      value: value,
      prev: node,
      next: next
    };
    node.next = newNode;
    next.prev = newNode;
    list.length++;
    return newNode;
  }
  /**
   * Removes `count` nodes after the given node. The given node will not be removed.
   *
   * @param {LinkedList<T>} list
   * @param {LinkedListNode<T>} node
   * @param {number} count
   * @template T
   */


  function removeRange(list, node, count) {
    var next = node.next;

    for (var i = 0; i < count && next !== list.tail; i++) {
      next = next.next;
    }

    node.next = next;
    next.prev = node;
    list.length -= i;
  }
  /**
   * @param {LinkedList<T>} list
   * @returns {T[]}
   * @template T
   */


  function toArray(list) {
    var array = [];
    var node = list.head.next;

    while (node !== list.tail) {
      array.push(node.value);
      node = node.next;
    }

    return array;
  }

  if (!_self.document) {
    if (!_self.addEventListener) {
      // in Node.js
      return _;
    }

    if (!_.disableWorkerMessageHandler) {
      // In worker
      _self.addEventListener('message', function (evt) {
        var message = JSON.parse(evt.data);
        var lang = message.language;
        var code = message.code;
        var immediateClose = message.immediateClose;

        _self.postMessage(_.highlight(code, _.languages[lang], lang));

        if (immediateClose) {
          _self.close();
        }
      }, false);
    }

    return _;
  } // Get current script and highlight


  var script = _.util.currentScript();

  if (script) {
    _.filename = script.src;

    if (script.hasAttribute('data-manual')) {
      _.manual = true;
    }
  }

  function highlightAutomaticallyCallback() {
    if (!_.manual) {
      _.highlightAll();
    }
  }

  if (!_.manual) {
    // If the document state is "loading", then we'll use DOMContentLoaded.
    // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
    // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
    // might take longer one animation frame to execute which can create a race condition where only some plugins have
    // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
    // See https://github.com/PrismJS/prism/issues/2102
    var readyState = document.readyState;

    if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
      document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(highlightAutomaticallyCallback);
      } else {
        window.setTimeout(highlightAutomaticallyCallback, 16);
      }
    }
  }

  return _;
}(_self);

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Prism$1;
} // hack for components to work correctly in node.js


if (typeof global !== 'undefined') {
  global.Prism = Prism$1;
} // some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */

/* **********************************************
     Begin prism-markup.js
********************************************** */


Prism$1.languages.markup = {
  'comment': /<!--[\s\S]*?-->/,
  'prolog': /<\?[\s\S]+?\?>/,
  'doctype': {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      'internal-subset': {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null // see below

      },
      'string': {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      'punctuation': /^<!|>$|[[\]]/,
      'doctype-tag': /^DOCTYPE/,
      'name': /[^\s<>'"]+/
    }
  },
  'cdata': /<!\[CDATA\[[\s\S]*?\]\]>/i,
  'tag': {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      'tag': {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          'punctuation': /^<\/?/,
          'namespace': /^[^\s>\/:]+:/
        }
      },
      'special-attr': [],
      'attr-value': {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          'punctuation': [{
            pattern: /^=/,
            alias: 'attr-equals'
          }, /"|'/]
        }
      },
      'punctuation': /\/?>/,
      'attr-name': {
        pattern: /[^\s>\/]+/,
        inside: {
          'namespace': /^[^\s>\/:]+:/
        }
      }
    }
  },
  'entity': [{
    pattern: /&[\da-z]{1,8};/i,
    alias: 'named-entity'
  }, /&#x?[\da-f]{1,8};/i]
};
Prism$1.languages.markup['tag'].inside['attr-value'].inside['entity'] = Prism$1.languages.markup['entity'];
Prism$1.languages.markup['doctype'].inside['internal-subset'].inside = Prism$1.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov

Prism$1.hooks.add('wrap', function (env) {
  if (env.type === 'entity') {
    env.attributes['title'] = env.content.replace(/&amp;/, '&');
  }
});
Object.defineProperty(Prism$1.languages.markup.tag, 'addInlined', {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside['language-' + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism$1.languages[lang]
    };
    includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      'included-cdata': {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside['language-' + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism$1.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
        return tagName;
      }), 'i'),
      lookbehind: true,
      greedy: true,
      inside: inside
    };
    Prism$1.languages.insertBefore('markup', 'cdata', def);
  }
});
Object.defineProperty(Prism$1.languages.markup.tag, 'addAttribute', {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function (attrName, lang) {
    Prism$1.languages.markup.tag.inside['special-attr'].push({
      pattern: RegExp(/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, 'i'),
      lookbehind: true,
      inside: {
        'attr-name': /^[^\s=]+/,
        'attr-value': {
          pattern: /=[\s\S]+/,
          inside: {
            'value': {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, 'language-' + lang],
              inside: Prism$1.languages[lang]
            },
            'punctuation': [{
              pattern: /^=/,
              alias: 'attr-equals'
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism$1.languages.html = Prism$1.languages.markup;
Prism$1.languages.mathml = Prism$1.languages.markup;
Prism$1.languages.svg = Prism$1.languages.markup;
Prism$1.languages.xml = Prism$1.languages.extend('markup', {});
Prism$1.languages.ssml = Prism$1.languages.xml;
Prism$1.languages.atom = Prism$1.languages.xml;
Prism$1.languages.rss = Prism$1.languages.xml;
/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism.languages.css = {
    'comment': /\/\*[\s\S]*?\*\//,
    'atrule': {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        'rule': /^@[\w-]+/,
        'selector-function-argument': {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: 'selector'
        },
        'keyword': {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        } // See rest below

      }
    },
    'url': {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
      greedy: true,
      inside: {
        'function': /^url/i,
        'punctuation': /^\(|\)$/,
        'string': {
          pattern: RegExp('^' + string.source + '$'),
          alias: 'url'
        }
      }
    },
    'selector': {
      pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
      lookbehind: true
    },
    'string': {
      pattern: string,
      greedy: true
    },
    'property': {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    'important': /!important\b/i,
    'function': {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    'punctuation': /[(){};:,]/
  };
  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
  var markup = Prism.languages.markup;

  if (markup) {
    markup.tag.addInlined('style', 'css');
    markup.tag.addAttribute('style', 'css');
  }
})(Prism$1);
/* **********************************************
     Begin prism-clike.js
********************************************** */


Prism$1.languages.clike = {
  'comment': [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  'string': {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  'class-name': {
    pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      'punctuation': /[.\\]/
    }
  },
  'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
  'boolean': /\b(?:true|false)\b/,
  'function': /\b\w+(?=\()/,
  'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  'punctuation': /[{}[\];(),.:]/
};
/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism$1.languages.javascript = Prism$1.languages.extend('clike', {
  'class-name': [Prism$1.languages.clike['class-name'], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
    lookbehind: true
  }],
  'keyword': [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
  'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism$1.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
Prism$1.languages.insertBefore('javascript', 'keyword', {
  'regex': {
    // eslint-disable-next-line regexp/no-dupe-characters-character-class
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
    lookbehind: true,
    greedy: true,
    inside: {
      'regex-source': {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: 'language-regex',
        inside: Prism$1.languages.regex
      },
      'regex-delimiter': /^\/|\/$/,
      'regex-flags': /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  'function-variable': {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: 'function'
  },
  'parameter': [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism$1.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism$1.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism$1.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism$1.languages.javascript
  }],
  'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism$1.languages.insertBefore('javascript', 'string', {
  'hashbang': {
    pattern: /^#!.*/,
    greedy: true,
    alias: 'comment'
  },
  'template-string': {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      'template-punctuation': {
        pattern: /^`|`$/,
        alias: 'string'
      },
      'interpolation': {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          'interpolation-punctuation': {
            pattern: /^\$\{|\}$/,
            alias: 'punctuation'
          },
          rest: Prism$1.languages.javascript
        }
      },
      'string': /[\s\S]+/
    }
  }
});

if (Prism$1.languages.markup) {
  Prism$1.languages.markup.tag.addInlined('script', 'javascript'); // add attribute support for all DOM events.
  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events

  Prism$1.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');
}

Prism$1.languages.js = Prism$1.languages.javascript;
/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
  if (typeof Prism$1 === 'undefined' || typeof document === 'undefined') {
    return;
  } // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill


  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }

  var LOADING_MESSAGE = 'Loading';

  var FAILURE_MESSAGE = function (status, message) {
    return ' Error ' + status + ' while fetching file: ' + message;
  };

  var FAILURE_EMPTY_MESSAGE = ' Error: File does not exist or is empty';
  var EXTENSIONS = {
    'js': 'javascript',
    'py': 'python',
    'rb': 'ruby',
    'ps1': 'powershell',
    'psm1': 'powershell',
    'sh': 'bash',
    'bat': 'batch',
    'h': 'c',
    'tex': 'latex'
  };
  var STATUS_ATTR = 'data-src-status';
  var STATUS_LOADING = 'loading';
  var STATUS_LOADED = 'loaded';
  var STATUS_FAILED = 'failed';
  var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
  var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  /**
   * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
   *
   * @param {HTMLElement} element
   * @param {string} language
   * @returns {void}
   */

  function setLanguageClass(element, language) {
    var className = element.className;
    className = className.replace(lang, ' ') + ' language-' + language;
    element.className = className.replace(/\s+/g, ' ').trim();
  }

  Prism$1.hooks.add('before-highlightall', function (env) {
    env.selector += ', ' + SELECTOR;
  });
  Prism$1.hooks.add('before-sanity-check', function (env) {
    var pre = env.element;

    if (pre.matches(SELECTOR)) {
      env.code = ''; // fast-path the whole thing and go to complete

      pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
      // add code element with loading message

      var code = pre.appendChild(document.createElement('CODE'));
      code.textContent = LOADING_MESSAGE;
      var src = pre.getAttribute('data-src');
      var language = env.language;

      if (language === 'none') {
        // the language might be 'none' because there is no language set;
        // in this case, we want to use the extension as the language
        var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
        language = EXTENSIONS[extension] || extension;
      } // set language classes


      setLanguageClass(code, language);
      setLanguageClass(pre, language); // preload the language

      var autoloader = Prism$1.plugins.autoloader;

      if (autoloader) {
        autoloader.loadLanguages(language);
      } // load file


      var xhr = new XMLHttpRequest();
      xhr.open('GET', src, true);

      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText) {
            // mark as loaded
            pre.setAttribute(STATUS_ATTR, STATUS_LOADED); // highlight code

            code.textContent = xhr.responseText;
            Prism$1.highlightElement(code);
          } else {
            // mark as failed
            pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

            if (xhr.status >= 400) {
              code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
            } else {
              code.textContent = FAILURE_EMPTY_MESSAGE;
            }
          }
        }
      };

      xhr.send(null);
    }
  });
  Prism$1.plugins.fileHighlight = {
    /**
     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
     *
     * Note: Elements which are already loaded or currently loading will not be touched by this method.
     *
     * @param {ParentNode} [container=document]
     */
    highlight: function highlight(container) {
      var elements = (container || document).querySelectorAll(SELECTOR);

      for (var i = 0, element; element = elements[i++];) {
        Prism$1.highlightElement(element);
      }
    }
  };
  var logged = false;
  /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */

  Prism$1.fileHighlight = function () {
    if (!logged) {
      console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
      logged = true;
    }

    Prism$1.plugins.fileHighlight.highlight.apply(this, arguments);
  };
})();

(function (Prism) {
  Prism.languages.xquery = Prism.languages.extend('markup', {
    'xquery-comment': {
      pattern: /\(:[\s\S]*?:\)/,
      greedy: true,
      alias: 'comment'
    },
    'string': {
      pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
      greedy: true
    },
    'extension': {
      pattern: /\(#.+?#\)/,
      alias: 'symbol'
    },
    'variable': /\$[-\w:]+/,
    'axis': {
      pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
      lookbehind: true,
      alias: 'operator'
    },
    'keyword-operator': {
      pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
      lookbehind: true,
      alias: 'operator'
    },
    'keyword': {
      pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
      lookbehind: true
    },
    'function': /[\w-]+(?::[\w-]+)*(?=\s*\()/,
    'xquery-element': {
      pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
      lookbehind: true,
      alias: 'tag'
    },
    'xquery-attribute': {
      pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
      lookbehind: true,
      alias: 'attr-name'
    },
    'builtin': {
      pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
      lookbehind: true
    },
    'number': /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
    'operator': [/[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/, {
      pattern: /(\s)-(?=\s)/,
      lookbehind: true
    }],
    'punctuation': /[[\](){},;:/]/
  });
  Prism.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
  Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/i;
  Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^="|"$/;
  Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {
    // Allow for two levels of nesting
    pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
    inside: Prism.languages.xquery,
    alias: 'language-xquery'
  }; // The following will handle plain text inside tags

  var stringifyToken = function (token) {
    if (typeof token === 'string') {
      return token;
    }

    if (typeof token.content === 'string') {
      return token.content;
    }

    return token.content.map(stringifyToken).join('');
  };

  var walkTokens = function (tokens) {
    var openedTags = [];

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      var notTagNorBrace = false;

      if (typeof token !== 'string') {
        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
          // We found a tag, now find its kind
          if (token.content[0].content[0].content === '</') {
            // Closing tag
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
              // Pop matching opening tag
              openedTags.pop();
            }
          } else {
            if (token.content[token.content.length - 1].content === '/>') ; else {
              // Opening tag
              openedTags.push({
                tagName: stringifyToken(token.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && (!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {
          // Here we might have entered an XQuery expression inside a tag
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {
          // Here we might have left an XQuery expression inside a tag
          openedTags[openedTags.length - 1].openedBraces--;
        } else if (token.type !== 'comment') {
          notTagNorBrace = true;
        }
      }

      if (notTagNorBrace || typeof token === 'string') {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          // Here we are inside a tag, and not inside an XQuery expression.
          // That's plain text: drop any tokens matched.
          var plainText = stringifyToken(token); // And merge text with adjacent text

          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {
            plainText += stringifyToken(tokens[i + 1]);
            tokens.splice(i + 1, 1);
          }

          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {
            plainText = stringifyToken(tokens[i - 1]) + plainText;
            tokens.splice(i - 1, 1);
            i--;
          }

          if (/^\s+$/.test(plainText)) {
            tokens[i] = plainText;
          } else {
            tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);
          }
        }
      }

      if (token.content && typeof token.content !== 'string') {
        walkTokens(token.content);
      }
    }
  };

  Prism.hooks.add('after-tokenize', function (env) {
    if (env.language !== 'xquery') {
      return;
    }

    walkTokens(env.tokens);
  });
})(Prism);

(function () {
  if (typeof Prism === 'undefined' || typeof document === 'undefined') {
    return;
  }

  var assign = Object.assign || function (obj1, obj2) {
    for (var name in obj2) {
      if (obj2.hasOwnProperty(name)) {
        obj1[name] = obj2[name];
      }
    }

    return obj1;
  };

  function NormalizeWhitespace(defaults) {
    this.defaults = assign({}, defaults);
  }

  function toCamelCase(value) {
    return value.replace(/-(\w)/g, function (match, firstChar) {
      return firstChar.toUpperCase();
    });
  }

  function tabLen(str) {
    var res = 0;

    for (var i = 0; i < str.length; ++i) {
      if (str.charCodeAt(i) == '\t'.charCodeAt(0)) {
        res += 3;
      }
    }

    return str.length + res;
  }

  NormalizeWhitespace.prototype = {
    setDefaults: function (defaults) {
      this.defaults = assign(this.defaults, defaults);
    },
    normalize: function (input, settings) {
      settings = assign(this.defaults, settings);

      for (var name in settings) {
        var methodName = toCamelCase(name);

        if (name !== 'normalize' && methodName !== 'setDefaults' && settings[name] && this[methodName]) {
          input = this[methodName].call(this, input, settings[name]);
        }
      }

      return input;
    },

    /*
     * Normalization methods
     */
    leftTrim: function (input) {
      return input.replace(/^\s+/, '');
    },
    rightTrim: function (input) {
      return input.replace(/\s+$/, '');
    },
    tabsToSpaces: function (input, spaces) {
      spaces = spaces | 0 || 4;
      return input.replace(/\t/g, new Array(++spaces).join(' '));
    },
    spacesToTabs: function (input, spaces) {
      spaces = spaces | 0 || 4;
      return input.replace(RegExp(' {' + spaces + '}', 'g'), '\t');
    },
    removeTrailing: function (input) {
      return input.replace(/\s*?$/gm, '');
    },
    // Support for deprecated plugin remove-initial-line-feed
    removeInitialLineFeed: function (input) {
      return input.replace(/^(?:\r?\n|\r)/, '');
    },
    removeIndent: function (input) {
      var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);

      if (!indents || !indents[0].length) {
        return input;
      }

      indents.sort(function (a, b) {
        return a.length - b.length;
      });

      if (!indents[0].length) {
        return input;
      }

      return input.replace(RegExp('^' + indents[0], 'gm'), '');
    },
    indent: function (input, tabs) {
      return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join('\t') + '$&');
    },
    breakLines: function (input, characters) {
      characters = characters === true ? 80 : characters | 0 || 80;
      var lines = input.split('\n');

      for (var i = 0; i < lines.length; ++i) {
        if (tabLen(lines[i]) <= characters) {
          continue;
        }

        var line = lines[i].split(/(\s+)/g);
        var len = 0;

        for (var j = 0; j < line.length; ++j) {
          var tl = tabLen(line[j]);
          len += tl;

          if (len > characters) {
            line[j] = '\n' + line[j];
            len = tl;
          }
        }

        lines[i] = line.join('');
      }

      return lines.join('\n');
    }
  }; // Support node modules

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = NormalizeWhitespace;
  } // Exit if prism is not loaded


  if (typeof Prism === 'undefined') {
    return;
  }

  Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
    'remove-trailing': true,
    'remove-indent': true,
    'left-trim': true,
    'right-trim': true
    /*'break-lines': 80,
    'indent': 2,
    'remove-initial-line-feed': false,
    'tabs-to-spaces': 4,
    'spaces-to-tabs': 4*/

  });
  Prism.hooks.add('before-sanity-check', function (env) {
    var Normalizer = Prism.plugins.NormalizeWhitespace; // Check settings

    if (env.settings && env.settings['whitespace-normalization'] === false) {
      return;
    } // Check classes


    if (!Prism.util.isActive(env.element, 'whitespace-normalization', true)) {
      return;
    } // Simple mode if there is no env.element


    if ((!env.element || !env.element.parentNode) && env.code) {
      env.code = Normalizer.normalize(env.code, env.settings);
      return;
    } // Normal mode


    var pre = env.element.parentNode;

    if (!env.code || !pre || pre.nodeName.toLowerCase() !== 'pre') {
      return;
    }

    var children = pre.childNodes;
    var before = '';
    var after = '';
    var codeFound = false; // Move surrounding whitespace from the <pre> tag into the <code> tag

    for (var i = 0; i < children.length; ++i) {
      var node = children[i];

      if (node == env.element) {
        codeFound = true;
      } else if (node.nodeName === '#text') {
        if (codeFound) {
          after += node.nodeValue;
        } else {
          before += node.nodeValue;
        }

        pre.removeChild(node);
        --i;
      }
    }

    if (!env.element.children.length || !Prism.plugins.KeepMarkup) {
      env.code = before + env.code + after;
      env.code = Normalizer.normalize(env.code, env.settings);
    } else {
      // Preserve markup for keep-markup plugin
      var html = before + env.element.innerHTML + after;
      env.element.innerHTML = Normalizer.normalize(html, env.settings);
      env.code = env.element.textContent;
    }
  });
})();

(function () {
  if (typeof Prism === 'undefined' || typeof document === 'undefined') {
    return;
  }
  /**
   * Plugin name which is used as a class name for <pre> which is activating the plugin
   *
   * @type {string}
   */


  var PLUGIN_NAME = 'line-numbers';
  /**
   * Regular expression used for determining line breaks
   *
   * @type {RegExp}
   */

  var NEW_LINE_EXP = /\n(?!$)/g;
  /**
   * Global exports
   */

  var config = Prism.plugins.lineNumbers = {
    /**
     * Get node for provided line number
     *
     * @param {Element} element pre element
     * @param {number} number line number
     * @returns {Element|undefined}
     */
    getLine: function (element, number) {
      if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
        return;
      }

      var lineNumberRows = element.querySelector('.line-numbers-rows');

      if (!lineNumberRows) {
        return;
      }

      var lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;
      var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);

      if (number < lineNumberStart) {
        number = lineNumberStart;
      }

      if (number > lineNumberEnd) {
        number = lineNumberEnd;
      }

      var lineIndex = number - lineNumberStart;
      return lineNumberRows.children[lineIndex];
    },

    /**
     * Resizes the line numbers of the given element.
     *
     * This function will not add line numbers. It will only resize existing ones.
     *
     * @param {HTMLElement} element A `<pre>` element with line numbers.
     * @returns {void}
     */
    resize: function (element) {
      resizeElements([element]);
    },

    /**
     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
     * the current viewport.
     *
     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
     *
     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
     *
     * @type {boolean}
     */
    assumeViewportIndependence: true
  };
  /**
   * Resizes the given elements.
   *
   * @param {HTMLElement[]} elements
   */

  function resizeElements(elements) {
    elements = elements.filter(function (e) {
      var codeStyles = getStyles(e);
      var whiteSpace = codeStyles['white-space'];
      return whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line';
    });

    if (elements.length == 0) {
      return;
    }

    var infos = elements.map(function (element) {
      var codeElement = element.querySelector('code');
      var lineNumbersWrapper = element.querySelector('.line-numbers-rows');

      if (!codeElement || !lineNumbersWrapper) {
        return undefined;
      }
      /** @type {HTMLElement} */


      var lineNumberSizer = element.querySelector('.line-numbers-sizer');
      var codeLines = codeElement.textContent.split(NEW_LINE_EXP);

      if (!lineNumberSizer) {
        lineNumberSizer = document.createElement('span');
        lineNumberSizer.className = 'line-numbers-sizer';
        codeElement.appendChild(lineNumberSizer);
      }

      lineNumberSizer.innerHTML = '0';
      lineNumberSizer.style.display = 'block';
      var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
      lineNumberSizer.innerHTML = '';
      return {
        element: element,
        lines: codeLines,
        lineHeights: [],
        oneLinerHeight: oneLinerHeight,
        sizer: lineNumberSizer
      };
    }).filter(Boolean);
    infos.forEach(function (info) {
      var lineNumberSizer = info.sizer;
      var lines = info.lines;
      var lineHeights = info.lineHeights;
      var oneLinerHeight = info.oneLinerHeight;
      lineHeights[lines.length - 1] = undefined;
      lines.forEach(function (line, index) {
        if (line && line.length > 1) {
          var e = lineNumberSizer.appendChild(document.createElement('span'));
          e.style.display = 'block';
          e.textContent = line;
        } else {
          lineHeights[index] = oneLinerHeight;
        }
      });
    });
    infos.forEach(function (info) {
      var lineNumberSizer = info.sizer;
      var lineHeights = info.lineHeights;
      var childIndex = 0;

      for (var i = 0; i < lineHeights.length; i++) {
        if (lineHeights[i] === undefined) {
          lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
        }
      }
    });
    infos.forEach(function (info) {
      var lineNumberSizer = info.sizer;
      var wrapper = info.element.querySelector('.line-numbers-rows');
      lineNumberSizer.style.display = 'none';
      lineNumberSizer.innerHTML = '';
      info.lineHeights.forEach(function (height, lineNumber) {
        wrapper.children[lineNumber].style.height = height + 'px';
      });
    });
  }
  /**
   * Returns style declarations for the element
   *
   * @param {Element} element
   */


  function getStyles(element) {
    if (!element) {
      return null;
    }

    return window.getComputedStyle ? getComputedStyle(element) : element.currentStyle || null;
  }

  var lastWidth = undefined;
  window.addEventListener('resize', function () {
    if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
      return;
    }

    lastWidth = window.innerWidth;
    resizeElements(Array.prototype.slice.call(document.querySelectorAll('pre.' + PLUGIN_NAME)));
  });
  Prism.hooks.add('complete', function (env) {
    if (!env.code) {
      return;
    }

    var code = env.element;
    var pre = code.parentNode; // works only for <code> wrapped inside <pre> (not inline)

    if (!pre || !/pre/i.test(pre.nodeName)) {
      return;
    } // Abort if line numbers already exists


    if (code.querySelector('.line-numbers-rows')) {
      return;
    } // only add line numbers if <code> or one of its ancestors has the `line-numbers` class


    if (!Prism.util.isActive(code, PLUGIN_NAME)) {
      return;
    } // Remove the class 'line-numbers' from the <code>


    code.classList.remove(PLUGIN_NAME); // Add the class 'line-numbers' to the <pre>

    pre.classList.add(PLUGIN_NAME);
    var match = env.code.match(NEW_LINE_EXP);
    var linesNum = match ? match.length + 1 : 1;
    var lineNumbersWrapper;
    var lines = new Array(linesNum + 1).join('<span></span>');
    lineNumbersWrapper = document.createElement('span');
    lineNumbersWrapper.setAttribute('aria-hidden', 'true');
    lineNumbersWrapper.className = 'line-numbers-rows';
    lineNumbersWrapper.innerHTML = lines;

    if (pre.hasAttribute('data-start')) {
      pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
    }

    env.element.appendChild(lineNumbersWrapper);
    resizeElements([pre]);
    Prism.hooks.run('line-numbers', env);
  });
  Prism.hooks.add('line-numbers', function (env) {
    env.plugins = env.plugins || {};
    env.plugins.lineNumbers = true;
  });
})();

/**
 * Highlight a code snippet. The snippet may either be passed in a template child
 * element, which could contain HTML or text. If no template child is present, the
 * component will take any text content contained in it and highlight it. One can also
 * pass the code to be highlighted in the `code` property.
 *
 * @cssprop [--pb-code-highlight-white-space=pre] - configures line wrapping
 */

class PbCodeHighlight extends LitElement {
  static get properties() {
    return {
      /**
       * The language to be used for syntax highlighting.
       */
      language: {
        type: String
      },

      /**
       * The code to be highlighted as a string. If not set,
       * this will be populated from either a template child element
       * or the element's text content.
       */
      code: {
        type: String
      },

      /**
       * Highlighting theme to use: 'coy', 'dark', 'funky', 'okaida', 'solarizedlight',
       * 'tomorrow', 'twilight' or 'default'.
       */
      theme: {
        type: String
      },
      lineNumbers: {
        type: Boolean,
        attribute: 'line-numbers'
      },
      _styles: {
        type: String
      }
    };
  }

  constructor() {
    super();
    this.language = 'xml';
    this.theme = 'default';
    this.lineNumbers = false;
  }

  connectedCallback() {
    super.connectedCallback();
    const theme = this.getAttribute('theme');

    if (theme === null) {
      this.setAttribute('theme', 'default');
    }
  }

  firstUpdated() {
    super.firstUpdated();

    if (!this.code) {
      const template = this.querySelector('template');

      if (template) {
        this.code = Prism.plugins.NormalizeWhitespace.normalize(template.innerHTML);
      } else {
        this.code = Prism.plugins.NormalizeWhitespace.normalize(this.textContent);
      }
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);

    switch (name) {
      case 'theme':
        PbCodeHighlight.loadTheme(newValue).then(styles => {
          this._styles = styles;
        });
        break;
    }
  }

  updated(changedProperties) {
    super.updated(changedProperties);

    if (changedProperties.has('code')) {
      this.highlight();
    }
  }

  highlight() {
    Prism.highlightAllUnder(this.shadowRoot);
  }

  render() {
    if (this.code) {
      return html$1`
                ${this._styles}
                <pre class="${this.lineNumbers ? 'line-numbers' : ''} language-${this.language}"><code>${this.code}</code></pre>
            `;
    }

    return html$1`<pre class="line-numbers"><code><code></pre>`;
  }

  static async loadTheme(theme) {
    const themeName = theme === 'default' ? 'prism.css' : `prism-${theme}.css`;
    const resource = resolveURL('../css/prismjs/') + themeName;
    console.log('<pb-code-highlight> loading theme %s from %s', theme, resource);
    const fetchedStyles = await fetch(resource).then(async response => response.text()).catch(e => '');
    return html$1`<style>${fetchedStyles}</style>`;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
            pre[class*='language-'] {
                margin: 0;
            }
            code[class*='language-'] {
                white-space: var(--pb-code-highlight-white-space, pre);
            }
            pre.line-numbers {
                position: relative;
                padding-left: 3.8em;
                counter-reset: linenumber;
            }

            pre.line-numbers > code {
                position: relative;
                white-space: inherit;
            }

            .line-numbers .line-numbers-rows {
                position: absolute;
                pointer-events: none;
                top: 0;
                font-size: 100%;
                left: -3.8em;
                width: 3em; /* works for line-numbers below 1000 lines */
                letter-spacing: -1px;
                border-right: 1px solid #999;

                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;

            }

            .line-numbers-rows > span {
                pointer-events: none;
                display: block;
                counter-increment: linenumber;
                height: auto !important;
            }

            .line-numbers-rows > span:before {
                content: counter(linenumber);
                color: #999;
                display: block;
                padding-right: 0.8em;
                text-align: right;
            }
        `;
  }

}
customElements.define('pb-code-highlight', PbCodeHighlight);

const codePenEndpoint = "https://teipublisher.com/exist/apps/tei-publisher";
/**
 * Viewer for demo code.
 * 
 * @customElement  pb-demo-snippet
 * @polymer
 * @appliesMixin pbMixin
 */

class PbDemoSnippet extends LitElement {
  static get properties() {
    return {
      title: {
        type: String
      },
      code: {
        type: String
      },
      _editorLoaded: {
        type: Boolean
      },
      _showCodeLabel: {
        type: String
      },
      _editCodeLabel: {
        type: String
      }
    };
  }

  constructor() {
    super();
    this.title = 'TEI Publisher Webcomponents Example';
    this.code = 'Loading ...';
    this._showCodeLabel = 'demo.showCode.show';
  }

  connectedCallback() {
    super.connectedCallback();
    const template = this.querySelector('template');
    this.code = PbDemoSnippet.removeIndent(template.innerHTML);
    this.code = this.code.replace(/\s*<style[\s\S]*>[\s\S]*?<\/style>\s*/g, '');
    const clone = document.importNode(template.content, true);
    this.appendChild(clone);
  }

  render() {
    let cpCode = this.code.replace(/(endpoint="[^"]+")/, `endpoint="${codePenEndpoint}"`);
    cpCode = PbDemoSnippet.indent(cpCode, 2);
    const style = this.querySelector('style');
    let css = '';

    if (style) {
      css = style.innerText;
    }

    const cpCss = `
@import url('https://fonts.googleapis.com/css?family=Oswald|Roboto&display=swap');

body {
    margin: 10px 20px;
    font-size: 16px;
    font-family: 'Roboto', 'Noto', sans - serif;
    line-height: 1.42857;
    font-weight: 300;
    color: #333333;

    --paper-tooltip-delay-in: 200;
}

${PbDemoSnippet.removeIndent(css)}`;
    const cpHtml = `
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <title>${this.title}</title>
        <script src="https://unpkg.com/@webcomponents/webcomponentsjs@2.4.3/webcomponents-loader.js"></script>
        <script type="module" src="https://unpkg.com/@teipublisher/pb-components@latest/dist/pb-components-bundle.js"></script>
        <script type="module" src="https://unpkg.com/@teipublisher/pb-components@latest/dist/pb-leaflet-map.js"></script>
    </head>

    <body>
    ${cpCode}
    </body>
</html>`;
    const cpOptions = {
      title: this.title,
      html: cpHtml,
      html_pre_processor: "none",
      css: cpCss,
      css_starter: "normalize",
      template: false,
      editors: 110
    };
    return html$1`
            <div class="snippet"><slot></slot></div>
            <pb-code-highlight id="source" theme="coy" language="html" line-numbers .code="${this.code}"></pb-code-highlight>
            <div id="container"></div>
            <div class="buttons">
                <button class="pretty-button" @click="${this._showCode}">${translate(this._showCodeLabel)}</button>
                <form action="https://codepen.io/pen/define" method="POST" target="_blank">
                    <input type="hidden" name="data" .value="${JSON.stringify(cpOptions)}">
                    <button class="pretty-button" type="submit">${translate('demo.editCode.show')}</button>
                </form>
            </div>
        `;
  }

  _showCode() {
    const source = this.shadowRoot.getElementById('source');

    if (source.classList.contains('open')) {
      source.classList.remove('open');
      this._showCodeLabel = 'demo.showCode.show';
    } else {
      source.classList.add('open');
      this._showCodeLabel = 'demo.showCode.hide';
    }
  }

  static removeIndent(input) {
    const indents = input.match(/^[^\S]*(?=\S)/gm);
    if (!indents || !indents[0].length) return input;
    indents.sort((a, b) => a.length - b.length);
    if (!indents[0].length) return input;
    return input.replace(RegExp('^' + indents[0], 'gm'), '');
  }

  static indent(input, tabs) {
    return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join('\t') + '$&');
  }

  static get styles() {
    return css`
            :host {
                display: block;
                box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
                padding: 20px;
            }
            pb-code-highlight {
                display: none;
                margin-top: 30px;
            }
            pb-code-highlight.open {
                display: block;
            }
            #container {
                margin-top: 20px;
            }
            .buttons {
                display: flex;
                justify-content: space-between;
                margin-top: 20px;
                padding-top: 10px;
                border-top: 1px solid var(--google-grey-400, #999);
            }
            .pretty-button {
                cursor: pointer;
                display: inline-block;
                box-sizing: border-box;
                margin: 12px 0;
                padding: 13px 44px;
                border: 2px solid #2196F3;
                background-color: transparent;
                font-size: 14px;
                font-weight: 500;
                color: #2196F3;
                text-align: center;
                text-decoration: none;
                text-transform: uppercase;
                border-radius: 0;
                -webkit-appearance: none;
                appearance: none;
            }
            .pretty-button:hover,
            .pretty-button:active {
                background-color: #2196F3;
                color: #FFF;
            }
            .pretty-button:disabled {
                background-color: transparent;
                border-color: #999;
                color: #999;
            }
        `;
  }

}
customElements.define('pb-demo-snippet', PbDemoSnippet);

/**
 * Utility class to plug into TEI Publisher's event system from custom javascript.
 */
class PbEvents {
  /**
   * Subscribe to an event received on particular channels.
   * 
   * @param {string} name the name of the event to listen for
   * @param {string|string[]|null} channels name of a channel, array of channel names or null to target the default channel
   * @param {Function|undefined} callback function called when event is triggered. 
   * Receives the event as first and the event handler as second parameter.
   */
  static subscribe(name, channels, callback, once = false) {
    if (channels && !Array.isArray(channels)) {
      // eslint-disable-next-line no-param-reassign
      channels = [channels];
    }

    const handler = document.addEventListener(name, (
    /** @type {CustomEvent} */
    ev) => {
      if (!channels && !(ev.detail && ev.detail.key) || channels && ev.detail && ev.detail.key && channels.indexOf(ev.detail.key) > -1) {
        if (callback) {
          callback(ev, handler);
        }
      }
    }, {
      once
    });
  }
  /**
   * Subscribe to an event received on a particular channel once. Returns a promise
   * which resolves when the event is caught.
   * 
   * @param {string} name the name of the event to listen for
   * @param {string|string[]|null} channels name of a channel, array of channel names or null to target the default channel
   * @returns {Promise} resolves if event is caught, providing the event as parameter
   */


  static subscribeOnce(name, channels = null) {
    if (channels && !Array.isArray(channels)) {
      // eslint-disable-next-line no-param-reassign
      channels = [channels];
    }

    return new Promise(resolve => {
      document.addEventListener(name, (
      /** @type {CustomEvent} */
      ev) => {
        if (!channels && !(ev.detail && ev.detail.key) || channels && ev.detail && ev.detail.key && channels.indexOf(ev.detail.key) > -1) {
          resolve(ev);
        }
      }, {
        once: true
      });
    });
  }
  /**
   * Emit an event to a particular channel
   * 
   * @param {string} type the name of the event to emit
   * @param {string|null} channel name of the channel or null to target the default channel
   * @param {any|null} detail value to pass in the event details
   */


  static emit(type, channel = null, detail = null) {
    const options = detail || {};

    if (channel) {
      options.key = channel;
    }

    const ev = new CustomEvent(type, {
      detail: options
    });
    document.dispatchEvent(ev);
  }

}

if (!window.pbEvents) {
  window.pbEvents = PbEvents;
}

const PB_COMPONENTS_VERSION = '1.36.3';
/**
 * Outputs the version of pb-components being used. This is injected
 * from `package.json` at build time.
 */

class PbVersion extends LitElement {
  static get properties() {
    return Object.assign({
      version: {
        type: String,
        reflect: true
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.version = PB_COMPONENTS_VERSION;
  }

  connectedCallback() {
    super.connectedCallback();

    if (!this.version) {
      const pkg = resolveURL('../package.json');
      fetch(pkg).then(response => response.json()).then(data => {
        this.version = data.version;
      });
    }
  }

  render() {
    return html$1`<span>${this.version ? this.version : 'unknown'}</span>`;
  }

  createRenderRoot() {
    return this;
  }

}
customElements.define('pb-version', PbVersion);

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;

    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false


  return false;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle$1(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets;

  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle$1(offsetParent).position !== 'static') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top) {
      sideY = bottom; // $FlowFixMe[prop-missing]

      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right; // $FlowFixMe[prop-missing]

      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref4) {
  var state = _ref4.state,
      options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect$2(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};

var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

var hash$1 = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name; // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step

  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

    if (checkMainAxis) {
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

/**!
* tippy.js v6.3.1
* (c) 2017-2021 atomiks
* MIT License
*/
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};

function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}

function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}

function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}

function debounce$1(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}

function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}

function normalizeToArray(value) {
  return [].concat(value);
}

function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}

function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}

function getBasePlacement$1(placement) {
  return placement.split('-')[0];
}

function arrayFrom(value) {
  return [].slice.call(value);
}

function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (obj[key] !== undefined) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function div() {
  return document.createElement('div');
}

function isElement$1(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}

function isNodeList(value) {
  return isType(value, 'NodeList');
}

function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}

function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}

function getArrayOfElements(value) {
  if (isElement$1(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}

function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}

function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}

function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;

  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


  return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
}

function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement$1(popperState.placement);
    var offsetData = popperState.modifiersData.offset;

    if (!offsetData) {
      return true;
    }

    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}

function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */


function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */


function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}

function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: function appendTo() {
    return document.body;
  },
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, {}, renderProps);
var defaultKeys = Object.keys(defaultProps);

var setDefaultProps = function setDefaultProps(partialProps) {

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};

function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return Object.assign({}, passedProps, {}, pluginProps);
}

function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}

function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}

var innerHTML = function innerHTML() {
  return 'innerHTML';
};

function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}

function createArrowElement(value) {
  var arrow = div();

  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;

    if (isElement$1(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }

  return arrow;
}

function setContent(content, props) {
  if (isElement$1(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}

function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}

function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);

  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;

    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }

    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }

    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }

    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }

    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }

    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }

  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away


render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];

function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
  //  Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
  var currentTarget; // ===========================================================================
  //  Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests 
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {

    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================


  var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;

  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function (event) {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
  });
  return instance; // ===========================================================================
  //  Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getIsDefaultRenderFn() {
    var _instance$props$rende; // @ts-ignore


    return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }

  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function handleStyles() {
    popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(void 0, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaContentAttribute() {
    var aria = instance.props.aria;

    if (!aria.content) {
      return;
    }

    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    } // Clicked on interactive popper


    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }

    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }

  function onTouchMove() {
    didTouchMove = true;
  }

  function onTouchStart() {
    didTouchMove = false;
  }

  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;

    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var _lastTriggerEvent;

    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;

      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }

      return null;
    }).filter(Boolean);

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

    if (shouldBail) {
      return;
    }

    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }

  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;

          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];

    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }

    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }

  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }

  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    createPopperInstance();
  }

  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentPress();
    var delay = getDelay(true);

    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];

    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  //  Public methods
  // ===========================================================================


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {

    if (instance.state.isDestroyed) {
      return;
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed


    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();
    handleStyles();

    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }

    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show() {


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.state.isVisible = true;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }

    handleStyles();
    addDocumentPress();

    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration


    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;

      setTransitionDuration([box, content], 0);
    }

    onFirstUpdate = function onFirstUpdate() {
      var _instance$popperInsta2;

      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }

      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;

      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;

        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
      // popper has been positioned for the first time

      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);

      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };

    mount();
  }

  function hide() {


    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }

    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles();

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;

      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }

    handleAriaContentAttribute();
    handleAriaExpandedAttribute();

    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }

  function hideWithInteractivity(event) {

    getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }

  function unmount() {

    if (instance.state.isVisible) {
      instance.hide();
    }

    if (!instance.state.isMounted) {
      return;
    }

    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });

    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }

    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }

  function destroy() {

    if (instance.state.isDestroyed) {
      return;
    }

    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement$1(targets) ? instances[0] : instances;
}

tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
// and causing transitions to break for singletons when the console is open, but
// most notably for non-transform styles being used, `gpuAcceleration: false`.


var applyStylesModifier = Object.assign({}, applyStyles$1, {
  effect: function effect(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    } // intentionally return no cleanup function
    // return () => { ... }

  }
});

tippy.setDefaultProps({
  render: render
});

function camelize(str) {
  return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (match, index) => {
    if (+match === 0) return "";
    return index === 0 ? match.toLowerCase() : match.toUpperCase();
  }).replace('-', '');
}
const base = `
    .tippy-box[data-animation=fade][data-state=hidden] {
        opacity: 0
    }

    .tippy-iOS {
        cursor: pointer!important;
        -webkit-tap-highlight-color: transparent
    }

    [data-tippy-root] {
        max-width: calc(100vw - 10px)
    }

    .tippy-box {
        position: relative;
        background-color: #333;
        color: #fff;
        border-radius: 4px;
        font-size: var(--pb-popover-font-size, var(--pb-base-font-size, 14px));
        line-height: var(--pb-popover-line-height, var(--pb-base-line-height, 1.4));
        text-align: left;
        font-style: normal;
        font-weight: normal;
        outline: 0;
        transition-property: transform, visibility, opacity
    }

    .tippy-box[data-placement^=top]>.tippy-arrow {
        bottom: 0
    }

    .tippy-box[data-placement^=top]>.tippy-arrow:before {
        bottom: -7px;
        left: 0;
        border-width: 8px 8px 0;
        border-top-color: initial;
        transform-origin: center top
    }

    .tippy-box[data-placement^=bottom]>.tippy-arrow {
        top: 0
    }

    .tippy-box[data-placement^=bottom]>.tippy-arrow:before {
        top: -7px;
        left: 0;
        border-width: 0 8px 8px;
        border-bottom-color: initial;
        transform-origin: center bottom
    }

    .tippy-box[data-placement^=left]>.tippy-arrow {
        right: 0
    }

    .tippy-box[data-placement^=left]>.tippy-arrow:before {
        border-width: 8px 0 8px 8px;
        border-left-color: initial;
        right: -7px;
        transform-origin: center left
    }

    .tippy-box[data-placement^=right]>.tippy-arrow {
        left: 0
    }

    .tippy-box[data-placement^=right]>.tippy-arrow:before {
        left: -7px;
        border-width: 8px 8px 8px 0;
        border-right-color: initial;
        transform-origin: center right
    }

    .tippy-box[data-inertia][data-state=visible] {
        transition-timing-function: cubic-bezier(.54, 1.5, .38, 1.11)
    }

    .tippy-arrow {
        width: 16px;
        height: 16px;
        color: #333
    }

    .tippy-arrow:before {
        content: "";
        position: absolute;
        border-color: transparent;
        border-style: solid
    }

    .tippy-content {
        position: relative;
        padding: 5px 9px;
        z-index: 1;
        overflow: auto;
        max-height: var(--pb-popover-max-height, calc(100vh - 60px));
        min-height: var(--pb-popover-min-height, auto);
        max-width: var(--pb-popover-max-width, auto);
        min-width: var(--pb-popover-min-width, auto);
        color: var(--pb-popover-color);
    }
`;
const lightBorder = `
    .tippy-box[data-theme~=light-border] {
        background-color: #fff;
        background-clip: padding-box;
        border: 1px solid rgba(0, 8, 16, .15);
        color: #333;
        box-shadow: 0 4px 14px -2px rgba(0, 8, 16, .08)
    }

    .tippy-box[data-theme~=light-border]>.tippy-backdrop {
        background-color: #fff
    }

    .tippy-box[data-theme~=light-border]>.tippy-arrow:after, .tippy-box[data-theme~=light-border]>.tippy-svg-arrow:after {
        content: "";
        position: absolute;
        z-index: -1
    }

    .tippy-box[data-theme~=light-border]>.tippy-arrow:after {
        border-color: transparent;
        border-style: solid
    }

    .tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-arrow:before {
        border-top-color: #fff
    }

    .tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-arrow:after {
        border-top-color: rgba(0, 8, 16, .2);
        border-width: 7px 7px 0;
        top: 17px;
        left: 1px
    }

    .tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-svg-arrow>svg {
        top: 16px
    }

    .tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-svg-arrow:after {
        top: 17px
    }

    .tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-arrow:before {
        border-bottom-color: #fff;
        bottom: 16px
    }

    .tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-arrow:after {
        border-bottom-color: rgba(0, 8, 16, .2);
        border-width: 0 7px 7px;
        bottom: 17px;
        left: 1px
    }

    .tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-svg-arrow>svg {
        bottom: 16px
    }

    .tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-svg-arrow:after {
        bottom: 17px
    }

    .tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-arrow:before {
        border-left-color: #fff
    }

    .tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-arrow:after {
        border-left-color: rgba(0, 8, 16, .2);
        border-width: 7px 0 7px 7px;
        left: 17px;
        top: 1px
    }

    .tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-svg-arrow>svg {
        left: 11px
    }

    .tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-svg-arrow:after {
        left: 12px
    }

    .tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-arrow:before {
        border-right-color: #fff;
        right: 16px
    }

    .tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-arrow:after {
        border-width: 7px 7px 7px 0;
        right: 17px;
        top: 1px;
        border-right-color: rgba(0, 8, 16, .2)
    }

    .tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-svg-arrow>svg {
        right: 11px
    }

    .tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-svg-arrow:after {
        right: 12px
    }

    .tippy-box[data-theme~=light-border]>.tippy-svg-arrow {
        fill: #fff
    }

    .tippy-box[data-theme~=light-border]>.tippy-svg-arrow:after {
        background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHoiIGZpbGw9InJnYmEoMCwgOCwgMTYsIDAuMikiLz48L3N2Zz4=);
        background-size: 16px 6px;
        width: 16px;
        height: 6px
    }
`;
const light = `
    .tippy-box[data-theme~=light] {
        color: #26323d;
        box-shadow: 0 0 20px 4px rgba(154, 161, 177, .15), 0 4px 80px -8px rgba(36, 40, 47, .25), 0 4px 4px -2px rgba(91, 94, 105, .15);
        background-color: #fff
    }

    .tippy-box[data-theme~=light][data-placement^=top]>.tippy-arrow:before {
        border-top-color: #fff
    }

    .tippy-box[data-theme~=light][data-placement^=bottom]>.tippy-arrow:before {
        border-bottom-color: #fff
    }

    .tippy-box[data-theme~=light][data-placement^=left]>.tippy-arrow:before {
        border-left-color: #fff
    }

    .tippy-box[data-theme~=light][data-placement^=right]>.tippy-arrow:before {
        border-right-color: #fff
    }

    .tippy-box[data-theme~=light]>.tippy-backdrop {
        background-color: #fff
    }

    .tippy-box[data-theme~=light]>.tippy-svg-arrow {
        fill: #fff
    }`;
const material = `
    .tippy-box[data-theme~=material] {
        background-color: #505355;
        font-weight: 600
    }

    .tippy-box[data-theme~=material][data-placement^=top]>.tippy-arrow:before {
        border-top-color: #505355
    }

    .tippy-box[data-theme~=material][data-placement^=bottom]>.tippy-arrow:before {
        border-bottom-color: #505355
    }

    .tippy-box[data-theme~=material][data-placement^=left]>.tippy-arrow:before {
        border-left-color: #505355
    }

    .tippy-box[data-theme~=material][data-placement^=right]>.tippy-arrow:before {
        border-right-color: #505355
    }

    .tippy-box[data-theme~=material]>.tippy-backdrop {
        background-color: #505355
    }

    .tippy-box[data-theme~=material]>.tippy-svg-arrow {
        fill: #505355
    }
`;
const translucent = `
    .tippy-box[data-theme~=translucent] {
        background-color: rgba(0, 0, 0, .7)
    }

    .tippy-box[data-theme~=translucent]>.tippy-arrow {
        width: 14px;
        height: 14px
    }

    .tippy-box[data-theme~=translucent][data-placement^=top]>.tippy-arrow:before {
        border-width: 7px 7px 0;
        border-top-color: rgba(0, 0, 0, .7)
    }

    .tippy-box[data-theme~=translucent][data-placement^=bottom]>.tippy-arrow:before {
        border-width: 0 7px 7px;
        border-bottom-color: rgba(0, 0, 0, .7)
    }

    .tippy-box[data-theme~=translucent][data-placement^=left]>.tippy-arrow:before {
        border-width: 7px 0 7px 7px;
        border-left-color: rgba(0, 0, 0, .7)
    }

    .tippy-box[data-theme~=translucent][data-placement^=right]>.tippy-arrow:before {
        border-width: 7px 7px 7px 0;
        border-right-color: rgba(0, 0, 0, .7)
    }

    .tippy-box[data-theme~=translucent]>.tippy-backdrop {
        background-color: rgba(0, 0, 0, .7)
    }

    .tippy-box[data-theme~=translucent]>.tippy-svg-arrow {
        fill: rgba(0, 0, 0, .7)
    }
`;

var themes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  camelize: camelize,
  base: base,
  lightBorder: lightBorder,
  light: light,
  material: material,
  translucent: translucent
});

function _injectStylesheet(root, name, cssCode) {
  const style = root.querySelector(`#pb-popover-${name}`);

  if (!style) {
    const container = root.nodeType === Node.DOCUMENT_NODE ? document.head : root;
    console.log('Loading tippy styles for theme %s into %o', name, container);
    const elem = document.createElement('style');
    elem.type = 'text/css';
    elem.id = `pb-popover-${name}`;
    elem.innerHTML = cssCode;
    container.appendChild(elem);
  }
}

function loadTippyStyles(root, theme) {
  _injectStylesheet(root, 'base', base);

  if (theme && theme !== 'none') {
    const name = camelize(theme);
    const themeCSS = themes[name];

    if (themeCSS) {
      _injectStylesheet(root, name, themeCSS);
    }
  }
}
/**
 * Show a popover. It may either 
 * 
 * 1. be attached to another element on the page which serves as a trigger. For this the
 * `for` property must be specified and should contain the ID of the trigger element. 
 * The whole content of the `pb-popover` element will be shown in the popup.
 * 
 * 2. if no `for` property is specified, the `pb-popover` acts itself as the trigger. The trigger
 * text is either taken from a slot named `default` - or the default slot (i.e. the content of the element).
 * The content to show in the popup should be supplied in a slot named `alternate`. It is recommended to use an
 * HTML `template` to specify the alternate, so it is ignored by the browser:
 * 
 * ```html
 * <pb-popover theme="material">
 *      <span slot="default">ipsum dolor sit amet</span>
 *      <template slot="alternate">
 *          <p>At vero eos et <strong>accusam</strong> et justo duo dolores<br>
 *          et ea rebum.</p>
 *      </template>
 * </pb-popover>
 * ```
 * 
 * If you would like popovers to contain nested popovers, choose approach 1 above and use `for`.
 * 
 * If property `persistent` is true, the popover will be shown
 * on click. Otherwise display a tooltip on mouseover.
 * 
 * `pb-popover` uses the tippy.js library for the popup.
 * 
 * ## Styling
 * 
 * When showing the popup, the popup content will either be added to the parent shadow DOM - if the `pb-popover`
 * is located inside the shadow DOM of another element like `pb-view`; or the document body. This has an
 * effect on where CSS styles can be defined: within a `pb-view`, only the styles specified inside the
 * CSS attached to the ODD are applied.
 * 
 * @prop {String} for - The id of a trigger element (e.g. a link) to which the popover will
 * be attached. If not set, the trigger is the pb-popover itself.
 * @prop {"material" | "light" | "translucent" | "light-border"} theme - The tippy theme to use.
 * @prop {"auto" | "top" | "bottom" | "left" | "right"} placement - Preferred placement of the popup.
 * Default is 'auto'.
 * @prop {String} fallbackPlacement - Fallback placement if there is more space on another side.
 * Accepts same values as `placement`. Separate by space if more than one.
 * @prop {Boolean} persistent - If true, show the 'hand' cursor when hovering over the link; `trigger` will be set to 'click'
 * unless defined otherwise; clicking anywhere on the page will close the popup.
 * @prop {"click" | "mouseenter" | "focus" | "focusin"} trigger - Defines one or more actions (space separated) which should cause
 * the popover to show. If property `persistent` is set, `trigger` will by default be set to `click`.
 * @prop {String} poupClass - Additional class names which will be added to the popup element.
 * Use this to apply a specific style to certain popovers, but not others.
 * @prop {String} remote - An optional URL to asynchronously load the popover's content from. Content will
 * be loaded after the popover is displayed. The downloaded HTML content will replace the text set via the alternate slot.
 * 
 * @slot default - the content to show for the trigger. If not specified, this will fall back to the unnamed slot.
 * @slot alternate - the content to show in the popup
 * 
 * @csspart trigger - the inline element used as trigger
 * 
 * @cssprop [--pb-popover-theme=none] - popup theme to use. One of 'material', 'light', 'translucent' or 'light-border'
 * @cssprop [--pb-popover-link-decoration=inherit] - text decoration for the trigger
 * @cssprop [--pb-popover-max-height=calc(100vh - 60px)] - limit the maximum height of the popup
 * @cssprop --pb-popover-min-height - set the minimum height of the popup
 * @cssprop --pb-popover-max-width - limit the max width of the popup
 * @cssprop --pb-popover-min-width - set the minimum width of the popup
 * @cssprop --pb-popover-color - Color of the popup text
 * @cssprop [--pb-popover-placement=auto] - Preferred popup placement, see property `placement`
 * @cssprop --pb-popover-fallback-placement - Fallback placements separated by space
 * @cssprop --pb-popover-trigger - define the trigger action, same as property `trigger`
 * @cssprop --pb-popover-persistent - switch to persistent behaviour, see property `persistent`
 */

class PbPopover extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      for: {
        type: String
      },
      theme: {
        type: String
      },
      placement: {
        type: String
      },
      fallbackPlacement: {
        type: String,
        attribute: 'fallback-placement'
      },
      persistent: {
        type: Boolean
      },
      trigger: {
        type: String
      },
      popupClass: {
        type: String,
        attribute: 'popup-class'
      },
      remote: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.persistent = false;
    this.trigger = null;
    this.for = null;
    this.theme = null;
    this.placement = null;
    this.fallbackPlacement = null;
    this.popupClass = null;
    this._tippy = null;
    this._content = null;
  }

  render() {
    if (this.for) {
      return html$1`<div class="hidden"><slot></slot></div>`;
    }

    return html$1`<span id="link" part="trigger" class="${this.persistent ? 'persistent' : ''}"><slot name="default"><slot></slot></slot></span><span class="hidden"><slot name="alternate"></slot></span>`;
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    if (this._tippy) {
      this._tippy.destroy();
    }

    if (this._observer) {
      this._observer.disconnect();
    }
  }

  _checkCSSProperties() {
    if (!this.theme && this.theme !== 'none') {
      this.theme = this._getCSSProperty('--pb-popover-theme', 'none');
    }

    if (!this.placement) {
      this.placement = this._getCSSProperty('--pb-popover-placement', 'auto');
    }

    if (!this.fallbackPlacement) {
      this.fallbackPlacement = this._getCSSProperty('--pb-popover-fallback-placement', null);
    }

    if (!this.persistent) {
      this.persistent = this._getCSSProperty('--pb-popover-persistent', false);
    }

    if (!this.trigger) {
      this.trigger = this._getCSSProperty('--pb-popover-trigger', null);
    }
  }

  _getCSSProperty(name, defaultValue) {
    const property = getComputedStyle(this).getPropertyValue(name);

    if (property) {
      try {
        return JSON.parse(property);
      } catch (e) {
        return defaultValue;
      }
    }

    return defaultValue;
  }

  _injectStyles() {
    this._checkCSSProperties();

    loadTippyStyles(this.getRootNode(), this.theme);
  }

  _getContent() {
    if (this._content) {
      return this._content;
    }

    const slot = this._getSlot();

    if (slot) {
      const content = document.createElement('div');
      slot.assignedNodes().forEach(node => {
        content.appendChild(node.content ? node.content.cloneNode(true) : node.cloneNode(true));
      });
      this._content = content;
      return content;
    }

    return null;
  }

  _getSlot() {
    if (this.for) {
      return this.shadowRoot.querySelector('slot');
    }

    return this.shadowRoot.querySelector('[name=alternate]');
  }
  /**
   * Listen for changes of the current element or its alternate slot
   * and update popover content accordingly.
   */


  _registerMutationObserver() {
    const slot = this._getSlot();

    this._observer = new MutationObserver(() => {
      this.alternate = this._getContent();
      console.log('alternate changed');
      this.emitTo('pb-popover-changed', this.alternate);
    });

    this._observer.observe(this, {
      subtree: true,
      childList: true,
      characterData: true
    });

    if (slot) {
      slot.assignedNodes().forEach(node => {
        this._observer.observe(node.content ? node.content : node, {
          subtree: true,
          childList: true,
          characterData: true
        });
      });
    }
  }
  /**
   * Returns the root element of the alternate content currently shown in the popover.
   * This will be initialized from either the default slot or the slot with name 'alternate' (if present).
   * The returned element is always a `div` and can be modified.
   */


  get alternate() {
    return this._getContent();
  }
  /**
   * Set the element to be shown in the popover. Use this to set popover
   * content dynamically. Alternatively you can also modify the DOM of the slots
   * directly and the changes should be picked up by the component.
   */


  set alternate(content) {
    this._content = content;

    if (this._tippy) {
      this._tippy.setContent(this._content);
    }
  }
  /**
   * Overwrite to enable/disable tippy instance
   */


  command(command, state) {
    if (command === 'disable') {
      this.disabled = state;

      if (this._tippy) {
        if (state) {
          this._tippy.disable();
        } else {
          this._tippy.enable();
        }
      }
    }
  }

  firstUpdated() {
    super.firstUpdated();

    this._injectStyles();

    this._registerMutationObserver();

    if (!this.trigger) {
      this.trigger = this.persistent ? 'click' : 'mouseenter';
    }

    const root = this.getRootNode();
    let target;

    if (this.for) {
      target = root.getElementById(this.for);

      if (!target) {
        console.error('<pb-popover> target element %s not found', this.for);
      }
    } else {
      target = this.shadowRoot.getElementById('link');
    }

    if (target) {
      const options = {
        allowHTML: true,
        appendTo: root.nodeType === Node.DOCUMENT_NODE ? document.body : root,
        placement: this.placement,
        interactive: true,
        ignoreAttributes: true,
        boundary: 'viewport',
        maxWidth: 'none',
        touch: 'hold',
        hideOnClick: false,
        trigger: this.trigger
      };

      if (this.persistent) {
        options.onClickOutside = (instance, ev) => {
          instance.hideWithInteractivity(ev);
        };
      }

      if (this.theme && this.theme !== 'none') {
        options.theme = this.theme;
      }

      if (this.fallbackPlacement) {
        const placements = this.fallbackPlacement.split(' ');
        options.popperOptions = {
          modifiers: [{
            name: 'flip',
            options: {
              fallbackPlacements: placements
            }
          }]
        };
      }

      if (this.popupClass) {
        options.onCreate = instance => {
          instance.popper.classList.add(this.popupClass);
        };
      }

      options.onShow = instance => {
        if (this.remote) {
          this._loadRemoteContent();
        } else {
          instance.setContent(this._getContent());
        }

        this.emitTo('pb-popover-show', {
          source: this
        });
      };

      this._tippy = tippy(target, options);
    }
  }

  _loadRemoteContent() {
    const url = this.toAbsoluteURL(this.remote);
    fetch(url, {
      method: 'GET',
      mode: 'cors',
      credentials: 'same-origin'
    }).then(response => response.text()).then(data => {
      this.alternate = data;
    }).catch(error => {
      console.error('<pb-popover> Error retrieving remote content: %o', error);
    });
  }

  static get styles() {
    return [css`
                :host {
                    display: inline;
                }
                .hidden {
                    display: none;
                }
                div {
                    float: left;
                }
                #link {
                    display: inline;
                    color: inherit;
                    text-decoration: var(--pb-popover-link-decoration, var(--pb-link-text-decoration, inherit));
                }
                #link.persistent {
                    cursor: pointer;
                }
            `];
  }

}
customElements.define('pb-popover', PbPopover);

/**
 * Link elements to each other: if the user moves the mouse over one element,
 * the others are highlighted by changing their background color. Which elements
 * are linked is determined by the `key` property: elements with the same key
 * are linked. If the user moves the mouse over an element, the key is sent with
 * a `pb-highlight` event. Other elements with the same key react to this event.
 *
 * `pb-highlight` should be output for relevant elements via ODD processing model.
 *
 * 
 *
 * @slot - default unnamed slot for highlight content
 * @fires pb-highlight-off - Fires removal of all highlights that might have existed before
 * @fires pb-highlight-on - Fires highlight event with a key passed to which other pb-highlight elements with the same key will react
 * @fires pb-highlight-off - When received, triggers removal of a highlight that might have been on for this element before
 * @fires pb-highlight-on - When received, switches the highlight on if the same key was received as the current element has
 * @cssprop --pb-highlight-color - Background color to highlight an element
*/

class PbHighlight extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The key to which this element is connected.
       */
      key: {
        type: String
      },

      /**
       * If set to > 0, specifies a duration (in ms) after which
       * the highlighting will be removed again
       */
      duration: {
        type: Number
      },

      /**
       * Scroll this element into view when it receives a highlight event
       */
      scroll: {
        type: Boolean
      },
      highlightSelf: {
        type: Boolean,
        attribute: 'highlight-self'
      },
      _className: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.key = null;
    this.duration = 0;
    this.scroll = false;
    this.highlightSelf = false;
    this._className = 'highlight-off';
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-highlight-on', this._highlightOn.bind(this));
    this.subscribeTo('pb-highlight-off', this._highlightOff.bind(this));
  }

  command(command, state) {
    super.command(command, state);

    if (this.disabled) {
      this._className = 'highlight-off';
    }
  }

  _mouseOver() {
    this.emitTo('pb-highlight-off', {
      source: this
    });

    if (this.highlightSelf) {
      this._highlightOn({
        detail: {
          id: this.key
        }
      });
    }

    this.emitTo('pb-highlight-on', {
      id: this.key,
      source: this,
      scroll: this.scroll
    });
  }

  render() {
    if (this.disabled) {
      return html$1`<slot></slot>`;
    }

    return html$1`<span id="content" class="${this._className}" @mouseover="${this._mouseOver}"><slot></slot></span>`;
  }

  static get styles() {
    return css`
            :host {
                display: inline;
            }

            @keyframes keyFrameBackgroundColorIn {
                0% {
                    background-color: inherit;
                }
                100% {
                    background-color: var(--pb-highlight-color, #F9E976);
                }
            }

            #content {
                display: inline;
            }

            .highlight-on {
                background-color: var(--pb-highlight-color, #F9E976);
                animation-name: keyFrameBackgroundColorIn;
                animation-duration: 500ms;
                animation-iteration-count: 1;
                animation-timing-function: ease-in;

            }

            .highlight-off {
                background-color: inherit;
            }
        `;
  }

  _highlightOn(ev) {
    if (ev.detail.source != this && ev.detail.id === this.key) {
      this._className = 'highlight-on';

      if (ev.detail.scroll) {
        this.scrollIntoView({
          behaviour: 'smooth'
        });
      }

      if (this.duration > 0) {
        setTimeout(function () {
          this._className = 'highlight-off';
        }.bind(this), this.duration);
      }
    }
  }

  _highlightOff(ev) {
    if (ev.detail.source != this) {
      this._className = 'highlight-off';
    }
  }
  /**
   * Fired if mouse pointer enters the element
   *
   * @event pb-highlight-on
   * @param {String} id key
   * @param {Object} source this element
   * @param {scroll} should target scroll to highlighted position
   */

  /**
   * Fired if mouse pointer leaves the element
   *
   * @event pb-highlight-off
   * @param {Object} source this element
   */


}
customElements.define('pb-highlight', PbHighlight);

/**
 * Create an internal link: clicking it will cause connected views to
 * update and load the corresponding document fragment defined by the
 * properties.
 *
 * @fires pb-refresh - Fires when user clicks the link
 */

class PbLink extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** Browse to an xml:id within the document */
      xmlId: {
        type: String,
        attribute: 'xml-id'
      },

      /** Browse to an eXist-internal node id, e.g. 3.5.6.1 */
      nodeId: {
        type: String,
        attribute: 'node-id',
        reflect: true
      },
      hash: {
        type: String,
        reflect: true
      },

      /** Browse to a different document */
      path: {
        type: String
      },

      /** Switch the ODD to use for display */
      odd: {
        type: String
      },

      /**
       * Modify browser history: if set, clicking this
       * element will generate a new history entry in the browser's history.
       * Only use this on one element on the page.
       */
      history: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.history = true;
  }

  connectedCallback() {
    super.connectedCallback();
    this._id = this.nodeId;
    this.subscribeTo('pb-visible', ev => {
      if (this.nodeId) {
        const [root, nodeId] = ev.detail.data.split(/\s*,\s*/);

        if (this.nodeId === root && (!this.hash || this.hash === nodeId)) {
          this.classList.add('active');
          this.scrollIntoView({
            block: 'nearest'
          });
          this.dispatchEvent(new CustomEvent('pb-collapse-open', {
            composed: true,
            bubbles: true
          }));
        } else {
          this.classList.remove('active');
        }
      }
    });
    this._content = this.innerHTML;
  }

  render() {
    return html$1`<a href="#" @click="${this._onClick}">${unsafeHTML(this._content)}</a>`;
  }

  createRenderRoot() {
    return this;
  }

  _onClick(ev) {
    ev.preventDefault();
    const params = {
      position: null
    };

    if (this.xmlId) {
      params.id = this.xmlId;
      this.history && this.setParameter('id', this.xmlId);
    } else if (this.nodeId) {
      params.position = this.nodeId;
      this.history && this.setParameter('root', this.nodeId);
    }

    if (this.path) {
      params.path = this.path;
      this.history && this.setPath(this.path);
    }

    if (this.odd) {
      params.odd = this.odd;
      this.history && this.setParameter('odd', this.odd);
    }

    if (this.hash) {
      params.hash = this.hash;

      if (this.history) {
        this.getUrl().hash = this.hash;
      }
    } else if (this.history) {
      this.getUrl().hash = '';
    }

    this.pushHistory('link click');
    this.emitTo('pb-refresh', params);
  }
  /**
   * Fired when user clicks the link
   *
   * @event pb-refresh
   * @param {Object} Parameters as defined in properties
   */


}
customElements.define('pb-link', PbLink);

/**
 * @slot - unnamed default slot for link text
 * @fires pb-show-annotation - Fires when mouse hovers over a pb-facs-link, passing image reference and coordinates that pb-facsimile reacts to
 */

class PbFacsLink extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** URL pointing to the facsimile image to load */
      facs: {
        type: String
      },

      /** An array of coordinates describing a rectangle to highlight */
      coordinates: {
        type: Array
      },

      /** 
       * Type of event which should trigger the facsimile to display. 
       * Either 'click' or 'mouseover' (default). */
      trigger: {
        type: String
      },

      /**
       * If set, trigger a `pb-show-annotation` event as soon as the element is initialized.
       * Use this to make `pb-facsimile` or `pb-svg` switch to the given image/coordinates upon
       * load.
       */
      emitOnLoad: {
        type: Boolean,
        attribute: 'emit-on-load'
      }
    });
  }

  constructor() {
    super();
    this.trigger = 'mouseover';
  }

  connectedCallback() {
    super.connectedCallback();
  }

  firstUpdated() {
    const link = this.shadowRoot.querySelector('a');

    switch (this.trigger) {
      case 'click':
        link.addEventListener('click', this._linkListener.bind(this));
        break;

      default:
        link.addEventListener('mouseover', this._linkListener.bind(this));
        break;
    }

    if (this.emitOnLoad) {
      this._trigger();
    }
  }

  render() {
    return html$1`<a href="#"><slot></slot></a>`;
  }

  static get styles() {
    return css`
            :host {
            }

            a, a:link {
                text-decoration: none;
                color: inherit;
            }
        `;
  }

  _linkListener(ev) {
    ev.preventDefault();

    this._trigger();
  }

  _trigger() {
    console.log("<facs-link> %s %o", this.facs, this.coordinates);
    this.emitTo('pb-show-annotation', {
      file: this.facs,
      coordinates: this.coordinates
    });
  }
  /**
   * Fires when mouse hovers a pb-facs-link
   *
   * @event pb-show-annotation
   * @param {String} file - reference to facsimile file
   * @param {String} coordinates to highlight
   */


}
customElements.define('pb-facs-link', PbFacsLink);

/** Import external script dynamically */

function _import(name, location) {
  window.ESGlobalBridge.requestAvailability();
  return new Promise(resolve => {
    window.ESGlobalBridge.instance.load(name, location);
    window.addEventListener(`es-bridge-${name}-loaded`, () => resolve(), {
      once: true
    });
  });
}
/**
 * Update the stylesheet required by MathJax.
 * Needs to be done after typesetting has completed.
 * 
 * @param {Element} context 
 * @param {Element} styles 
 */


function _updateStyles(context, styles) {
  let root = context.getRootNode();

  if (root.nodeType === Node.DOCUMENT_NODE) {
    root = root.head;
  }

  const oldStyles = root.querySelector(`#${styles.id}`);

  if (oldStyles) {
    oldStyles.parentNode.removeChild(oldStyles);
  }

  root.appendChild(styles);
}
/**
 * Iterate through the given `pb-formula` elements and typeset the math.
 */


function _initMath(context, formulas) {
  formulas.forEach(formula => {
    if (formula.hasChildNodes()) {
      const display = formula.hasAttribute('display') || false;
      const mathml = formula.querySelector('math');
      const options = window.MathJax.getMetricsFor(formula.parentNode, display);
      options.display = display;
      let chtml;
      let source;

      if (mathml) {
        source = mathml.outerHTML;
        chtml = window.MathJax.mathml2chtml(source, options);
      } else {
        window.MathJax.texReset();
        source = formula.innerHTML;
        chtml = window.MathJax.tex2chtml(source, options);
      }

      formula.innerHTML = '';
      formula.appendChild(chtml);
      formula.setAttribute('loaded', 'loaded');
      formula.setAttribute('source', source);
    }
  });

  _updateStyles(context, window.MathJax.chtmlStylesheet());
}
/**
 * Search the passed in element for `pb-formula` elements and
 * render them via MathJax.
 * 
 * Formulas need to be processed sequentially or the output will
 * be screwed up. Therefore we cannot call MathJax asynchronously
 * but need to do it from this central controller.
 * 
 * @param {Element} elem the root element to process
 */


function typesetMath(elem) {
  const formulas = elem.querySelectorAll('pb-formula');
  console.log(`<pb-formula> Found ${formulas.length} elements to typeset ...`);

  if (formulas.length > 0) {
    if (window.MathJax) {
      _initMath(elem, formulas);

      return;
    }

    const showMenu = elem.querySelector('pb-formula[menu]');
    window.MathJax = {
      startup: {
        typeset: false,
        // Perform initial typeset?
        pageReady: () => _initMath(elem, formulas) // Called when MathJax and page are ready

      },
      options: {
        enableMenu: showMenu !== null
      }
    };

    _import('MathJax', 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js');
  }
}
/**
 * Represents a mathematical formula, either in TeX notation or MathML. The element itself
 * does not do any typesetting. Instead you must call the global `typesetMath(rootNode)` function and
 * pass it the root context which should be searched for `pb-notation` elements. The function will
 * then do the actual typesetting. The reason for this is that formulas need to be typeset synchronously, i.e. one
 * after the other.
 * 
 * The component detects automatically if the formula to typeset is in TeX notation or MathML.
 * 
 * @slot - should contain math in TeX notation or MathML
 */

class PbFormula extends LitElement {
  static get properties() {
    return Object.assign({
      /**
       * TeX notation only: render the formula in display mode, i.e. as block level element.
       */
      display: {
        type: Boolean
      },

      /**
       * Option: if set, enable the MathJax context menu. This affects **all** formulas
       * in the context (the page or pb-view), not just the current component!
       */
      menu: {
        type: Boolean
      },

      /**
       * Will be set once the element has been typeset.
       */
      loaded: {
        type: Boolean
      },

      /**
       * Will contain the source notation once the element has been typeset.
       */
      source: {
        type: String
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.display = false;
  }

  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);

    switch (name) {
      case 'loaded':
        this.loaded = true;
        break;

      case 'source':
        this.source = newVal;
        break;
    }
  }

  render() {
    if (!this.hasChildNodes()) {
      return null;
    }

    if (!this.loaded) {
      return html$1`<span class="loading">${translate('dialogs.loading')}</span>`;
    }

    return html$1`<div id="content" class="${this.display ? 'block' : ''}"><slot></slot></div>`;
  }

  static get styles() {
    return css`
            :host {
                display: inline-block;
            }
            .block {
                display: block;
            }
            .loading {
                color: #808080;
            }
        `;
  }

}
customElements.define('pb-formula', PbFormula);

/**
 * Dynamically load data by calling a server-side script, optionally triggered by an event.
 * This is used for e.g. the document list on the start page or the table
 * of contents.
 * 
 * @slot - default unnamed slot for content
 * @fires pb-start-update - Fired before the element updates its content
 * @fires pb-end-update - Fired after the element has finished updating its content
 * @fires pb-results-received - Fired when the component received content from the server
 * @fires pb-toggle - When received, changes the state of the feature
 */

class PbLoad extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** The URL for the AJAX request. If a relative URL is passed, it will be resolved
       * against the current API endpoint.
       */
      url: {
        type: String
      },

      /**
       * If set to true, the `url` property will be interpreted as a template string
       * containing placeholders for parameters in `{parameter-name}`. The placeholders
       * will be replaced by the actual parameters when building the final URL. Each parameter
       * used in the URL template will be removed from the request parameter list.
       */
      expand: {
        type: Boolean
      },

      /** ID of the pb-document this element is connected to. The document path to
       * load will be taken from the pb-document.
       */
      src: {
        type: String
      },

      /**
       * The container element into which the results returned by
       * the AJAX request will be loaded.
       */
      container: {
        type: String
      },

      /**
       * Should content be loaded immediately when the component is initialized?
       */
      auto: {
        type: Boolean
      },

      /**
       * Only load content once, not every time a `pb-load` event is received.
       */
      loadOnce: {
        type: Boolean
      },

      /**
       * If set, relative links (img, a) will be made absolute.
       */
      fixLinks: {
        type: Boolean,
        attribute: 'fix-links'
      },

      /**
       * Start offset to use for showing paginated content.
       */
      start: {
        type: Number
      },

      /**
       * If set, a parameter "language" will be added to the parameter list. 
       * Also, a refresh will be triggered if a `pb-i18n-update` event is received,
       * e.g. due to the user selecting a different interface language.
       * 
       * Also requires `requireLanguage` to be set on the surrounding `pb-page`.
       * See there for more information.
       */
      useLanguage: {
        type: Boolean,
        attribute: 'use-language'
      },
      history: {
        type: Boolean
      },
      event: {
        type: String
      },
      userParams: {
        type: Object
      }
    });
  }

  constructor() {
    super();
    this.auto = false;
    this.loadOnce = false;
    this.history = false;
    this.event = 'pb-load';
    this.loaded = false;
    this.language = null;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo(this.event, ev => {
      if (this.history && ev.detail && ev.detail.params) {
        const start = ev.detail.params.start;

        if (start) {
          this.setParameter('start', start);
          this.pushHistory('pagination', {
            start: start
          });
        }
      }

      PbLoad.waitOnce('pb-page-ready', () => {
        this.load(ev);
      });
    });

    if (this.history) {
      window.addEventListener('popstate', ev => {
        ev.preventDefault();

        if (ev.state && ev.state.start && ev.state.start !== this.start) {
          this.start = ev.state.start;
          this.load();
        }
      });
    }

    this.subscribeTo('pb-toggle', ev => {
      this.toggleFeature(ev);
    });
    this.subscribeTo('pb-i18n-update', ev => {
      const needsRefresh = this.language && this.language !== ev.detail.language;
      this.language = ev.detail.language;

      if (this.useLanguage && needsRefresh) {
        this.load();
      }
    }, []);
    this.signalReady();
  }

  firstUpdated() {
    if (this.auto) {
      this.start = this.getParameter('start', this.start);
      PbLoad.waitOnce('pb-page-ready', data => {
        if (data && data.language) {
          this.language = data.language;
        }

        this.wait(() => this.load());
      });
    } else {
      PbLoad.waitOnce('pb-page-ready', data => {
        if (data && data.language) {
          this.language = data.language;
        }
      });
    }
  }

  render() {
    return html$1`
            <slot></slot>
            <iron-ajax
                id="loadContent"
                verbose
                handle-as="text"
                method="get"
                with-credentials
                @response="${this._handleContent}"
                @error="${this._handleError}"></iron-ajax>
            <paper-dialog id="errorDialog">
                <h2>${translate('dialogs.error')}</h2>
                <paper-dialog-scrollable></paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm="dialog-confirm" autofocus="autofocus">
                    ${translate('dialogs.close')}
                    </paper-button>
                </div>
            </paper-dialog>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
        `;
  }

  toggleFeature(ev) {
    this.userParams = ev.detail.properties;
    console.log('<pb-load> toggle feature %o', this.userParams);

    if (ev.detail.action === 'refresh') {
      this.load();
    }
  }

  getURL(params) {
    let url = this.url;

    if (this.expand) {
      url = url.replace(/{([^})]+)}/g, (match, key) => {
        if (!params[key]) {
          return '';
        }

        const param = encodeURIComponent(params[key] || key);
        delete params[key];
        return param;
      });
    }

    return this.toAbsoluteURL(url);
  }

  load(ev) {
    if (!this.url) {
      return;
    }

    if (this.loadOnce && this.loaded) {
      return;
    }

    this.emitTo('pb-start-update');
    let params = {};

    if (ev) {
      if (ev instanceof Event) {
        if (ev.detail && ev.detail.params) {
          params = ev.detail.params;
        }
      } else {
        params = ev;
      }
    }

    const doc = this.getDocument();

    if (doc) {
      params.doc = doc.path;
    } // set start parameter to start property, but only if not provided otherwise already


    if (this.start && !params.start) {
      params.start = this.start;
    }

    if (this.language) {
      params.language = this.language;
    }

    params = this.prepareParameters(params);
    const url = this.getURL(params);
    console.log("<pb-load> Loading %s with parameters %o", url, params);
    const loader = this.shadowRoot.getElementById('loadContent');
    loader.params = params;
    loader.url = url;
    loader.generateRequest();

    if (this.loadOnce) {
      this.loaded = true;
    }
  }
  /**
   * Allow subclasses to set parameters before the request is being sent.
   *
   * @param params Map of parameters
   * @return new or modified parameters map
   */


  prepareParameters(params) {
    if (this.userParams) {
      return Object.assign(params, this.userParams);
    }

    return params;
  }

  _handleContent(ev) {
    const resp = this.shadowRoot.getElementById('loadContent').lastResponse;

    if (this.container) {
      this.style.display = 'none';
      document.querySelectorAll(this.container).forEach(elem => {
        elem.innerHTML = resp;

        this._parseHeaders(ev.detail.xhr, elem);

        this._fixLinks(elem);

        this._onLoad(elem);
      });
    } else {
      this.style.display = '';

      this._clearContent();

      const div = document.createElement('div');
      div.innerHTML = resp;

      this._parseHeaders(ev.detail.xhr, div);

      div.slot = '';
      this.appendChild(div);

      this._fixLinks(div);

      this._onLoad(div);
    }

    this.emitTo('pb-end-update');
  }

  _clearContent() {
    const contentSlot = this.shadowRoot.querySelector('slot:not([name])');

    if (contentSlot) {
      // clear content from slot
      contentSlot.assignedNodes().forEach(node => node.parentNode.removeChild(node));
    }
  }

  _handleError() {
    this.emitTo('pb-end-update');
    const loader = this.shadowRoot.getElementById('loadContent');
    const {
      response
    } = loader.lastError;
    let message;

    if (response) {
      message = response.description;
    } else {
      message = '<pb-i18n key="dialogs.serverError"></pb-i18n>';
    }

    const dialog = this.shadowRoot.getElementById('errorDialog');
    const body = dialog.querySelector("paper-dialog-scrollable");
    body.innerHTML = `<p><pb-i18n key="dialogs.serverError"></pb-i18n>: ${message} </p>`;
    dialog.open();
  }

  _parseHeaders(xhr, content) {
    // Try to determine number of pages and current position
    // Search for data-pagination-* attributes first and if they
    // can't be found, check HTTP headers
    function getPaginationParam(type) {
      const elem = content.querySelector(`[data-pagination-${type}]`);

      if (elem) {
        return elem.getAttribute(`data-pagination-${type}`);
      }

      return xhr.getResponseHeader(`pb-${type}`);
    }

    const total = getPaginationParam('total');
    const start = getPaginationParam('start');

    if (this.start !== start) {
      this.start = parseInt(start);
    }

    this.emitTo('pb-results-received', {
      "count": total ? parseInt(total, 10) : 0,
      "start": this.start,
      "params": this.shadowRoot.getElementById('loadContent').params
    });
  }

  _fixLinks(content) {
    typesetMath(content);

    if (this.fixLinks) {
      content.querySelectorAll('img').forEach(image => {
        const oldSrc = image.getAttribute('src');
        const src = new URL(oldSrc, `${this.getEndpoint()}/`);
        image.src = src;
      });
      content.querySelectorAll('a').forEach(link => {
        const oldHref = link.getAttribute('href');
        const href = new URL(oldHref, `${this.getEndpoint()}/`);
        link.href = href;
      });
    }
  }

  _onLoad(content) {}
  /**
   * Fired before the element updates its content
   *
   * @event pb-start-update
   * @param {object} Parameters to be passed to the request
   */

  /**
   * Fired after the element has finished updating its content
   *
   * @event pb-end-update
   */

  /**
   * Fired after the element has received content from the server
   *
   * @event pb-results-received
   * @param {int} count number of results received (according to `pb-total` header)
   * @param {int} start offset into the result set (according to `pb-start` header)
   */


}
customElements.define('pb-load', PbLoad);

/**
 * Component to browse through a collection of documents with sorting, filtering and facets.
 *
 * @slot toolbar - toolbar area
 * @slot - unnamed default slot
 * @slot footer - footer area
 * 
 * @fires pb-collection - Sent to inform e.g. pb-upload about current collection
 * @fires pb-search-resubmit - When received, set facet values as received from the event
 * @fires pb-login - When received, refresh the view if the user changed
 * 
 * @cssprop --pb-search-suggestions-background - Background for the autocomplete suggestions for the filter field
 * @cssprop --pb-search-suggestions-color - Text color for the autocomplete suggestion for the filter field
 * @cssprop --pb-search-label-color - Determines the color of small label above the sort by/filter by/filter fields
 * @cssprop --pb-search-input-color - Determines the color of the text in the sort by/filter by/filter fields
 * @cssprop --pb-search-focus-color - Color of the field labels and underline when in focus
 * @cssprop --pb-browse-toolbar-justify-content - How to justify the browse toolbar content, following flexbox justify-content property e.g. center, space-evenly, start...
 * 
 * @csspart delete-button - the delete button
 * @csspart sort-dropdown - dropdown for sorting
 * @csspart filter-dropdown - dropdown for filtering
 * @csspart filter-input - input for filtering
 */

class PbBrowseDocs extends PbLoad {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      sortBy: {
        type: String,
        attribute: 'sort-by'
      },
      sortOptions: {
        type: Array,
        attribute: 'sort-options'
      },
      sortLabel: {
        type: String
      },
      filter: {
        type: String
      },
      filterBy: {
        type: String,
        attribute: 'filter-by'
      },
      filterOptions: {
        type: Array,
        attribute: 'filter-options'
      },
      filterByLabel: {
        type: String
      },
      filterPlaceholderLabel: {
        type: String
      },
      collection: {
        type: String
      },
      facets: {
        type: Object
      },

      /** Id of the pb-login element to connect to */
      login: {
        type: String
      },

      /**
       * If set, requires the logged in user to be member of
       * the given group.
       */
      group: {
        type: String
      },
      subforms: {
        type: String
      },

      /**
       * If set, rewrite URLs to load pages as static HTML files,
       * so no TEI Publisher instance is required
       */
      static: {
        type: Boolean
      },
      _file: {
        type: String
      },
      _selected: {
        type: Array
      },
      _allowModification: {
        type: Boolean
      },
      _suggestions: {
        type: Array
      }
    });
  }

  constructor() {
    super();
    this.sortOptions = [];
    this.sortLabel = 'browse.sort';
    this.sortBy = 'default';
    this.filter = '';
    this.filterOptions = [{
      label: 'Title',
      value: 'title'
    }];
    this.filterByLabel = 'browse.filter';
    this.filterPlaceholderLabel = 'browse.filterPlaceholder';
    this.filterBy = 'title';
    this._allowModification = false;
    this._suggestions = [];
    this.static = false;
  }

  connectedCallback() {
    super.connectedCallback();
    const sortParam = this.getParameter('sort');

    if (sortParam) {
      this.sortBy = sortParam;
    }

    const filterParam = this.getParameter('filter');

    if (filterParam) {
      this.filter = filterParam;
      this.filterBy = this.getParameter('filterBy', this.filterBy);
    }

    this.facets = this.getParametersMatching(/^facet-.*$/);
    this.collection = this.getParameter('collection');
    this.subscribeTo('pb-search-resubmit', this._facets.bind(this));
    this.subscribeTo('pb-login', ev => {
      if (ev.detail.userChanged) {
        this._facets(ev);
      }
    }, []);
    document.addEventListener('pb-i18n-update', () => {
      // clear paper-listbox selection after language updates
      const lb = this.shadowRoot.getElementById('sort-list');
      let old = lb.selected;
      lb.selected = undefined;
      lb.selected = old;
      const fl = this.shadowRoot.getElementById('filter-list');
      old = fl.selected;
      fl.selected = undefined;
      fl.selected = old;
    });
  }

  firstUpdated() {
    PbBrowseDocs.waitOnce('pb-page-ready', options => {
      const loader = this.shadowRoot.getElementById('autocompleteLoader');

      if (cmpVersion(options.apiVersion, '1.0.0') >= 0) {
        loader.url = `${options.endpoint}/api/search/autocomplete`;

        if (!this.url) {
          this.url = 'api/collection';
        }
      } else {
        loader.url = `${options.endpoint}/modules/autocomplete.xql`;

        if (!this.url) {
          this.url = 'collection/';
        }
      }
    });
    this.shadowRoot.getElementById('autocomplete').addEventListener('autocomplete-change', this._autocomplete.bind(this));

    if (this.login) {
      const login = document.getElementById(this.login);

      if (!login) {
        console.error('<pb-browse-docs> connected pb-login element not found!');
      } else {
        this.subscribeTo('pb-login', ev => {
          this._allowModification = this._loggedIn(ev.detail.user, ev.detail.group);
        }, []);
        this._allowModification = login.loggedIn && this._loggedIn(login.user, login.groups);
      }
    }

    this.shadowRoot.getElementById('sort-list').addEventListener('selected-item-changed', this._sort.bind(this));
    this.shadowRoot.getElementById('delete').addEventListener('click', this._handleDelete.bind(this));
    super.firstUpdated();
  }

  render() {
    return html$1`
            <custom-style>
                <style>
                    :host {
                        --suggestions-item: {
                            color: var(--pb-search-suggestions-color, black);
                        };
                        --suggestions-wrapper: {
                            background: var(--pb-search-suggestions-background, white);
                        }
                    }
                </style>
            </custom-style>
            <slot name="header"></slot>
            <div class="toolbar">
                <paper-dropdown-menu id="sort" label="${translate(this.sortLabel)}" part="sort-dropdown">
                    <paper-listbox id="sort-list" selected="${this.sortBy}" slot="dropdown-content" class="dropdown-content" attr-for-selected="value">
                    ${this.sortOptions.map(option => html$1`<paper-item value="${option.value}">${translate(option.label)}</paper-item>`)}
                    </paper-listbox>
                </paper-dropdown-menu>
                <div>
                    <paper-dropdown-menu id="filterSelect" label="${translate(this.filterByLabel)}" part="filter-dropdown">
                        <paper-listbox id="filter-list" selected="${this.filterBy}" slot="dropdown-content" class="dropdown-content" attr-for-selected="value" @selected-item-changed="${this._filterChanged}">
                        ${this.filterOptions.map(option => html$1`<paper-item value="${option.value}">${translate(option.label)}</paper-item>`)}
                        </paper-listbox>
                    </paper-dropdown-menu>
                    <paper-input id="filterString" type="search" name="filter" label="${translate(this.filterPlaceholderLabel)}" value="${this.filter}"
                        @keyup="${this._handleEnter}" part="filter-input">
                        <iron-icon icon="search" @click="${this._filter}" slot="prefix"></iron-icon>
                    </paper-input>
                    <paper-autocomplete-suggestions id="autocomplete" for="filterString" source="${this._suggestions}" remote-source></paper-autocomplete-suggestions>
                </div>
            </div>
            <div class="toolbar">
                <slot name="toolbar"></slot>
                <paper-button id="delete" part="delete-button" title="${translate('browse.delete')}" class="${this._canModify(this._allowModification)}">
                    <iron-icon icon="delete"></iron-icon>
                    <span class="label">${translate('browse.delete')}</span>
                </paper-button>
            </div>
            <slot></slot>
            <slot name="footer"></slot>
            
            <iron-ajax
                id="loadContent"
                verbose
                handle-as="text"
                method="get"
                with-credentials
                @response="${this._handleContent}"
                @error="${this._handleError}"></iron-ajax>
            <iron-ajax
                id="autocompleteLoader"
                verbose
                handle-as="json"
                method="get"
                with-credentials
                @response="${this._updateSuggestions}"></iron-ajax>

            <paper-dialog id="deleteDialog">
                <h2>${translate('browse.delete')}</h2>
                <paper-dialog-scrollable>
                    <p>${translate('browse.confirmDeletion', {
      count: this._selected ? this._selected.length : 0
    })}</p>
                </paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm="dialog-confirm" autofocus @click="${this._confirmDelete}">${translate('dialogs.yes')}</paper-button>
                    <paper-button dialog-confirm="dialog-cancel">${translate('dialogs.no')}</paper-button>
                </div>
            </paper-dialog>
            <paper-dialog id="errorDialog">
                <h2>${translate('dialogs.error')}</h2>
                <paper-dialog-scrollable></paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm="dialog-confirm" autofocus="autofocus">
                    ${translate('dialogs.close')}
                    </paper-button>
                </div>
            </paper-dialog>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
                --paper-input-container-color: var(--pb-search-label-color, var(--paper-grey-500, #303030));
                --paper-input-container-input-color: var(--pb-search-input-color, var(--pb-color-primary, #000000));
                --paper-input-container-focus-color: var(--pb-search-focus-color, var(--paper-grey-500, #303030));
            }

            .toolbar {
                display: flex;
                justify-content: var(--pb-browse-toolbar-justify-content);
            }

            [name="toolbar"] {
                flex: 1 0;
            }

            #sort {
                display: block;
            }

            #filterString {
                position: relative;
                display: inline-block;
                vertical-align: bottom;
            }

            .hidden {
                display: none;
            }
        `;
  }

  getURL(params) {
    if (this.static) {
      // use a static URL
      return `collections/${this.collection ? this.collection + '/' : ''}${params.start || '1'}.html`;
    }

    const url = super.getURL(params);
    return this.collection ? `${url}/${this.collection}` : url;
  }

  prepareParameters(params) {
    params = this._paramsFromSubforms(params);
    params.sort = this.sortBy;

    if (this.filter) {
      params.filter = this.filter;
      params.browse = this.filterBy;
    }

    if (this.facets) {
      params = Object.assign(params, this.facets);
    }

    return params;
  }

  _paramsFromSubforms(params) {
    if (this.subforms) {
      document.querySelectorAll(this.subforms).forEach(form => {
        if (form.serializeForm) {
          Object.assign(params, form.serializeForm());
        }
      });
    }

    return params;
  }
  /**
   * returns selected documents.
   *
   * @returns {Array}
   */


  getSelected() {
    const selected = [];

    if (this.container) {
      document.querySelectorAll(this.container).forEach(container => container.querySelectorAll('.document-select paper-checkbox[checked]').forEach(checkbox => {
        selected.push(checkbox.value);
      }));
    } else {
      this.querySelectorAll('.document-select paper-checkbox[checked]').forEach(checkbox => {
        selected.push(checkbox.value);
      });
    }

    return selected;
  }

  _filter() {
    const filter = this.shadowRoot.getElementById('filterString').value;
    const filterBy = this.shadowRoot.getElementById('filter-list').selected;

    if (typeof filter !== 'undefined') {
      console.log('<pb-browse-docs> Filter by %s', filter);
      this.filter = filter;
      this.setParameter('filter', filter);
      this.setParameter('filterBy', filterBy);
      this.pushHistory('filter docs');
      this.load();
    }
  }

  _filterChanged() {
    const filterBy = this.shadowRoot.getElementById('filter-list').selected;

    if (filterBy && filterBy !== this.filterBy) {
      console.log('<pb-browse-docs> Filtering on %s', filterBy);
      this.filterBy = filterBy;
    }
  }

  _sort() {
    const sortBy = this.shadowRoot.getElementById('sort-list').selected;

    if (sortBy && sortBy !== this.sortBy) {
      console.log('<pb-browse-docs> Sorting by %s', sortBy);
      this.sortBy = sortBy;
      this.setParameter('sort', sortBy);
      this.pushHistory('sort docs');
      this.load();
    }
  }

  _facets(ev) {
    if (ev.detail && ev.detail.params) {
      this.clearParametersMatching(/^(all-|facet-).*/);

      for (let param in ev.detail.params) {
        this.setParameter(param, ev.detail.params[param]);
      }

      this.facets = ev.detail.params;
      this.start = 1;
      this.pushHistory('facets');
    }

    this.load();
  }

  _onLoad(content) {
    window.scrollTo(0, 0);
    const div = content.querySelector('[data-root]');
    const collection = div && div.getAttribute('data-root');
    const writable = div && div.classList.contains('writable');
    this.emitTo('pb-collection', {
      writable,
      collection
    });
    document.querySelectorAll('[can-write]').forEach(elem => {
      elem.disabled = !writable;
    });
    content.querySelectorAll('[data-collection]').forEach(link => {
      link.addEventListener('click', ev => {
        ev.preventDefault();
        this.collection = link.getAttribute('data-collection');
        this.start = 1;
        this.setParameter('collection', this.collection);
        this.pushHistory('browse collection');
        console.log('<pb-browse-docs> loading collection %s', this.collection);
        this.load();
      });
    });
  }

  _handleDelete(target, ev) {
    const deleteDialog = this.shadowRoot.getElementById('deleteDialog');
    const selected = this.getSelected();

    if (selected.length > 0) {
      this._selected = selected;
      deleteDialog.open();
    }
  }

  _confirmDelete() {
    if (!(this._file || this._selected)) {
      return;
    }

    let files;

    if (this._selected) {
      files = this._selected;
    } else {
      files = [this._file];
    }

    console.log('<pb-browse-docs> Deleting %o', this._file);
    const params = {
      action: 'delete',
      'docs[]': files
    };
    this._file = null;
    this._selected = null;
    this.load(params);
  }

  _loggedIn(user, groups) {
    if (user == null) {
      return false;
    }

    if (this.group) {
      if (!groups) {
        return false;
      }

      return groups.indexOf(this.group) > -1;
    }

    return true;
  }

  _canModify(allowModification) {
    return allowModification ? '' : 'hidden';
  }

  _autocomplete(ev) {
    const autocompleteLoader = this.shadowRoot.getElementById('autocompleteLoader');
    autocompleteLoader.params = {
      query: ev.detail.option.text,
      field: this.filterBy
    };
    autocompleteLoader.generateRequest();
  }

  _updateSuggestions() {
    const autocomplete = this.shadowRoot.getElementById('autocomplete');
    const autocompleteLoader = this.shadowRoot.getElementById('autocompleteLoader');
    autocomplete.suggestions(autocompleteLoader.lastResponse);
  }

  _handleEnter(e) {
    if (e.keyCode == 13) {
      this._filter();
    }
  }

}
customElements.define('pb-browse-docs', PbBrowseDocs);

/**
 * Represents a Publisher document. It has no visual presentation but holds meta-data
 * about the document to be used by other components like `pb-view`. Every `pb-view`
 * references a `pb-document`.
 * `pb-document` requires an id attribute to allow other components to access it.
 *
 * @fires pb-document - Fires update event
 */

class PbDocument extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The path to the document to be loaded. Should be relative to `root`.
       */
      path: {
        type: String,
        reflect: true
      },

      /**
       * The root collection which will be used to resolve relative paths
       * specified in `path`.
       */
      rootPath: {
        type: String,
        attribute: 'root-path'
      },

      /**
       * The odd file which should be used to render this document by default. Might be
       * overwritten in a `pb-view`. The odd should be specified by its name without path
       * or the `.odd` suffix.
       */
      odd: {
        type: String,
        reflect: true
      },

      /**
       * The default view to be used for displaying this document. Can be either `page`, `div` or `simple`.
       * Might be overwritten in a `pb-view`.
       *
       * Value | Displayed content
       * ------|------------------
       * `page` | content is displayed page by page as determined by tei:pb
       * `div` | content is displayed by divisions
       * `single` | do not paginate but display entire content at once
       */
      view: {
        type: String,
        reflect: true
      },
      sourceView: {
        type: String,
        attribute: 'source-view'
      }
    });
  }

  constructor() {
    super();
    this.path = '';
    this.rootPath = '';
  }

  connectedCallback() {
    super.connectedCallback();
  }

  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);

    if (oldVal) {
      console.log('<pb-document> Emit update event');
      this.emitTo('pb-document', this);
    }
  }
  /**
   * Returns the name of the document without path.
   *
   * @returns {string} Name of the document
   */


  getFileName() {
    return this.path.replace(/^.*?([^\/]+)$/, '$1');
  }
  /**
   * Returns the full path to the document.
    * @returns {string} Full path to the document
   */


  getFullPath() {
    return this.rootPath + '/' + this.path;
  }

}

customElements.define('pb-document', PbDocument);

/**
 * Navigate backward/forward in a document. This component does not implement any functionality itself.
 * It just sends a `pb-navigate` event when clicked. You may also assign a shortcut key by setting property
 * `keyboard`.
 *
 * @slot - default unnamed slot
 * @fires pb-navigate - Fire event indicating that listening components should navigate in the given direction
 * @fires pb-update - When received, updates the state of navigation buttons (disables when no forward/backward navigation possible)
 */

class PbNavigation extends pbHotkeys(pbMixin(LitElement)) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The direction to navigate in, either `forward` or `backward`
       */
      direction: {
        type: String
      },

      /**
       * Register a shortcut key, e.g. 'left' or 'shift+left'
       */
      keyboard: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.direction = 'forward';
    this.disabled = true;
  }

  connectedCallback() {
    super.connectedCallback();

    if (this.keyboard) {
      this.hotkeys = {
        'next': this.keyboard
      };
    }

    this.subscribeTo('pb-update', this._update.bind(this));
    this.registerHotkey('next', () => this.emitTo('pb-navigate', {
      direction: this.direction
    }));
    this.signalReady();
  }

  _update(ev) {
    if (this.direction === 'forward') {
      if (ev.detail.data.next) {
        this.disabled = false;
      } else {
        this.disabled = true;
      }
    } else if (ev.detail.data.previous) {
      this.disabled = false;
    } else {
      this.disabled = true;
    }
  }

  _handleClick() {
    this.emitTo('pb-navigate', {
      direction: this.direction
    });
  }

  render() {
    return html$1`
            <a id="button" @click="${this._handleClick}"><slot></slot></a>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: inline;
            }
            :host([disabled]) {
                display: none;
            }
        `;
  }

}
customElements.define('pb-navigation', PbNavigation);

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

var consoleLogger = {
  type: 'logger',
  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};

var Logger = function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Logger);

    this.init(concreteLogger, options);
  }

  _createClass(Logger, [{
    key: "init",
    value: function init(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.prefix = options.prefix || 'i18next:';
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.forward(args, 'log', '', true);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.forward(args, 'warn', '', true);
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.forward(args, 'error', '');
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger(this.logger, _objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);

  return Logger;
}();

var baseLogger = new Logger();

var EventEmitter = function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this.observers = {};
  }

  _createClass(EventEmitter, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;

      events.split(' ').forEach(function (event) {
        _this.observers[event] = _this.observers[event] || [];

        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;

      if (!listener) {
        delete this.observers[event];
        return;
      }

      this.observers[event] = this.observers[event].filter(function (l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function (observer) {
          observer.apply(void 0, args);
        });
      }

      if (this.observers['*']) {
        var _cloned = [].concat(this.observers['*']);

        _cloned.forEach(function (observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);

  return EventEmitter;
}();

function defer() {
  var res;
  var rej;
  var promise = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}

function makeString(object) {
  if (object == null) return '';
  return '' + object;
}

function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}

function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}

function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}

function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);

  if (value !== undefined) {
    return value;
  }

  return getPath(defaultData, key);
}

function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== '__proto__') {
      if (prop in target) {
        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}

function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}

var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};

function escape$1(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}

var isIE10 = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;

var ResourceStore = function (_EventEmitter) {
  _inherits(ResourceStore, _EventEmitter);

  function ResourceStore(data) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };

    _classCallCheck(this, ResourceStore);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore).call(this));

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    _this.data = data || {};
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    return _this;
  }

  _createClass(ResourceStore, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);

      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var path = [lng, ns];
      if (key && typeof key !== 'string') path = path.concat(key);
      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
      }

      return getPath(this.data, path);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === undefined) keySeparator = '.';
      var path = [lng, ns];
      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        value = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent) this.emit('added', lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        silent: false
      };

      for (var m in resources) {
        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
      }

      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        deep = resources;
        resources = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};

      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread({}, pack, resources);
      }

      setPath(this.data, path, pack);
      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }

      this.removeNamespaces(ns);
      this.emit('removed', lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== undefined;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);

  return ResourceStore;
}(EventEmitter);

var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};

var Translator = function (_EventEmitter) {
  _inherits(Translator, _EventEmitter);

  function Translator(services) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Translator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator).call(this));

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this));
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    _this.logger = baseLogger.create('translator');
    return _this;
  }

  _createClass(Translator, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== undefined;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === undefined) nsSeparator = ':';
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS;

      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var m = key.match(this.interpolator.nestingRegexp);

        if (m && m.length > 0) {
          return {
            key: key,
            namespaces: namespaces
          };
        }

        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }

      if (typeof namespaces === 'string') namespaces = [namespaces];
      return {
        key: key,
        namespaces: namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;

      if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }

      if (!options) options = {};
      if (keys === undefined || keys === null) return '';
      if (!Array.isArray(keys)) keys = [String(keys)];
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;

      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
          key = _this$extractFromKey.key,
          namespaces = _this$extractFromKey.namespaces;

      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

      if (lng && lng.toLowerCase() === 'cimode') {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }

        return key;
      }

      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
        if (!options.returnObjects && !this.options.returnObjects) {
          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }

        if (keySeparator) {
          var resTypeIsArray = resType === '[object Array]';
          var copy$$1 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy$$1[m] === deepKey) copy$$1[m] = res[m];
            }
          }

          res = copy$$1;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;

        if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
          usedDefault = true;

          if (options.count !== undefined) {
            var suffix = this.pluralResolver.getSuffix(lng, options.count);
            res = options["defaultValue".concat(suffix)];
          }

          if (!res) res = options.defaultValue;
        }

        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }

        var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);

          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread({}, options, {
              keySeparator: false
            }));
            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
          }

          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === 'all') {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }

          var send = function send(l, k) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
            }

            _this2.emit('missingKey', l, namespace, k, res);
          };

          if (this.options.saveMissing) {
            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function (l) {
                var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

                plurals.forEach(function (p) {
                  return send([l], p);
                });
              });
            } else {
              send(lngs, key);
            }
          }
        }

        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
      }

      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;

      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved: resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
          interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
        }));
        var skipOnVariables = options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        var nestBef;

        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }

        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);

        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft) options.nest = false;
        }

        if (options.nest !== false) res = this.interpolator.nest(res, function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (lastKey && lastKey[0] === args[0]) {
            _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));

            return null;
          }

          return _this3.translate.apply(_this3, args.concat([key]));
        }, options);
        if (options.interpolation) this.interpolator.reset();
      }

      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
          i18nResolved: resolved
        }, options) : options, this);
      }

      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === 'string') keys = [keys];
      keys.forEach(function (k) {
        if (_this4.isValidLookup(found)) return;

        var extracted = _this4.extractFromKey(k, options);

        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
        var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function (ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;

          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;

            _this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
          }

          codes.forEach(function (code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKey = key;
            var finalKeys = [finalKey];

            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count);
              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context));
              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
            }

            var possibleKey;

            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey: usedKey,
        exactUsedKey: exactUsedKey,
        usedLng: usedLng,
        usedNS: usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }]);

  return Translator;
}(EventEmitter);

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil = function () {
  function LanguageUtil(options) {
    _classCallCheck(this, LanguageUtil);

    this.options = options;
    this.whitelist = this.options.supportedLngs || false;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create('languageUtils');
  }

  _createClass(LanguageUtil, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return null;
      var p = code.split('-');
      if (p.length === 2) return null;
      p.pop();
      if (p[p.length - 1].toLowerCase() === 'x') return null;
      return this.formatLanguageCode(p.join('-'));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return code;
      var p = code.split('-');
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === 'string' && code.indexOf('-') > -1) {
        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
        var p = code.split('-');

        if (this.options.lowerCaseLng) {
          p = p.map(function (part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2) p[1] = p[1].toUpperCase();
          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
        }

        return p.join('-');
      }

      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code) {
      this.logger.deprecate('languageUtils.isWhitelisted', 'function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it\'s usage asap.');
      return this.isSupportedCode(code);
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }

      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;

      if (!codes) return null;
      var found;
      codes.forEach(function (code) {
        if (found) return;

        var cleanedLng = _this.formatLanguageCode(code);

        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });

      if (!found && this.options.supportedLngs) {
        codes.forEach(function (code) {
          if (found) return;

          var lngOnly = _this.getLanguagePartFromCode(code);

          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = _this.options.supportedLngs.find(function (supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
          });
        });
      }

      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
      if (!code) return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;

      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];

      var addCode = function addCode(c) {
        if (!c) return;

        if (_this2.isSupportedCode(c)) {
          codes.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };

      if (typeof code === 'string' && code.indexOf('-') > -1) {
        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === 'string') {
        addCode(this.formatLanguageCode(code));
      }

      fallbackCodes.forEach(function (fc) {
        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);

  return LanguageUtil;
}();

var sets = [{
  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
  nr: [1],
  fc: 3
}, {
  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ['ar'],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ['cs', 'sk'],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ['csb', 'pl'],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ['cy'],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ['fr'],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ['ga'],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ['gd'],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ['is'],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ['jv'],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ['kw'],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ['lt'],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ['lv'],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ['mk'],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ['mnk'],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ['mt'],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ['or'],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ['ro'],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ['sl'],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ['he', 'iw'],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver = function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');
    this.rules = createRules();
  }

  _createClass(PluralResolver, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var rule = this.getRule(code);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var _this = this;

      var ret = [];
      var rule = this.getRule(code);
      if (!rule) return ret;
      rule.numbers.forEach(function (n) {
        var suffix = _this.getSuffix(code, n);

        ret.push("".concat(key).concat(suffix));
      });
      return ret;
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var _this2 = this;

      var rule = this.getRule(code);

      if (rule) {
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];

        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = 'plural';
          } else if (suffix === 1) {
            suffix = '';
          }
        }

        var returnSuffix = function returnSuffix() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        };

        if (this.options.compatibilityJSON === 'v1') {
          if (suffix === 1) return '';
          if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (this.options.compatibilityJSON === 'v2') {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }

        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }

      this.logger.warn("no plural rule found for: ".concat(code));
      return '';
    }
  }]);

  return PluralResolver;
}();

var Interpolator = function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Interpolator);

    this.logger = baseLogger.create('interpolator');
    this.options = options;

    this.format = options.interpolation && options.interpolation.format || function (value) {
      return value;
    };

    this.init(options);
  }

  _createClass(Interpolator, [{
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape$1;
      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, 'g');
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;

      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

      function regexSafe(val) {
        return val.replace(/\$/g, '$$$$');
      }

      var handleFormat = function handleFormat(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, undefined, lng) : path;
        }

        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, options);
      };

      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function (todo) {
        replaces = 0;

        while (match = todo.regex.exec(str)) {
          value = handleFormat(match[1].trim());

          if (value === undefined) {
            if (typeof missingInterpolationHandler === 'function') {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === 'string' ? temp : '';
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));

              value = '';
            }
          } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {
            value = makeString(value);
          }

          str = str.replace(match[0], todo.safeValue(value));
          todo.regex.lastIndex = 0;
          replaces++;

          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var match;
      var value;

      var clonedOptions = _objectSpread({}, options);

      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;

      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');

        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }

        delete clonedOptions.defaultValue;
        return key;
      }

      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;

        if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function (elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }

        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== 'string') return value;
        if (typeof value !== 'string') value = makeString(value);

        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = '';
        }

        if (doReduce) {
          value = formatters.reduce(function (v, f) {
            return _this2.format(v, f, options.lng, options);
          }, value.trim());
        }

        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }

      return str;
    }
  }]);

  return Interpolator;
}();

function remove(arr, what) {
  var found = arr.indexOf(what);

  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}

var Connector = function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  function Connector(backend, store, services) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector).call(this));

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create('backendConnector');
    _this.state = {};
    _this.queue = [];

    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }

    return _this;
  }

  _createClass(Connector, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;

      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function (lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function (ns) {
          var name = "".concat(lng, "|").concat(ns);

          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ;else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0) pending.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0) pending.push(name);
            if (toLoad.indexOf(name) < 0) toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces) toLoadLanguages.push(lng);
      });

      if (toLoad.length || pending.length) {
        this.queue.push({
          pending: pending,
          loaded: {},
          errors: [],
          callback: callback
        });
      }

      return {
        toLoad: toLoad,
        pending: pending,
        toLoadLanguages: toLoadLanguages,
        toLoadNamespaces: toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split('|');
      var lng = s[0];
      var ns = s[1];
      if (err) this.emit('failedLoading', lng, ns, err);

      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }

      this.state[name] = err ? -1 : 2;
      var loaded = {};
      this.queue.forEach(function (q) {
        pushPath(q.loaded, [lng], ns);
        remove(q.pending, name);
        if (err) q.errors.push(err);

        if (q.pending.length === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function (l) {
            if (!loaded[l]) loaded[l] = [];

            if (q.loaded[l].length) {
              q.loaded[l].forEach(function (ns) {
                if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
              });
            }
          });
          q.done = true;

          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit('loaded', loaded);
      this.queue = this.queue.filter(function (q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;

      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : undefined;
      if (!lng.length) return callback(null, {});
      return this.backend[fcName](lng, ns, function (err, data) {
        if (err && data && tried < 5) {
          setTimeout(function () {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }

        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if (!this.backend) {
        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
        return callback && callback();
      }

      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === 'string') namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);

      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }

      toLoad.toLoad.forEach(function (name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var s = name.split('|');
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        return;
      }

      if (key === undefined || key === null || key === '') return;

      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread({}, options, {
          isUpdate: isUpdate
        }));
      }

      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);

  return Connector;
}(EventEmitter);

function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: 'all',
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: 'fallback',
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (_typeof(args[1]) === 'object') ret = args[1];
      if (typeof args[1] === 'string') ret.defaultValue = args[1];
      if (typeof args[2] === 'string') ret.tDescription = args[2];

      if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function (key) {
          ret[key] = options[key];
        });
      }

      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      nestingOptionsSeparator: ',',
      maxReplaces: 1000,
      skipOnVariables: false
    }
  };
}

function transformOptions(options) {
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];

  if (options.whitelist) {
    if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
      options.whitelist = options.whitelist.concat(['cimode']);
    }

    options.supportedLngs = options.whitelist;
  }

  if (options.nonExplicitWhitelist) {
    options.nonExplicitSupportedLngs = options.nonExplicitWhitelist;
  }

  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
    options.supportedLngs = options.supportedLngs.concat(['cimode']);
  }

  return options;
}

function noop() {}

var I18n = function (_EventEmitter) {
  _inherits(I18n, _EventEmitter);

  function I18n() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, I18n);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };

    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);

        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }

      setTimeout(function () {
        _this.init(options, callback);
      }, 0);
    }

    return _this;
  }

  _createClass(I18n, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (options.whitelist && !options.supportedLngs) {
        this.logger.deprecate('whitelist', 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
      }

      if (options.nonExplicitWhitelist && !options.nonExplicitSupportedLngs) {
        this.logger.deprecate('whitelist', 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
      }

      this.options = _objectSpread({}, get(), this.options, transformOptions(options));
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;

      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === 'function') return new ClassOrObject();
        return ClassOrObject;
      }

      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }

        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on('*', function (event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });

        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }

        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }

        this.translator = new Translator(this.services, this.options);
        this.translator.on('*', function (event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function (m) {
          if (m.init) m.init(_this2);
        });
      }

      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn('init: no languageDetector is used and no lng is defined');
      }

      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
      storeApi.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store;

          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
      storeApiChained.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store2;

          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);

          return _this2;
        };
      });
      var deferred = defer();

      var load = function load() {
        _this2.changeLanguage(_this2.options.lng, function (err, t) {
          _this2.isInitialized = true;
          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);

          _this2.emit('initialized', _this2.options);

          deferred.resolve(t);
          callback(err, t);
        });
      };

      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }

      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === 'string' ? language : this.language;
      if (typeof language === 'function') usedCallback = language;

      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
        var toLoad = [];

        var append = function append(lng) {
          if (!lng) return;

          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

          lngs.forEach(function (l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };

        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function (l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }

        if (this.options.preload) {
          this.options.preload.forEach(function (l) {
            return append(l);
          });
        }

        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function (err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');

      if (module.type === 'backend') {
        this.modules.backend = module;
      }

      if (module.type === 'logger' || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }

      if (module.type === 'languageDetector') {
        this.modules.languageDetector = module;
      }

      if (module.type === 'i18nFormat') {
        this.modules.i18nFormat = module;
      }

      if (module.type === 'postProcessor') {
        postProcessor.addPostProcessor(module);
      }

      if (module.type === '3rdParty') {
        this.modules.external.push(module);
      }

      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;

      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit('languageChanging', lng);

      var done = function done(err, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);

          _this4.translator.changeLanguage(l);

          _this4.isLanguageChangingTo = undefined;

          _this4.emit('languageChanged', l);

          _this4.logger.log('languageChanged', l);
        } else {
          _this4.isLanguageChangingTo = undefined;
        }

        deferred.resolve(function () {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function () {
          return _this4.t.apply(_this4, arguments);
        });
      };

      var setLng = function setLng(lngs) {
        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);

        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }

          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }

        _this4.loadResources(l, function (err) {
          done(err, l);
        });
      };

      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }

      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;

      var fixedT = function fixedT(key, opts) {
        var options;

        if (_typeof(opts) !== 'object') {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }

          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread({}, opts);
        }

        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        return _this5.t(key, options);
      };

      if (typeof lng === 'string') {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }

      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;

      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;

      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isInitialized) {
        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
        return false;
      }

      if (!this.languages || !this.languages.length) {
        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
        return false;
      }

      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === 'cimode') return true;

      var loadNotPending = function loadNotPending(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];

        return loadState === -1 || loadState === 2;
      };

      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== undefined) return preResult;
      }

      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;

      var deferred = defer();

      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }

      if (typeof ns === 'string') ns = [ns];
      ns.forEach(function (n) {
        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
      });
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === 'string') lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function (lng) {
        return preloaded.indexOf(lng) < 0;
      });

      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }

      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng) return 'rtl';
      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
    }
  }, {
    key: "createInstance",
    value: function createInstance() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      return new I18n(options, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

      var mergedOptions = _objectSpread({}, this.options, options, {
        isClone: true
      });

      var clone = new I18n(mergedOptions);
      var membersToCopy = ['store', 'services', 'language'];
      membersToCopy.forEach(function (m) {
        clone[m] = _this8[m];
      });
      clone.services = _objectSpread({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on('*', function (event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }]);

  return I18n;
}(EventEmitter);

var i18next = new I18n();

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

var arr = [];
var each = arr.forEach;
var slice = arr.slice;

function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
} // eslint-disable-next-line no-control-regex


var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

var serializeCookie = function serializeCookie(name, val, options) {
  var opt = options || {};
  opt.path = opt.path || '/';
  var value = encodeURIComponent(val);
  var str = name + '=' + value;

  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) str += '; HttpOnly';
  if (opt.secure) str += '; Secure';

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;

      case 'lax':
        str += '; SameSite=Lax';
        break;

      case 'strict':
        str += '; SameSite=Strict';
        break;

      case 'none':
        str += '; SameSite=None';
        break;

      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
};

var cookie = {
  create: function create(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      path: '/',
      sameSite: 'strict'
    };

    if (minutes) {
      cookieOptions.expires = new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);
    }

    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = name + '=';
    var ca = document.cookie.split(';');

    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];

      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }

      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }

    return null;
  },
  remove: function remove(name) {
    this.create(name, '', -1);
  }
};
var cookie$1 = {
  name: 'cookie',
  lookup: function lookup(options) {
    var found;

    if (options.lookupCookie && typeof document !== 'undefined') {
      var c = cookie.read(options.lookupCookie);
      if (c) found = c;
    }

    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== 'undefined') {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
    }
  }
};
var querystring = {
  name: 'querystring',
  lookup: function lookup(options) {
    var found;

    if (typeof window !== 'undefined') {
      var query = window.location.search.substring(1);
      var params = query.split('&');

      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf('=');

        if (pos > 0) {
          var key = params[i].substring(0, pos);

          if (key === options.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }

    return found;
  }
};
var hasLocalStorageSupport = null;

var localStorageAvailable = function localStorageAvailable() {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;

  try {
    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
    var testKey = 'i18next.translate.boo';
    window.localStorage.setItem(testKey, 'foo');
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }

  return hasLocalStorageSupport;
};

var localStorage$1 = {
  name: 'localStorage',
  lookup: function lookup(options) {
    var found;

    if (options.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng) found = lng;
    }

    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport = null;

var sessionStorageAvailable = function sessionStorageAvailable() {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;

  try {
    hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;
    var testKey = 'i18next.translate.boo';
    window.sessionStorage.setItem(testKey, 'foo');
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }

  return hasSessionStorageSupport;
};

var sessionStorage = {
  name: 'sessionStorage',
  lookup: function lookup(options) {
    var found;

    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
      if (lng) found = lng;
    }

    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options.lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: 'navigator',
  lookup: function lookup(options) {
    var found = [];

    if (typeof navigator !== 'undefined') {
      if (navigator.languages) {
        // chrome only; not an array, so can't use .push.apply instead of iterating
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }

      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }

      if (navigator.language) {
        found.push(navigator.language);
      }
    }

    return found.length > 0 ? found : undefined;
  }
};
var htmlTag = {
  name: 'htmlTag',
  lookup: function lookup(options) {
    var found;
    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);

    if (htmlTag && typeof htmlTag.getAttribute === 'function') {
      found = htmlTag.getAttribute('lang');
    }

    return found;
  }
};
var path = {
  name: 'path',
  lookup: function lookup(options) {
    var found;

    if (typeof window !== 'undefined') {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);

      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === 'number') {
          if (typeof language[options.lookupFromPathIndex] !== 'string') {
            return undefined;
          }

          found = language[options.lookupFromPathIndex].replace('/', '');
        } else {
          found = language[0].replace('/', '');
        }
      }
    }

    return found;
  }
};
var subdomain = {
  name: 'subdomain',
  lookup: function lookup(options) {
    var found;

    if (typeof window !== 'undefined') {
      var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);

      if (language instanceof Array) {
        if (typeof options.lookupFromSubdomainIndex === 'number') {
          found = language[options.lookupFromSubdomainIndex].replace('http://', '').replace('https://', '').replace('.', '');
        } else {
          found = language[0].replace('http://', '').replace('https://', '').replace('.', '');
        }
      }
    }

    return found;
  }
};

function getDefaults() {
  return {
    order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],
    lookupQuerystring: 'lng',
    lookupCookie: 'i18next',
    lookupLocalStorage: 'i18nextLng',
    lookupSessionStorage: 'i18nextLng',
    // cache user language
    caches: ['localStorage'],
    excludeCacheFor: ['cimode'] //cookieMinutes: 10,
    //cookieDomain: 'myDomain'

  };
}

var Browser = /*#__PURE__*/function () {
  function Browser(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck$1(this, Browser);

    this.type = 'languageDetector';
    this.detectors = {};
    this.init(services, options);
  }

  _createClass$1(Browser, [{
    key: "init",
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options, this.options || {}, getDefaults()); // backwards compatibility

      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage$1);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;

      if (!detectionOrder) detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function (detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup = _this.detectors[detectorName].lookup(_this.options);

          if (lookup && typeof lookup === 'string') lookup = [lookup];
          if (lookup) detected = detected.concat(lookup);
        }
      });
      if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0

      return detected.length > 0 ? detected[0] : null; // a little backward compatibility
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage(lng, caches) {
      var _this2 = this;

      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function (cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);

  return Browser;
}();

Browser.type = 'languageDetector';

var arr$1 = [];
var each$1 = arr$1.forEach;
var slice$1 = arr$1.slice;

function defaults$1(obj) {
  each$1.call(slice$1.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

function addQueryString(url, params) {
  if (params && _typeof(params) === 'object') {
    var queryString = '',
        e = encodeURIComponent; // Must encode data

    for (var paramName in params) {
      queryString += '&' + e(paramName) + '=' + e(params[paramName]);
    }

    if (!queryString) {
      return url;
    }

    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
  }

  return url;
} // https://gist.github.com/Xeoncross/7663273


function ajax(url, options, callback, data, cache) {
  if (data && _typeof(data) === 'object') {
    if (!cache) {
      data['_t'] = new Date();
    } // URL encoded form data must be in querystring format


    data = addQueryString('', data).slice(1);
  }

  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }

  try {
    var x;

    if (XMLHttpRequest) {
      x = new XMLHttpRequest();
    } else {
      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');
    }

    x.open(data ? 'POST' : 'GET', url, 1);

    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }

    x.withCredentials = !!options.withCredentials;

    if (data) {
      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    }

    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }

    var h = options.customHeaders;
    h = typeof h === 'function' ? h() : h;

    if (h) {
      for (var i in h) {
        x.setRequestHeader(i, h[i]);
      }
    }

    x.onreadystatechange = function () {
      x.readyState > 3 && callback && callback(x.responseText, x);
    };

    x.send(data);
  } catch (e) {
    console && console.log(e);
  }
}

function getDefaults$1() {
  return {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
    allowMultiLoading: false,
    parse: JSON.parse,
    parsePayload: function parsePayload(namespace, key, fallbackValue) {
      return _defineProperty({}, key, fallbackValue || '');
    },
    crossDomain: false,
    ajax: ajax
  };
}

var Backend = /*#__PURE__*/function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Backend);

    this.init(services, options);
    this.type = 'backend';
  }

  _createClass(Backend, [{
    key: "init",
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.services = services;
      this.options = defaults$1(options, this.options || {}, getDefaults$1());
    }
  }, {
    key: "readMulti",
    value: function readMulti(languages, namespaces, callback) {
      var loadPath = this.options.loadPath;

      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath(languages, namespaces);
      }

      var url = this.services.interpolator.interpolate(loadPath, {
        lng: languages.join('+'),
        ns: namespaces.join('+')
      });
      this.loadUrl(url, callback);
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      var loadPath = this.options.loadPath;

      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath([language], [namespace]);
      }

      var url = this.services.interpolator.interpolate(loadPath, {
        lng: language,
        ns: namespace
      });
      this.loadUrl(url, callback);
    }
  }, {
    key: "loadUrl",
    value: function loadUrl(url, callback) {
      var _this = this;

      this.options.ajax(url, this.options, function (data, xhr) {
        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true
        /* retry */
        );
        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false
        /* no retry */
        );
        var ret, err;

        try {
          ret = _this.options.parse(data, url);
        } catch (e) {
          err = 'failed parsing ' + url + ' to json';
        }

        if (err) return callback(err, false);
        callback(null, ret);
      });
    }
  }, {
    key: "create",
    value: function create(languages, namespace, key, fallbackValue) {
      var _this2 = this;

      if (typeof languages === 'string') languages = [languages];
      var payload = this.options.parsePayload(namespace, key, fallbackValue);
      languages.forEach(function (lng) {
        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, {
          lng: lng,
          ns: namespace
        });

        _this2.options.ajax(url, _this2.options, function (data, xhr) {//const statusCode = xhr.status.toString();
          // TODO: if statusCode === 4xx do log
        }, payload);
      });
    }
  }]);

  return Backend;
}();

Backend.type = 'backend';

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2(Constructor, staticProps);
  return Constructor;
}

var arr$2 = [];
var each$2 = arr$2.forEach;
var slice$2 = arr$2.slice;

function defaults$2(obj) {
  each$2.call(slice$2.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

function createClassOnDemand(ClassOrObject) {
  if (!ClassOrObject) return null;
  if (typeof ClassOrObject === 'function') return new ClassOrObject();
  return ClassOrObject;
}

function getDefaults$2() {
  return {};
}

var Backend$1 = /*#__PURE__*/function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck$2(this, Backend);

    this.backends = [];
    this.type = 'backend';
    this.init(services, options);
  }

  _createClass$2(Backend, [{
    key: "init",
    value: function init(services) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var i18nextOptions = arguments.length > 2 ? arguments[2] : undefined;
      this.services = services;
      this.options = defaults$2(options, this.options || {}, getDefaults$2());
      this.options.backends && this.options.backends.forEach(function (b, i) {
        _this.backends[i] = _this.backends[i] || createClassOnDemand(b);

        _this.backends[i].init(services, _this.options.backendOptions[i], i18nextOptions);
      });
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      var _this2 = this;

      var bLen = this.backends.length;

      var loadPosition = function loadPosition(pos) {
        if (pos >= bLen) return callback(new Error('non of the backend loaded data;', true)); // failed pass retry flag

        var backend = _this2.backends[pos];

        if (backend.read) {
          backend.read(language, namespace, function (err, data) {
            if (!err && data && Object.keys(data).length > -1) {
              callback(null, data, pos);
              savePosition(pos - 1, data); // save one in front
            } else {
              loadPosition(pos + 1); // try load from next
            }
          });
        } else {
          loadPosition(pos + 1); // try load from next
        }
      };

      var savePosition = function savePosition(pos, data) {
        if (pos < 0) return;
        var backend = _this2.backends[pos];

        if (backend.save) {
          backend.save(language, namespace, data);
          savePosition(pos - 1, data);
        } else {
          savePosition(pos - 1, data);
        }
      };

      loadPosition(0);
    }
  }, {
    key: "create",
    value: function create(languages, namespace, key, fallbackValue) {
      this.backends.forEach(function (b) {
        if (b.create) b.create(languages, namespace, key, fallbackValue);
      });
    }
  }]);

  return Backend;
}();

Backend$1.type = 'backend';

/**
 * Make sure there's only one instance of pb-page active at any time.
 */

let _instance;
/**
 * Configuration element which should wrap around other `pb-` elements.
 * Among other things, this element determines the TEI Publisher
 * instance to which all elements will talk (property `endpoint`), and
 * initializes the i18n language module.
 * 
 * @slot - default unnamed slot for content
 * @fires pb-page-ready - fired when the endpoint and language settings have been determined
 * @fires pb-i18n-update - fired when the user selected a different display language
 * @fires pb-i18n-language - when received, changes the language to the one passed in the event and proceeds to pb-i18-update
 * @fires pb-toggle - when received, dispatch state changes to the elements on the page (see `pb-toggle-feature`, `pb-select-feature`)
 */


class PbPage extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * TEI Publisher internal: set to the root URL of the current app
       */
      appRoot: {
        type: String,
        attribute: 'app-root'
      },

      /**
       * TEI Publisher internal: set to the current page template.
       */
      template: {
        type: String
      },

      /**
       * The base URL of the TEI Publisher instance. All nested elements will
       * talk to this instance. By default it is set to the URL the
       * page was loaded from.
       * 
       * The endpoint can be overwritten by providing an HTTP request parameter
       * `_target` with an URL.
       */
      endpoint: {
        type: String,
        reflect: true
      },
      apiVersion: {
        type: String,
        attribute: 'api-version',
        reflect: true
      },

      /**
       * Optional URL pointing to a directory from which additional i18n 
       * language files will be loaded. The URL should contain placeholders
       * for the language (`lng`) and the namespace (`ns`), e.g.
       * 
       * `resources/i18n/{{ns}}_{{lng}}.json`
       * 
       * or
       * 
       * `resources/i18n/{{ns}}/{{lng}}.json`
       * 
       * The latter assumes custom language files in a subdirectory, the first
       * expects the namespace to be specified at the start of the file name.
       * 
       * The default namespace for custom language files is assumed to be `app`,
       * but you can define additional namespaces via `localeFallbackNS`.
       */
      locales: {
        type: String
      },

      /**
       * Optional list of whitespace separated namespaces which should be searched
       * for translations. By default, only the namespace `common` is queried.
       * If the `locales` property is specified, an additional namespace `app` is added.
       * You can add more namespace here, e.g. `custom`, if you want to provide
       * translations for custom apps or components.
       */
      localeFallbackNs: {
        type: String,
        attribute: 'locale-fallback-ns'
      },

      /**
       * Set a language for i18n (e.g. 'en' or 'de'). If not set, browser language
       * detection will be used.
       */
      language: {
        type: String
      },

      /**
       * If set, the element will wait for a language being set by i18n before
       * it sends a `pb-page-ready` event. Elements like `pb-view` will wait
       * for this event before displaying content.
       * 
       * Also, `pb-view` will pass the configured language to the server endpoint
       * where it will be available to ODD processing models in variable 
       * `$parameters?language` and can thus be used to change output depending on
       * the user interface language.
       * 
       * If you would like `pb-view` to refresh automatically whenever the language
       * setting changes, specify property `useLanguage` on the corresponding `pb-view`.
       */
      requireLanguage: {
        type: Boolean,
        attribute: 'require-language'
      },

      /**
       * Will be set while the component is loading and unset when
       * it is fully loaded. Use to avoid flash of unstyled content
       * via CSS: set `unresolved` on `pb-page` in the HTML and
       * add a CSS rule like:
       * 
       * ```css
       * pb-page[unresolved] {
       *     display: none;
       * }
       * ```
       */
      unresolved: {
        type: Boolean,
        reflect: true
      }
    });
  }

  constructor() {
    super();
    this.unresolved = true;
    this.endpoint = ".";
    this.apiVersion = undefined;
    this.requireLanguage = false;
    this._localeFallbacks = [];
    this._i18nInstance = null;

    if (_instance) {
      this.disabled = true;
    } else {
      _instance = this; // clear global page events which might have been set by other pb-page instances.
      // important while running the test suite.

      clearPageEvents();
    }
  }

  set localeFallbackNs(value) {
    value.split(/\s+/).forEach(v => this._localeFallbacks.push(v));
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this._i18nInstance = null;

    if (_instance === this) {
      // clear to allow future instances
      _instance = null;
    }
  }

  async connectedCallback() {
    super.connectedCallback();

    if (this.disabled) {
      return;
    }

    if (this.locales && this._localeFallbacks.indexOf('app') === -1) {
      this._localeFallbacks.push('app');
    }

    this._localeFallbacks.push('common');

    const target = this.getParameter('_target');

    if (target) {
      this.endpoint = target;
    }

    const apiVersion = this.getParameter('_api');

    if (apiVersion) {
      this.apiVersion = apiVersion;
    } // try to figure out what version of TEI Publisher the server is running


    if (!this.apiVersion) {
      // first check if it has a login endpoint, i.e. runs a version < 7
      // this is necessary to prevent a CORS failure
      const json = await fetch(`${this.endpoint}/login`).then(res => {
        if (res.ok) {
          return null;
        } // if not, access the actual /api/version endpoint to retrieve the API version


        return fetch(`${this.endpoint}/api/version`).then(res2 => res2.json());
      }).catch(() => null);

      if (json) {
        this.apiVersion = json.api;
        console.log(`<pb-page> Server reports API version ${this.apiVersion} with app ${json.app.name}/${json.app.version} running on ${json.engine.name}/${json.engine.version}`);
      } else {
        console.log('<pb-page> No API version reported by server, assuming 0.9.0');
        this.apiVersion = '0.9.0';
      }
    }

    if (!this.requireLanguage) {
      this.signalReady('pb-page-ready', {
        endpoint: this.endpoint,
        template: this.template,
        apiVersion: this.apiVersion
      });
    }
  }

  firstUpdated() {
    super.firstUpdated();

    if (this.disabled) {
      return;
    }

    const defaultLocales = resolveURL('../i18n/') + '{{ns}}/{{lng}}.json';
    console.log('<pb-page> Loading locales. common: %s; additional: %s; namespaces: %o', defaultLocales, this.locales, this._localeFallbacks);
    const backends = this.locales ? [Backend, Backend] : [Backend];
    const backendOptions = [{
      loadPath: defaultLocales,
      crossDomain: true
    }];

    if (this.locales) {
      backendOptions.unshift({
        loadPath: this.locales,
        crossDomain: true
      });
    }

    const options = {
      fallbackLng: 'en',
      defaultNS: 'common',
      ns: ['common'],
      debug: false,
      load: 'languageOnly',
      detection: {
        lookupQuerystring: 'lang'
      },
      backend: {
        backends,
        backendOptions
      }
    };

    if (this.language) {
      options.lng = this.language;
    }

    if (this._localeFallbacks.length > 0) {
      const fallbacks = this._localeFallbacks.slice();

      options.defaultNS = fallbacks[0];
      options.fallbackNS = fallbacks.slice(1);
      options.ns = fallbacks;
    }

    console.log('<pb-page> i18next options: %o', options);
    this._i18nInstance = i18next.createInstance();

    this._i18nInstance.use(Browser).use(Backend$1);

    this._i18nInstance.init(options).then(t => {
      initTranslation(t); // initialized and ready to go!

      this._updateI18n(t);

      this.signalReady('pb-i18n-update', {
        t,
        language: this._i18nInstance.language
      });

      if (this.requireLanguage) {
        this.signalReady('pb-page-ready', {
          endpoint: this.endpoint,
          apiVersion: this.apiVersion,
          template: this.template,
          language: this._i18nInstance.language
        });
      }
    });

    this.subscribeTo('pb-i18n-language', ev => {
      const {
        language
      } = ev.detail;

      this._i18nInstance.changeLanguage(language).then(t => {
        this._updateI18n(t);

        this.emitTo('pb-i18n-update', {
          t,
          language: this._i18nInstance.language
        }, []);
      }, []);
    });
    this.subscribeTo('pb-toggle', this._toggleFeatures.bind(this));
    this.unresolved = false;
    console.log('<pb-page> endpoint: %s; trigger window resize', this.endpoint);
    this.querySelectorAll('app-header').forEach(h => h._notifyLayoutChanged());
    typesetMath(this);
  }

  _updateI18n(t) {
    this.querySelectorAll('[data-i18n]').forEach(elem => {
      const targets = elem.getAttribute('data-i18n');
      const regex = /(?:\[([^\]]+)\])?([^;]+)/g;
      let m = regex.exec(targets);

      while (m) {
        const translated = t(m[2]);

        if (m[1]) {
          elem.setAttribute(m[1], translated);
        } else {
          elem.innerHTML = translated;
        }

        m = regex.exec(targets);
      }
    });
  }
  /**
   * Handle the `pb-toggle` event sent by `pb-select-feature` or `pb-toggle-feature`
   * and dispatch actions to the elements on the page.
   */


  _toggleFeatures(ev) {
    if (ev.detail.selectors) {
      ev.detail.selectors.forEach(sc => {
        this.querySelectorAll(sc.selector).forEach(node => {
          const command = sc.command || 'toggle';

          if (node.command) {
            node.command(command, sc.state);
          }

          if (sc.state) {
            node.classList.add(command);
          } else {
            node.classList.remove(command);
          }
        });
      });
    }
  }

  render() {
    return html$1`<slot></slot>`;
  }

  static get styles() {
    return css`
        :host {
            display: block;
        }
        `;
  }

}

customElements.define('pb-page', PbPage);

/**
 * Display a pagination control from which the user can select a page to view
 * from a multi-page collection of resources. To determine the number of pages,
 * `pb-paginate` listens for the `pb-results-received` event emitted by `pb-load`.
 * If the user clicks on one of the page indicators, a `pb-load` event is emitted,
 * which should cause the connected `pb-load` element to refresh.
 *
 * @fires pb-load - Fires when user selects new page to show
 * @fires pb-results-received - When received, recalculates page ranges to display according to the parameters received
 */

class PbPaginate extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * total number of pages
       */
      total: {
        type: Number,
        reflect: true
      },

      /**
       * start page
       */
      start: {
        type: Number,
        reflect: true
      },

      /**
       * amount of entries per page
       */
      perPage: {
        type: Number,
        attribute: 'per-page'
      },

      /**
       * i18n key to use for looking up the message showing number of items in list
       * or fixed label to display
       */
      foundLabel: {
        type: String,
        attribute: 'found-label'
      },

      /**
       * the current page
       */
      page: {
        type: Number
      },

      /**
       * the amount of pages
       */
      pageCount: {
        type: Number,
        attribute: 'page-count'
      },

      /**
       * todo
       */
      range: {
        type: Number
      },

      /**
       * todo:
       */
      pages: {
        type: Array
      }
    });
  }

  constructor() {
    super();
    this.total = 0;
    this.start = 1;
    this.perPage = 10;
    this.page = 1;
    this.pageCount = 10;
    this.range = 5;
    this.pages = [];
    this.foundLabel = 'browse.items';
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-results-received', this._refresh.bind(this));
  }

  render() {
    return html$1`
            <span @click="${this._handleFirst}"><iron-icon icon="first-page"></iron-icon></span>
            ${this.pages.map((item, index) => html$1`<span class="${item.class}" @click="${() => this._handleClick(item, index)}">${item.label}</span>`)}
            <span @click="${this._handleLast}"><iron-icon icon="last-page"></iron-icon></span>

            <span class="found">${translate(this.foundLabel, {
      count: this.total
    })}</span>
        `;
  }

  static get styles() {
    return css`
            :host([total="0"]) {
                display: none;
            }

            :host {
                display: flex;
                flex-direction: row;
                align-items: center;
            }

            span {
                padding: 4px 8px;
                cursor: pointer;
            }

            .active {
                background-color: var(--pb-color-primary);
                color: var(--pb-color-inverse);
                border-radius: 50%;
                min-width: 1em;
                width: 1em;
                line-height: 1em;
                padding: .4em;
                text-align: center;

                box-shadow:  0 3px 4px 0 rgba(0, 0, 0, 0.14),
                             0 1px 8px 0 rgba(0, 0, 0, 0.12),
                             0 3px 3px -2px rgba(0, 0, 0, 0.4);
            }

            .found {
                padding-left: 20px;
            }
        `;
  }

  _update(start, total) {
    if (!total || !start) {
      return;
    }

    this.pageCount = Math.ceil(total / this.perPage);
    this.page = Math.ceil(start / this.perPage);
    let lowerBound = Math.max(this.page - Math.ceil(this.range / 2) + 1, 1);
    let upperBound = Math.min(lowerBound + this.range - 1, this.pageCount);
    lowerBound = Math.max(upperBound - this.range + 1, 1);
    console.log("<pb-paginate> start: %d, total: %d, perPage: %d, pageCount: %s, page: %d, lower: %d, upper: %d", start, total, this.perPage, this.pageCount, this.page, lowerBound, upperBound);
    const pages = [];

    for (let i = lowerBound; i <= upperBound; i++) {
      pages.push({
        label: i,
        "class": i === this.page ? "active" : ""
      });
    }

    this.pages = pages;
  }

  _refresh(ev) {
    this.start = Number(ev.detail.start);
    this.total = ev.detail.count;

    this._update(this.start, this.total);
  }

  _handleClick(item, index) {
    this.start = (this.pages[index].label - 1) * this.perPage + 1;
    this.emitTo('pb-load', {
      "params": {
        "start": this.start,
        "per-page": this.perPage,
        "page": index
      }
    });
  }

  _handleFirst(ev) {
    this.start = 1;
    this.emitTo('pb-load', {
      "params": {
        "start": 1,
        "per-page": this.perPage,
        "page": 0
      }
    });
  }

  _handleLast(ev) {
    this.start = (this.pageCount - 1) * this.perPage + 1;
    this.emitTo('pb-load', {
      "params": {
        "start": this.start,
        "per-page": this.perPage,
        "page": this.pageCount - 1
      }
    });
  }

}
customElements.define('pb-paginate', PbPaginate);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * `iron-range-behavior` provides the behavior for something with a minimum to
 * maximum range.
 *
 * @demo demo/index.html
 * @polymerBehavior
 */

const IronRangeBehavior = {
  properties: {
    /**
     * The number that represents the current value.
     */
    value: {
      type: Number,
      value: 0,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The number that indicates the minimum value of the range.
     */
    min: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * The number that indicates the maximum value of the range.
     */
    max: {
      type: Number,
      value: 100,
      notify: true
    },

    /**
     * Specifies the value granularity of the range's value.
     */
    step: {
      type: Number,
      value: 1,
      notify: true
    },

    /**
     * Returns the ratio of the value.
     */
    ratio: {
      type: Number,
      value: 0,
      readOnly: true,
      notify: true
    }
  },
  observers: ['_update(value, min, max, step)'],
  _calcRatio: function (value) {
    return (this._clampValue(value) - this.min) / (this.max - this.min);
  },
  _clampValue: function (value) {
    return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
  },
  _calcStep: function (value) {
    // polymer/issues/2493
    value = parseFloat(value);

    if (!this.step) {
      return value;
    }

    var numSteps = Math.round((value - this.min) / this.step);

    if (this.step < 1) {
      /**
       * For small values of this.step, if we calculate the step using
       * `Math.round(value / step) * step` we may hit a precision point issue
       * eg. 0.1 * 0.2 =  0.020000000000000004
       * http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
       *
       * as a work around we can divide by the reciprocal of `step`
       */
      return numSteps / (1 / this.step) + this.min;
    } else {
      return numSteps * this.step + this.min;
    }
  },
  _validateValue: function () {
    var v = this._clampValue(this.value);

    this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
    return this.value !== v;
  },
  _update: function () {
    this._validateValue();

    this._setRatio(this._calcRatio(this.value) * 100);
  }
};

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
Material design: [Progress &
activity](https://www.google.com/design/spec/components/progress-activity.html)

The progress bars are for situations where the percentage completed can be
determined. They give users a quick sense of how much longer an operation
will take.

Example:

    <paper-progress value="10"></paper-progress>

There is also a secondary progress which is useful for displaying intermediate
progress, such as the buffer level during a streaming playback progress bar.

Example:

    <paper-progress value="10" secondary-progress="30"></paper-progress>

### Styling progress bar:

To change the active progress bar color:

    paper-progress {
       --paper-progress-active-color: #e91e63;
    }

To change the secondary progress bar color:

    paper-progress {
      --paper-progress-secondary-color: #f8bbd0;
    }

To change the progress bar background color:

    paper-progress {
      --paper-progress-container-color: #64ffda;
    }

Add the class `transiting` to a paper-progress to animate the progress bar when
the value changed. You can also customize the transition:

    paper-progress {
      --paper-progress-transition-duration: 0.08s;
      --paper-progress-transition-timing-function: ease;
      --paper-progress-transition-delay: 0s;
    }

To change the duration of the indeterminate cycle:

    paper-progress {
      --paper-progress-indeterminate-cycle-duration: 2s;
    }

The following mixins are available for styling:

Custom property | Description | Default
----------------|-------------|---------
`--paper-progress-container` | Mixin applied to container | `{}`
`--paper-progress-transition-duration` | Duration of the transition | `0.08s`
`--paper-progress-transition-timing-function` | The timing function for the transition | `ease`
`--paper-progress-transition-delay` | delay for the transition | `0s`
`--paper-progress-container-color` | Color of the container | `--google-grey-300`
`--paper-progress-active-color` | The color of the active bar | `--google-green-500`
`--paper-progress-secondary-color` | The color of the secondary bar | `--google-green-100`
`--paper-progress-disabled-active-color` | The color of the active bar if disabled | `--google-grey-500`
`--paper-progress-disabled-secondary-color` | The color of the secondary bar if disabled  | `--google-grey-300`
`--paper-progress-height` | The height of the progress bar | `4px`
`--paper-progress-indeterminate-cycle-duration` | Duration of an indeterminate cycle | `2s`

@group Paper Elements
@element paper-progress
@demo demo/index.html
*/

Polymer({
  _template: html`
    <style>
      :host {
        display: block;
        width: 200px;
        position: relative;
        overflow: hidden;
      }

      :host([hidden]), [hidden] {
        display: none !important;
      }

      #progressContainer {
        @apply --paper-progress-container;
        position: relative;
      }

      #progressContainer,
      /* the stripe for the indeterminate animation*/
      .indeterminate::after {
        height: var(--paper-progress-height, 4px);
      }

      #primaryProgress,
      #secondaryProgress,
      .indeterminate::after {
        @apply --layout-fit;
      }

      #progressContainer,
      .indeterminate::after {
        background: var(--paper-progress-container-color, var(--google-grey-300));
      }

      :host(.transiting) #primaryProgress,
      :host(.transiting) #secondaryProgress {
        -webkit-transition-property: -webkit-transform;
        transition-property: transform;

        /* Duration */
        -webkit-transition-duration: var(--paper-progress-transition-duration, 0.08s);
        transition-duration: var(--paper-progress-transition-duration, 0.08s);

        /* Timing function */
        -webkit-transition-timing-function: var(--paper-progress-transition-timing-function, ease);
        transition-timing-function: var(--paper-progress-transition-timing-function, ease);

        /* Delay */
        -webkit-transition-delay: var(--paper-progress-transition-delay, 0s);
        transition-delay: var(--paper-progress-transition-delay, 0s);
      }

      #primaryProgress,
      #secondaryProgress {
        @apply --layout-fit;
        -webkit-transform-origin: left center;
        transform-origin: left center;
        -webkit-transform: scaleX(0);
        transform: scaleX(0);
        will-change: transform;
      }

      #primaryProgress {
        background: var(--paper-progress-active-color, var(--google-green-500));
      }

      #secondaryProgress {
        background: var(--paper-progress-secondary-color, var(--google-green-100));
      }

      :host([disabled]) #primaryProgress {
        background: var(--paper-progress-disabled-active-color, var(--google-grey-500));
      }

      :host([disabled]) #secondaryProgress {
        background: var(--paper-progress-disabled-secondary-color, var(--google-grey-300));
      }

      :host(:not([disabled])) #primaryProgress.indeterminate {
        -webkit-transform-origin: right center;
        transform-origin: right center;
        -webkit-animation: indeterminate-bar var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
        animation: indeterminate-bar var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
      }

      :host(:not([disabled])) #primaryProgress.indeterminate::after {
        content: "";
        -webkit-transform-origin: center center;
        transform-origin: center center;

        -webkit-animation: indeterminate-splitter var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
        animation: indeterminate-splitter var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
      }

      @-webkit-keyframes indeterminate-bar {
        0% {
          -webkit-transform: scaleX(1) translateX(-100%);
        }
        50% {
          -webkit-transform: scaleX(1) translateX(0%);
        }
        75% {
          -webkit-transform: scaleX(1) translateX(0%);
          -webkit-animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          -webkit-transform: scaleX(0) translateX(0%);
        }
      }

      @-webkit-keyframes indeterminate-splitter {
        0% {
          -webkit-transform: scaleX(.75) translateX(-125%);
        }
        30% {
          -webkit-transform: scaleX(.75) translateX(-125%);
          -webkit-animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
        100% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
      }

      @keyframes indeterminate-bar {
        0% {
          transform: scaleX(1) translateX(-100%);
        }
        50% {
          transform: scaleX(1) translateX(0%);
        }
        75% {
          transform: scaleX(1) translateX(0%);
          animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          transform: scaleX(0) translateX(0%);
        }
      }

      @keyframes indeterminate-splitter {
        0% {
          transform: scaleX(.75) translateX(-125%);
        }
        30% {
          transform: scaleX(.75) translateX(-125%);
          animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          transform: scaleX(.75) translateX(125%);
        }
        100% {
          transform: scaleX(.75) translateX(125%);
        }
      }
    </style>

    <div id="progressContainer">
      <div id="secondaryProgress" hidden\$="[[_hideSecondaryProgress(secondaryRatio)]]"></div>
      <div id="primaryProgress"></div>
    </div>
`,
  is: 'paper-progress',
  behaviors: [IronRangeBehavior],
  properties: {
    /**
     * The number that represents the current secondary progress.
     */
    secondaryProgress: {
      type: Number,
      value: 0
    },

    /**
     * The secondary ratio
     */
    secondaryRatio: {
      type: Number,
      value: 0,
      readOnly: true
    },

    /**
     * Use an indeterminate progress indicator.
     */
    indeterminate: {
      type: Boolean,
      value: false,
      observer: '_toggleIndeterminate'
    },

    /**
     * True if the progress is disabled.
     */
    disabled: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      observer: '_disabledChanged'
    }
  },
  observers: ['_progressChanged(secondaryProgress, value, min, max, indeterminate)'],
  hostAttributes: {
    role: 'progressbar'
  },
  _toggleIndeterminate: function (indeterminate) {
    // If we use attribute/class binding, the animation sometimes doesn't
    // translate properly on Safari 7.1. So instead, we toggle the class here in
    // the update method.
    this.toggleClass('indeterminate', indeterminate, this.$.primaryProgress);
  },
  _transformProgress: function (progress, ratio) {
    var transform = 'scaleX(' + ratio / 100 + ')';
    progress.style.transform = progress.style.webkitTransform = transform;
  },
  _mainRatioChanged: function (ratio) {
    this._transformProgress(this.$.primaryProgress, ratio);
  },
  _progressChanged: function (secondaryProgress, value, min, max, indeterminate) {
    secondaryProgress = this._clampValue(secondaryProgress);
    value = this._clampValue(value);
    var secondaryRatio = this._calcRatio(secondaryProgress) * 100;
    var mainRatio = this._calcRatio(value) * 100;

    this._setSecondaryRatio(secondaryRatio);

    this._transformProgress(this.$.secondaryProgress, secondaryRatio);

    this._transformProgress(this.$.primaryProgress, mainRatio);

    this.secondaryProgress = secondaryProgress;

    if (indeterminate) {
      this.removeAttribute('aria-valuenow');
    } else {
      this.setAttribute('aria-valuenow', value);
    }

    this.setAttribute('aria-valuemin', min);
    this.setAttribute('aria-valuemax', max);
  },
  _disabledChanged: function (disabled) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
  },
  _hideSecondaryProgress: function (secondaryRatio) {
    return secondaryRatio === 0;
  }
});

/**
 * A progress bar which becomes active when signal `pb-start-update` is
 * being sent and is deactivated on `pb-end-update`.
 *
 * @fires pb-start-update - When received, activates the progress bar
 * @fires pb-end-update - When received, disables the progress bar
 
 */

class PbProgress extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      _disabled: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this._disabled = true;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-start-update', this._startUpdate.bind(this));
    this.subscribeTo('pb-end-update', this._endUpdate.bind(this));
  }

  render() {
    this.style.visibility = this._disabled ? 'hidden' : 'visible';
    return html$1`
            <paper-progress id="progress" indeterminate ?disabled="${this._disabled}"></paper-progress>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
                visibility: hidden;
            }

            paper-progress {
                width: 100%;
            }
        `;
  }

  _startUpdate() {
    this._disabled = false;
  }

  _endUpdate() {
    this._disabled = true;
  }

}
customElements.define('pb-progress', PbProgress);

/**
 * Implements a basic search form, which can be extended with additional inputs.
 *
 * @cssprop --pb-search-label-color - Color of the label and underline
 * @cssprop --pb-search-input-color - Text color for input field
 * @cssprop --pb-search-focus-color - Color for label and underline if input has focus
 * @cssprop --pb-search-suggestions-color - Color for the labels shown in the suggestions dropdown
 * @cssprop --pb-search-suggestions-background - Background for the suggestions dropdown
 * @slot - default unnamed slot
 * @slot - beforeInput renders content before the actual search input field
 * @slot - searchButton allows to plug a component that acts as submit button. Must support the 'click' event
 * @slot - resetButton allows to plug a component that acts as reset button. Must support the 'click' event
 * @fires pb-load - Fired to perform the actual search with parameters passed to the request
 * @fires pb-search-resubmit - When received, triggers the search again
 */

class PbSearch extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      action: {
        type: String
      },
      value: {
        type: String
      },
      placeHolder: {
        type: String,
        attribute: 'place-holder'
      },
      redirect: {
        type: Boolean
      },
      currentDoc: {
        type: String,
        attribute: 'current-doc'
      },
      submitOnLoad: {
        type: Boolean,
        attribute: 'submit-on-load'
      },
      subforms: {
        type: String
      },
      disableAutocomplete: {
        type: Boolean,
        attribute: 'disable-autocomplete'
      }
    });
  }

  constructor() {
    super();
    this.value = '';
    this.redirect = false;
    this.submitOnLoad = false;
    this.placeHolder = 'search.placeholder';
    this.disableAutocomplete = false;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-search-resubmit', this._doSearch.bind(this));
  }

  firstUpdated() {
    if (!this.disableAutocomplete) {
      const autocomplete = this.shadowRoot.getElementById('autocomplete');
      autocomplete.addEventListener('autocomplete-change', this._autocomplete.bind(this));
    }

    const ironform = this.shadowRoot.getElementById('ironform');
    ironform.addEventListener('iron-form-response', event => event.detail.completes.then(r => this.emitTo('pb-search', r.parseResponse())));
    PbSearch.waitOnce('pb-page-ready', options => {
      const loader = this.shadowRoot.getElementById('autocompleteLoader');

      if (this.minApiVersion('1.0.0')) {
        loader.url = `${options.endpoint}/api/search/autocomplete`;
      } else {
        loader.url = `${options.endpoint}/modules/autocomplete.xql`;
      }
    });

    if (this.submitOnLoad) {
      const params = this.getParameters();
      this.emitTo('pb-load', {
        "url": this.action,
        "params": params
      });
    }

    this.addEventListener('click', e => {
      const root = e.target.closest('[slot]');

      if (!root) {
        return;
      }

      if (root.slot === 'searchButton') {
        this._doSearch();
      }

      if (root.slot === 'resetButton') {
        this._reset();
      }
    });
  }

  render() {
    return html$1`
            <custom-style>
                <style>
                    :host {
                        --suggestions-item: {
                            color: var(--pb-search-suggestions-color, black);
                        };
                        --suggestions-wrapper: {
                            background: var(--pb-search-suggestions-background, white);
                        }
                    }
                </style>
            </custom-style>
            <iron-form id="ironform" allow-redirect="${this.redirect}">
                <form id="searchPageForm" method="get" action="${this.action}" accept="text/html">
                    <slot name="beforeInput"></slot>
                    <paper-input id="search" type="search" name="query" @keyup="${this._handleEnter}" label="${translate(this.placeHolder)}"
                        value="${this.value}" always-float-label>
                        <iron-icon icon="search" @click="${this._doSearch}" slot="prefix"></iron-icon>
                    </paper-input>
                    <paper-autocomplete-suggestions id="autocomplete" for="search" source="${this._suggestions}" remote-source></paper-autocomplete-suggestions>
                    <slot></slot>
                    
                    <slot name="searchButton"></slot>
                    <slot name="resetButton"></slot>
                    
                </form>
            </iron-form>
            <iron-ajax
                id="autocompleteLoader"
                verbose
                handle-as="json"
                method="get"
                with-credentials
                @response="${this._updateSuggestions}"></iron-ajax>
        `;
  }

  static get styles() {
    return css`
            :host {
                --paper-input-container-color: var(--pb-search-label-color, var(--paper-grey-500, #303030));
                --paper-input-container-input-color: var(--pb-search-input-color, var(--pb-color-primary, #000000));
                --paper-input-container-focus-color: var(--pb-search-focus-color, var(--paper-grey-500, #303030));
            }
            a{
                padding:1rem;
                color:var(--pb-reset-color);
            }
            .buttons{
                margin-top:1rem;
            }
        `;
  }

  _doSearch() {
    let json = this.shadowRoot.getElementById('ironform').serializeForm();
    json = this._paramsFromSubforms(json);

    if (this.redirect) {
      window.location.href = `${this.action}?${new URLSearchParams(json)}`;
    } else {
      this.setParameters(json);
      this.pushHistory('search'); // always start on first result after submitting new search

      json.start = 1;
      this.emitTo('pb-load', {
        "url": this.action,
        "params": json
      });
    }
  }

  _paramsFromSubforms(params) {
    if (this.subforms) {
      document.querySelectorAll(this.subforms).forEach(form => {
        if (form.serializeForm) {
          Object.assign(params, form.serializeForm());
        }
      });
    }

    return params;
  }

  _handleEnter(e) {
    if (e.keyCode === 13) {
      this._doSearch();
    }
  }

  _doSubmit() {
    this.shadowRoot.getElementById('ironform').submit();
  }

  _reset() {
    this.shadowRoot.getElementById('ironform').reset();
  }

  _autocomplete(ev) {
    const params = this.shadowRoot.getElementById('ironform').serializeForm();
    const loader = this.shadowRoot.getElementById('autocompleteLoader');
    loader.params = params;
    loader.generateRequest();
  }

  _updateSuggestions() {
    const autocomplete = this.shadowRoot.getElementById('autocomplete');
    const loader = this.shadowRoot.getElementById('autocompleteLoader');

    if (loader.lastResponse) {
      autocomplete.suggestions(loader.lastResponse);
    }
  }

}
customElements.define('pb-search', PbSearch);

/**
 * Enable or disable a particular display feature by setting a predefined or custom parameter.
 * Toggling display features can be done server-side or client-side.
 * 
 * It is important that `pb-toggle-feature` emits and subscribes to the same channel as the target `pb-view`.
 * 
 * # Server side toggling
 * 
 * You may set the following view parameters which correspond to the properties supported by `pb-view`:
 *
 * | Parameter | Description |
 * | ----------------|-------------|
 * | odd | the ODD to use |
 * | view | the view type: 'page', 'div' or 'single' |
 * | columnSeparator | CSS selector to find elements to use as column separator |
 * | xpath | XPath expression to select a portion of the text for display |
 *
 * For example, one may switch between page-by-page and by-division view using
 *
 * ```html
 * <pb-toggle-feature emit="transcription" name="view" on="page" off="div">Page View</pb-toggle-feature>
 * ```
 *
 * It is also possible to set custom parameters, which will be passed to the ODD as user-defined parameters.
 * This can be used e.g. to implement different views on the text, e.g. a 'diplomatic' and a 'normalized' mode. Both
 * views would be backed by the same ODD and processing model, while the passed in parameter
 * can be used to distinguish the modes.
 *
 * For example, the following snippet would result in a custom parameter called `mode` with
 * either a value of `dipl` or `norm`. Within processing model predicates it could be queried as
 * `$parameters?mode='norm'` to check if the normalized version should be output.
 *
 * ```html
 * <pb-toggle-feature name="mode" on="diplomatic" off="norm">Diplomatic View</pb-toggle-feature>
 * ```
 *
 * Besides setting a single parameter, you may also set multiple
 * properties on the target `pb-view` via the `properties-on` and `properties-off`
 * attributes (as an alternative to `on` and `off`). For example, in 'on' state, you may
 * want to use a different ODD and switch the view to 'page' at the same time:
 *
 * ```html
 * <pb-toggle-feature properties-on='{"odd": "myodd", "view": "page"}' properties-off='{"odd": "myodd-diplomatic", "view": "div"}'>
 *     Diplomatic View
 * </pb-toggle-feature>
 * ```
 *
 * # Client side toggling
 * 
 * The component can also be used to toggle features client-side, i.e. without requiring a server-roundtrip.
 * To enable this, the `selector` property should be set to a CSS3 selector targetting the HTML elements
 * to toggle. In `on` state, the selected elements will be assigned a class `.toggled`.
 * 
 * ```html
 * <pb-toggle-feature name="normalized" selector=".choice,.choice-alternate,br">Normalized View</pb-toggle-feature>
 * ```
 * 
 * Note that the name attribute is still required: it is used to determine if the feature is in on or off state by
 * looking at request parameters.
 * 
 * Instead of toggling the class, you can also completely disable the elements selected - provided that they are
 * publisher components implementing the corresponding `command` method of `pb-mixin`. To disable elements instead of
 * toggling, set the `action` property to *disable*.
 * 
 * ```html
 * <pb-toggle-feature name="plain" selector=".tei-foreign,pb-highlight,pb-popover" action="disable" default="off">Plain Reading View</pb-toggle-feature>
 * ```
 *
 * @fires pb-toggle - Fired when the feature is toggled, it's changing properties between values of its `on` and `off` state
 * @fires pb-update - When received, sets the features passed from the event
 */

class PbToggleFeature extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The name of the feature (required). This will correspond to the name of the custom parameter
       * passed to the ODD.
       */
      name: {
        type: String
      },

      /**
       * (optional) CSS selector: selects the elements to toggle client side (sets or unsets a 
       * CSS class `.toggled`). Setting this property will not trigger a reload as everything is
       * handled by javascript.
       */
      selector: {
        type: String
      },

      /**
       * In combination with a selector specifies the action to be taken, currently one of
       * `toggle` (default) or `disable`.
       */
      action: {
        type: String
      },

      /**
       * Value to set the parameter to when the feature is enabled.
       */
      on: {
        type: String
      },

      /**
       * Value to set the parameter to when the feature is disabled.
       */
      off: {
        type: String
      },

      /**
       * The default setting: either 'on' or 'off'
       */
      default: {
        type: String
      },

      /**
       * Additional properties to set on the pb-view if toggle is in 'on' state.
       * Possible properties are 'view', 'odd' and 'columnSeparator'.
       */
      propertiesOn: {
        type: Object,
        attribute: 'properties-on'
      },

      /**
       * Additional properties to set on the pb-view if toggle is in 'off' state.
       * Possible properties are 'view', 'odd' and 'columnSeparator'.
       */
      propertiesOff: {
        type: Object,
        attribute: 'properties-off'
      },
      checked: {
        type: Boolean
      },

      /**
       * If set to false (the default), `pb-toggle-feature` will pass its properties to the
       * connected view before this loads content for the first time. If true,
       * `pb-toggle-feature` will initialize its state depending on the setting of the view.
       * This only makes sense for the special properties 'view' and 'odd' though.
       */
      initFromView: {
        type: Boolean,
        attribute: 'init-from-view'
      }
    });
  }

  constructor() {
    super();
    this.default = 'on';
    this.action = 'toggle';
    this.propertiesOn = {};
    this.propertiesOff = {};
    this.initFromView = false;
  }

  render() {
    return html$1`
            <paper-checkbox id="checkbox" @change="${this._changed}" .checked="${this.checked}" .disabled="${this.disabled}"><slot></slot></paper-checkbox>
        `;
  }

  connectedCallback() {
    super.connectedCallback();

    if (this.initFromView) {
      const initHandler = this.subscribeTo('pb-update', ev => {
        if (this.name === 'infiniteScroll') {
          this.checked = ev.detail.infiniteScroll === this.propertiesOn[this.name];
        } else if (this.name === 'view' || this.name === 'odd' || this.name === 'xpath') {
          this.checked = ev.detail.data[this.name] === this.propertiesOn[this.name];
        }

        initHandler.forEach(handler => document.removeEventListener('pb-update', handler));
      });
      this.waitForChannel(() => {
        const params = {
          selectors: [{
            selector: this.selector,
            command: this.action,
            state: this.checked
          }],
          properties: {},
          action: 'init'
        };
        this.emitTo('pb-toggle', params);
        this.signalReady();
      });
    } else {
      const param = this.getParameter(this.name);

      if (typeof param !== 'undefined') {
        this.checked = param === 'on';
      } else {
        this.checked = this.default === 'on';
      }

      this.waitForChannel(() => {
        const params = {
          selectors: [{
            selector: this.selector,
            command: this.action,
            state: this.checked
          }],
          properties: this.checked ? this.propertiesOn : this.propertiesOff,
          action: 'init'
        };
        this.emitTo('pb-toggle', params);
        this.signalReady();
      });
    }
  }

  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);

    switch (name) {
      case 'on':
        this.propertiesOn[this.name] = newVal;
        break;

      case 'off':
        this.propertiesOff[this.name] = newVal;
        break;
    }
  }

  _changed() {
    this.checked = this.shadowRoot.getElementById('checkbox').checked;

    if (this.name) {
      this.setParameter(this.name, this.checked ? 'on' : 'off');
      this.pushHistory('toggle feature ' + this.name);
    }

    const params = {
      selectors: [{
        selector: this.selector,
        command: this.action,
        state: this.checked
      }],
      properties: this.checked ? this.propertiesOn : this.propertiesOff,
      action: 'refresh'
    };
    this.emitTo('pb-toggle', params);
  }

}
customElements.define('pb-toggle-feature', PbToggleFeature);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
Use `<paper-item-body>` in a `<paper-item>` or `<paper-icon-item>` to make two-
or three- line items. It is a flex item that is a vertical flexbox.

    <paper-item>
      <paper-item-body two-line>
        <div>Show your status</div>
        <div secondary>Your status is visible to everyone</div>
      </paper-item-body>
    </paper-item>

The child elements with the `secondary` attribute is given secondary text
styling.

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-item-body-two-line-min-height` | Minimum height of a two-line item | `72px`
`--paper-item-body-three-line-min-height` | Minimum height of a three-line item | `88px`
`--paper-item-body-secondary-color` | Foreground color for the `secondary` area | `--secondary-text-color`
`--paper-item-body-secondary` | Mixin applied to the `secondary` area | `{}`

*/

Polymer({
  _template: html`
    <style>
      :host {
        overflow: hidden; /* needed for text-overflow: ellipsis to work on ff */
        @apply --layout-vertical;
        @apply --layout-center-justified;
        @apply --layout-flex;
      }

      :host([two-line]) {
        min-height: var(--paper-item-body-two-line-min-height, 72px);
      }

      :host([three-line]) {
        min-height: var(--paper-item-body-three-line-min-height, 88px);
      }

      :host > ::slotted(*) {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      :host > ::slotted([secondary]) {
        @apply --paper-font-body1;

        color: var(--paper-item-body-secondary-color, var(--secondary-text-color));

        @apply --paper-item-body-secondary;
      }
    </style>

    <slot></slot>
`,
  is: 'paper-item-body'
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<paper-icon-item>` is a convenience element to make an item with icon. It is an
interactive list item with a fixed-width icon area, according to Material
Design. This is useful if the icons are of varying widths, but you want the item
bodies to line up. Use this like a `<paper-item>`. The child node with the slot
name `item-icon` is placed in the icon area.

    <paper-icon-item>
      <iron-icon icon="favorite" slot="item-icon"></iron-icon>
      Favorite
    </paper-icon-item>
    <paper-icon-item>
      <div class="avatar" slot="item-icon"></div>
      Avatar
    </paper-icon-item>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-item-icon-width` | Width of the icon area | `56px`
`--paper-item-icon` | Mixin applied to the icon area | `{}`
`--paper-icon-item` | Mixin applied to the item | `{}`
`--paper-item-selected-weight` | The font weight of a selected item | `bold`
`--paper-item-selected` | Mixin applied to selected paper-items | `{}`
`--paper-item-disabled-color` | The color for disabled paper-items | `--disabled-text-color`
`--paper-item-disabled` | Mixin applied to disabled paper-items | `{}`
`--paper-item-focused` | Mixin applied to focused paper-items | `{}`
`--paper-item-focused-before` | Mixin applied to :before focused paper-items | `{}`

*/

Polymer({
  _template: html`
    <style include="paper-item-shared-styles"></style>
    <style>
      :host {
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --paper-font-subhead;

        @apply --paper-item;
        @apply --paper-icon-item;
      }

      .content-icon {
        @apply --layout-horizontal;
        @apply --layout-center;

        width: var(--paper-item-icon-width, 56px);
        @apply --paper-item-icon;
      }
    </style>

    <div id="contentIcon" class="content-icon">
      <slot name="item-icon"></slot>
    </div>
    <slot></slot>
`,
  is: 'paper-icon-item',
  behaviors: [PaperItemBehavior]
});

/**
 * Similar to `pb-toggle-feature` but allows you to choose from a list of defined states instead of a simple
 * on/off toggle. Like `pb-toggle-feature` it can change state server-side as well as client-side. 
 * 
 * The list of states is passed as a JSON array to property `items`:
 * 
 * # Server-side
 * 
 * Properties to be passed to the server are specified as follows:
 * 
 * ```javascript
 * [
 *      {"name": "Diplomatic View", "properties": {"mode": "diplomatic", "view": "page"}},
 *      {"name": "Normalized View", "properties": {"mode": "norm", "view": "single"}}
 * ]
 * ```
 * 
 * # Client-side
 * 
 * ```javascript
 * [
 *      {"name": "Diplomatic View", "selectors": [{"selector": ".choice,.choice-alternate,br", "state": false},{"selector": ".tei-foreign,pb-highlight,pb-popover", "command": "disable"}]},
 *      {"name": "Normalized View", "selectors": [{"selector": ".choice,.choice-alternate,br", "state": true},{"selector": ".tei-foreign,pb-highlight,pb-popover", "command": "disable"}]},
 *      {"name": "Plain Reading View", "selectors": [{"selector": ".choice,.choice-alternate,br", "state": true}, {"selector": ".tei-foreign,pb-highlight,pb-popover", "command": "disable", "state": true}]}
 * ]
 * ```
 * 
 * Each item in the `selectors` property above defines either a state or a command. *state* will simply add
 * a css class `.toggled` to the target element when true. If *command* is set to 'disable', it will entirely disable
 * the functionality of selected elements - provided that they are
 * publisher components implementing the corresponding `command` method of `pb-mixin`.
 * 
 * @fires pb-toggle - Fired when a feature is selected from the dropdown and sends the selected properties
 */

class PbSelectFeature extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
      * The name of the feature (required). This will correspond to the name of the custom parameter
      * passed to the ODD.
      */
      name: {
        type: String
      },

      /**
       * The label to display on top of the drop down
       */
      label: {
        type: String
      },
      selected: {
        type: Number
      },
      items: {
        type: Array
      }
    });
  }

  constructor() {
    super();
    this.initializing = true;
    this.items = [];
    this.label = 'document.selectFeature';
  }

  connectedCallback() {
    super.connectedCallback();
    const param = this.getParameter(this.name);

    if (typeof param !== 'undefined') {
      this.selected = parseInt(param, 10);
    } else if (this.items.length > 0) {
      this.selected = 0;
    }

    this.waitForChannel(() => {
      if (this.selected && this.selected < this.items.length) {
        this._emit('init', this.selected);
      }

      this.initializing = false;
      this.signalReady();
    });
  }

  firstUpdated() {
    super.firstUpdated();
    this.shadowRoot.getElementById('menu').addEventListener('selected-item-changed', this._selectionChanged.bind(this));
  } // updated(changedProperties) {
  //     super.updated();
  //     if (changedProperties.has('items')) {
  //         const current = this.shadowRoot.getElementById('list').selectedItem;
  //         if (!current && this.items.length > 0) {
  //             this.selected = 0;
  //             this._emit('refresh');
  //         }
  //         console.log('selected: %o', this.selected);
  //     }
  // }


  _selectionChanged() {
    const current = this.shadowRoot.getElementById('list').selected;
    this.setParameter(this.name, current);
    this.pushHistory('toggle feature ' + this.name);
    console.log('<pb-select-feature> Setting features: %o', this.items[current]);

    this._emit('refresh', current);
  }

  _emit(action, index) {
    const item = this.items[index];
    const params = {
      properties: item.properties || {},
      selectors: item.selectors,
      action
    };
    this.emitTo('pb-toggle', params);
  }

  render() {
    return html$1`
            <paper-dropdown-menu id="menu" label="${translate(this.label)}" .disabled="${this.disabled}">
                <paper-listbox id="list" slot="dropdown-content" selected="${this.selected}">
                    ${this.items.map(item => html$1`<paper-item>${item.name}</paper-item>`)}
                </paper-listbox>
            </paper-dropdown-menu>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            #menu {
                width: inherit;
                min-width: inherit;
                max-width: inherit;
            }
        `;
  }

}
customElements.define('pb-select-feature', PbSelectFeature);

/*
 * anime.js v3.2.1
 * (c) 2020 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
// Defaults
var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};
var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};
var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d']; // Caching

var cache = {
  CSS: {},
  springs: {}
}; // Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) {
    return Array.isArray(a);
  },
  obj: function (a) {
    return stringContains(Object.prototype.toString.call(a), 'Object');
  },
  pth: function (a) {
    return is.obj(a) && a.hasOwnProperty('totalLength');
  },
  svg: function (a) {
    return a instanceof SVGElement;
  },
  inp: function (a) {
    return a instanceof HTMLInputElement;
  },
  dom: function (a) {
    return a.nodeType || is.svg(a);
  },
  str: function (a) {
    return typeof a === 'string';
  },
  fnc: function (a) {
    return typeof a === 'function';
  },
  und: function (a) {
    return typeof a === 'undefined';
  },
  nil: function (a) {
    return is.und(a) || a === null;
  },
  hex: function (a) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
  },
  rgb: function (a) {
    return /^rgb/.test(a);
  },
  hsl: function (a) {
    return /^hsl/.test(a);
  },
  col: function (a) {
    return is.hex(a) || is.rgb(a) || is.hsl(a);
  },
  key: function (a) {
    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
  }
}; // Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) {
    return parseFloat(p);
  }) : [];
} // Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


function spring(string, duration) {
  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? duration * t / 1000 : t;

    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }

    if (t === 0 || t === 1) {
      return t;
    }

    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];

    if (cached) {
      return cached;
    }

    var frame = 1 / 6;
    var elapsed = 0;
    var rest = 0;

    while (true) {
      elapsed += frame;

      if (solver(elapsed) === 1) {
        rest++;

        if (rest >= 16) {
          break;
        }
      } else {
        rest = 0;
      }
    }

    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;
} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


function steps(steps) {
  if (steps === void 0) steps = 10;
  return function (t) {
    return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);
  };
} // BezierEasing https://github.com/gre/bezier-easing


var bezier = function () {
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      return;
    }

    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  return bezier;
}();

var penner = function () {
  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
  var eases = {
    linear: function () {
      return function (t) {
        return t;
      };
    }
  };
  var functionEasings = {
    Sine: function () {
      return function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function () {
      return function (t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function () {
      return function (t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function () {
      return function (t) {
        var pow2,
            b = 4;

        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function (amplitude, period) {
      if (amplitude === void 0) amplitude = 1;
      if (period === void 0) period = .5;
      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
      };
    }
  };
  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () {
      return function (t) {
        return Math.pow(t, i + 2);
      };
    };
  });
  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;

    eases['easeOut' + name] = function (a, b) {
      return function (t) {
        return 1 - easeIn(a, b)(1 - t);
      };
    };

    eases['easeInOut' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
      };
    };

    eases['easeOutIn' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;
      };
    };
  });
  return eases;
}();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) {
    return easing;
  }

  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);

  switch (name) {
    case 'spring':
      return spring(easing, duration);

    case 'cubicBezier':
      return applyArguments(bezier, args);

    case 'steps':
      return applyArguments(steps, args);

    default:
      return applyArguments(ease, args);
  }
} // Strings


function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch (e) {
    return;
  }
} // Arrays


function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];

  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];

      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }

  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(is.arr(b) ? flattenArray(b) : b);
  }, []);
}

function toArray(o) {
  if (is.arr(o)) {
    return o;
  }

  if (is.str(o)) {
    o = selectString(o) || o;
  }

  if (o instanceof NodeList || o instanceof HTMLCollection) {
    return [].slice.call(o);
  }

  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) {
    return a === val;
  });
} // Objects


function cloneObject(o) {
  var clone = {};

  for (var p in o) {
    clone[p] = o[p];
  }

  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o1) {
    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
  }

  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o2) {
    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
  }

  return o;
} // Colors


function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return "rgba(" + r + "," + g + "," + b + ",1)";
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  var r, g, b;

  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}

function colorToRgb(val) {
  if (is.rgb(val)) {
    return rgbToRgba(val);
  }

  if (is.hex(val)) {
    return hexToRgba(val);
  }

  if (is.hsl(val)) {
    return hslToRgba(val);
  }
} // Units


function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

  if (split) {
    return split[1];
  }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') {
    return 'px';
  }

  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
    return 'deg';
  }
} // Values


function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) {
    return val;
  }

  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);

  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
    return value;
  }

  var cached = cache.CSS[value + unit];

  if (!is.und(cached)) {
    return cached;
  }

  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {
    return 'attribute';
  }

  if (is.dom(el) && arrayContains(validTransforms, prop)) {
    return 'transform';
  }

  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
    return 'css';
  }

  if (el[prop] != null) {
    return 'object';
  }
}

function getElementTransforms(el) {
  if (!is.dom(el)) {
    return;
  }

  var str = el.style.transform || '';
  var reg = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m;

  while (m = reg.exec(str)) {
    transforms.set(m[1], m[2]);
  }

  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;

  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }

  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform':
      return getTransformValue(target, propName, animatable, unit);

    case 'css':
      return getCSSValue(target, propName, unit);

    case 'attribute':
      return getAttribute(target, propName);

    default:
      return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);

  if (!operator) {
    return to;
  }

  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));

  switch (operator[0][0]) {
    case '+':
      return x + y + u;

    case '-':
      return x - y + u;

    case '*':
      return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) {
    return colorToRgb(val);
  }

  if (/\s/g.test(val)) {
    return val;
  }

  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

  if (unit) {
    return unitLess + unit;
  }

  return unitLess;
} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: getAttribute(el, 'x1'),
    y: getAttribute(el, 'y1')
  }, {
    x: getAttribute(el, 'x2'),
    y: getAttribute(el, 'y2')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);

    if (i > 0) {
      totalLength += getDistance(previousPos, currentPos);
    }

    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // Path animation


function getTotalLength(el) {
  if (el.getTotalLength) {
    return el.getTotalLength();
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
} // Motion path


function getParentSvgEl(el) {
  var parentEl = el.parentNode;

  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) {
      break;
    }

    parentEl = parentEl.parentNode;
  }

  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width,
    h: height,
    vW: viewBox[2],
    vH: viewBox[3]
  };
}

function getPath$1(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function (property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    };
  };
}

function getPathProgress(path, progress, isPathTargetInsideSVG) {
  function point(offset) {
    if (offset === void 0) offset = 0;
    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }

  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
  var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;

  switch (path.property) {
    case 'x':
      return (p.x - svg.x) * scaleX;

    case 'y':
      return (p.y - svg.y) * scaleY;

    case 'angle':
      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
} // Decompose value


function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: is.str(val) || unit ? value.split(rgx) : []
  };
} // Animatables


function parseTargets(targets) {
  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
  return filterArray(targetsArray, function (item, pos, self) {
    return self.indexOf(item) === pos;
  });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {
      target: t,
      id: i,
      total: parsed.length,
      transforms: {
        list: getElementTransforms(t)
      }
    };
  });
} // Properties


function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

  if (/^spring/.test(settings.easing)) {
    settings.duration = spring(settings.easing);
  }

  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = l === 2 && !is.obj(prop[0]);

    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) {
        settings.duration = tweenSettings.duration / l;
      }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {
        value: prop
      };
    }
  }

  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = is.obj(v) && !is.pth(v) ? v : {
      value: v
    }; // Default delay value should only be applied to the first tween

    if (is.und(obj.delay)) {
      obj.delay = !i ? tweenSettings.delay : 0;
    } // Default endDelay value should only be applied to the last tween


    if (is.und(obj.endDelay)) {
      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
    }

    return obj;
  }).map(function (k) {
    return mergeObjects(k, settings);
  });
}

function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
    return Object.keys(key);
  })), function (p) {
    return is.key(p);
  }).reduce(function (a, b) {
    if (a.indexOf(b) < 0) {
      a.push(b);
    }

    return a;
  }, []);
  var properties = {};

  var loop = function (i) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};

      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) {
            newKey.value = key[p];
          }
        } else {
          newKey[p] = key[p];
        }
      }

      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop(i);

  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;

  if (keyframes) {
    params = mergeObjects(flattenKeyframes(keyframes), params);
  }

  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }

  return properties;
} // Tweens


function normalizeTweenValues(tween, animatable) {
  var t = {};

  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);

    if (is.arr(value)) {
      value = value.map(function (v) {
        return getFunctionValue(v, animatable);
      });

      if (value.length === 1) {
        value = value[0];
      }
    }

    t[p] = value;
  }

  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;

    if (is.und(to)) {
      to = previousValue;
    }

    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
    tween.isColor = is.col(tween.from.original);

    if (tween.isColor) {
      tween.round = 1;
    }

    previousTween = tween;
    return tween;
  });
} // Tween progress


var setProgressValue = {
  css: function (t, p, v) {
    return t.style[p] = v;
  },
  attribute: function (t, p, v) {
    return t.setAttribute(p, v);
  },
  object: function (t, p, v) {
    return t[p] = v;
  },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);

    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) {
        str += prop + "(" + value + ") ";
      });
      t.style.transform = str;
    }
  }
}; // Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
} // Animations


function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);

  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    };
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) {
    return !is.und(a);
  });
} // Create Instance


function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;

  var getTlOffset = function (anim) {
    return anim.timelineOffset ? anim.timelineOffset : 0;
  };

  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration;
  })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.delay;
  })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration - anim.endDelay;
  })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
} // Core


var activeInstances = [];

var engine = function () {
  var raf;

  function play() {
    if (!raf && (!isDocumentHidden() || !anime$1.suspendWhenDocumentHidden) && activeInstances.length > 0) {
      raf = requestAnimationFrame(step);
    }
  }

  function step(t) {
    // memo on algorithm issue:
    // dangerous iteration over mutable `activeInstances`
    // (that collection may be updated from within callbacks of `tick`-ed animation instances)
    var activeInstancesLength = activeInstances.length;
    var i = 0;

    while (i < activeInstancesLength) {
      var activeInstance = activeInstances[i];

      if (!activeInstance.paused) {
        activeInstance.tick(t);
        i++;
      } else {
        activeInstances.splice(i, 1);
        activeInstancesLength--;
      }
    }

    raf = i > 0 ? requestAnimationFrame(step) : undefined;
  }

  function handleVisibilityChange() {
    if (!anime$1.suspendWhenDocumentHidden) {
      return;
    }

    if (isDocumentHidden()) {
      // suspend ticks
      raf = cancelAnimationFrame(raf);
    } else {
      // is back to active tab
      // first adjust animations to consider the time that ticks were suspended
      activeInstances.forEach(function (instance) {
        return instance._onDocumentVisibility();
      });
      engine();
    }
  }

  if (typeof document !== 'undefined') {
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }

  return play;
}();

function isDocumentHidden() {
  return !!document && document.hidden;
} // Public Instance


function anime$1(params) {
  if (params === void 0) params = {};
  var startTime = 0,
      lastTime = 0,
      now = 0;
  var children,
      childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) {
      return resolve = _resolve;
    });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;

    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }

    instance.reversed = !instance.reversed;
    children.forEach(function (child) {
      return child.reversed = instance.reversed;
    });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime$1.speed);
  }

  function seekChild(time, child) {
    if (child) {
      child.seek(time - child.timelineOffset);
    }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) {
        seekChild(time, children[i]);
      }
    } else {
      for (var i$1 = childrenLength; i$1--;) {
        seekChild(time, children[i$1]);
      }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;

    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

      if (tweenLength) {
        tween = filterArray(tweens, function (t) {
          return insTime < t.end;
        })[0] || tween;
      }

      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = void 0;

      for (var n = 0; n < toNumbersLength; n++) {
        var value = void 0;
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;

        if (!tween.isPath) {
          value = fromNumber + eased * (toNumber - fromNumber);
        } else {
          value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
        }

        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }

        numbers.push(value);
      } // Manual Array.reduce for better performances


      var stringsLength = strings.length;

      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];

        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];

          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }

      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) {
      instance[cb](instance);
    }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;

    if (children) {
      syncInstanceChildren(insTime);
    }

    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }

    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }

    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }

    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
      setAnimationsProgress(insDuration);
    }

    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }

      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }

    instance.currentTime = minMax(insTime, 0, insDuration);

    if (instance.began) {
      setCallback('update');
    }

    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();

      if (!instance.remaining) {
        instance.paused = true;

        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');

          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;

        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function () {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;

    for (var i = childrenLength; i--;) {
      instance.children[i].reset();
    }

    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
      instance.remaining++;
    }

    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  }; // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)


  instance._onDocumentVisibility = resetTime; // Set Value helper

  instance.set = function (targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function (t) {
    now = t;

    if (!startTime) {
      startTime = now;
    }

    setInstanceProgress((now + (lastTime - startTime)) * anime$1.speed);
  };

  instance.seek = function (time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function () {
    instance.paused = true;
    resetTime();
  };

  instance.play = function () {
    if (!instance.paused) {
      return;
    }

    if (instance.completed) {
      instance.reset();
    }

    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    engine();
  };

  instance.reverse = function () {
    toggleInstanceDirection();
    instance.completed = instance.reversed ? false : true;
    resetTime();
  };

  instance.restart = function () {
    instance.reset();
    instance.play();
  };

  instance.remove = function (targets) {
    var targetsArray = parseTargets(targets);
    removeTargetsFromInstance(targetsArray, instance);
  };

  instance.reset();

  if (instance.autoplay) {
    instance.play();
  }

  return instance;
} // Remove targets from animation


function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargetsFromInstance(targetsArray, instance) {
  var animations = instance.animations;
  var children = instance.children;
  removeTargetsFromAnimations(targetsArray, animations);

  for (var c = children.length; c--;) {
    var child = children[c];
    var childAnimations = child.animations;
    removeTargetsFromAnimations(targetsArray, childAnimations);

    if (!childAnimations.length && !child.children.length) {
      children.splice(c, 1);
    }
  }

  if (!animations.length && !children.length) {
    instance.pause();
  }
}

function removeTargetsFromActiveInstances(targets) {
  var targetsArray = parseTargets(targets);

  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    removeTargetsFromInstance(targetsArray, instance);
  }
} // Stagger helpers


function stagger(val, params) {
  if (params === void 0) params = {};
  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) {
      fromIndex = 0;
    }

    if (fromCenter) {
      fromIndex = (t - 1) / 2;
    }

    if (fromLast) {
      fromIndex = t - 1;
    }

    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          var toX = index % grid[0];
          var toY = Math.floor(index / grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (axis === 'x') {
            value = -distanceX;
          }

          if (axis === 'y') {
            value = -distanceY;
          }

          values.push(value);
        }

        maxValue = Math.max.apply(Math, values);
      }

      if (easing) {
        values = values.map(function (val) {
          return easing(val / maxValue) * maxValue;
        });
      }

      if (direction === 'reverse') {
        values = values.map(function (val) {
          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
        });
      }
    }

    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
  };
} // Timeline


function timeline(params) {
  if (params === void 0) params = {};
  var tl = anime$1(params);
  tl.duration = 0;

  tl.add = function (instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;

    if (tlIndex > -1) {
      activeInstances.splice(tlIndex, 1);
    }

    function passThrough(ins) {
      ins.passThrough = true;
    }

    for (var i = 0; i < children.length; i++) {
      passThrough(children[i]);
    }

    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime$1(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();

    if (tl.autoplay) {
      tl.play();
    }

    return tl;
  };

  return tl;
}

anime$1.version = '3.2.1';
anime$1.speed = 1; // TODO:#review: naming, documentation

anime$1.suspendWhenDocumentHidden = true;
anime$1.running = activeInstances;
anime$1.remove = removeTargetsFromActiveInstances;
anime$1.get = getOriginalTargetValue;
anime$1.set = setTargetsValue;
anime$1.convertPx = convertPxToUnit;
anime$1.path = getPath$1;
anime$1.setDashoffset = setDashoffset;
anime$1.stagger = stagger;
anime$1.timeline = timeline;
anime$1.easing = parseEasings;
anime$1.penner = penner;

anime$1.random = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

/**
 * This is the main component for viewing text which has been transformed via an ODD.
 * The document to be viewed is determined by the `pb-document` element the property
 * `src` points to. If not overwritten, `pb-view` will use the settings defined by
 * the connected document, like view type, ODD etc.
 * 
 * `pb-view` can display an entire document or just a fragment of it
 * as defined by the properties `xpath`, `xmlId` or `nodeId`. The most common use case
 * is to set `xpath` to point to a specific part of a document.
 * 
 * Navigating to the next or previous fragment would usually be triggered by a separate
 * `pb-navigation` element, which sends a `pb-navigate` event to the `pb-view`. However,
 * `pb-view` also implements automatic loading of next/previous fragments if the user
 * scrolls the page beyond the current viewport boudaries. To enable this, set property
 * `infinite-scroll`.
 *
 * You may also define optional parameters to be passed to the ODD in nested `pb-param`
 * tags. These parameters can be accessed within the ODD via the `$parameters` map. For
 * example, the following snippet is being used to output breadcrumbs above the main text
 * in the documentation view:
 *
 * ```xml
 * <section class="breadcrumbs">
 *      <pb-view id="title-view1" src="document1" subscribe="transcription">
 *          <pb-param name="mode" value="breadcrumbs"/>
 *      </pb-view>
 * </section>
 * ```
 *
 * @cssprop [--pb-view-column-gap=10px] - The gap between columns in two-column mode
 * @cssprop --pb-view-loader-font - Font used in the message shown during loading in infinite scroll mode
 * @cssprop [--pb-view-loader-color=black] - Text color in the message shown during loading in infinite scroll mode
 * @cssprop [--pb-view-loader-background-padding=10px 20px] - Background padding for the  message shown during loading in infinite scroll mode
 * @cssprop [--pb-view-loader-background-image=linear-gradient(to bottom, #f6a62440, #f6a524)] - Background image the message shown during loading in infinite scroll mode
 * @cssprop --pb-footnote-color - Text color of footnote marker
 * @cssprop --pb-footnote-padding - Padding around a footnote marker
 * @cssprop --pb-footnote-font-size - Font size for the footnote marker
 * @cssprop --pb-footnote-font-family - Font family for the footnote marker
 * @cssprop --pb-view-scroll-margin-top - Applied to any element with an id
 * @csspart content - The root div around the displayed content
 * @csspart footnotes - div containing the footnotes
  
 * @fires pb-start-update - Fired before the element updates its content
 * @fires pb-update - Fired when the component received content from the server
 * @fires pb-end-update - Fired after the element has finished updating its content
 * @fires pb-navigate - When received, navigate forward or backward in the document
 * @fires pb-zoom - When received, zoom in or out by changing font size of the content
 * @fires pb-refresh - When received, refresh the content based on the parameters passed in the event
 * @fires pb-toggle - When received, toggle content properties
 */

class PbView extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
      * The id of a `pb-document` element this view should display.
      * Settings like `odd` or `view` will be taken from the `pb-document`
      * unless overwritten by properties in this component.
      *
      * This property is **required** and **must** point to an existing `pb-document` with
      * the given id.
      *
      * Setting the property after initialization will clear the properties xmlId, nodeId and odd.
      */
      src: {
        type: String
      },

      /**
      * The ODD to use for rendering the document. Overwrites an ODD defined on
      * `pb-document`. The odd should be specified by its name without path
      * or the `.odd` suffix.
      */
      odd: {
        type: String,
        reflect: true
      },

      /**
      * The view type to use for paginating the document. Either `page`, `div` or `single`.
      * Overwrites the same property specified on `pb-document`. Values have the following meaning:
      *
      * Value | Displayed content
      * ------|------------------
      * `page` | content is displayed page by page as determined by tei:pb
      * `div` | content is displayed by divisions
      * `single` | do not paginate but display entire content at once
      */
      view: {
        type: String,
        reflect: true
      },

      /**
      * An eXist nodeId. If specified, selects the root of the fragment of the document
      * which should be displayed. Normally this property is set automatically by pagination.
      */
      nodeId: {
        type: String,
        reflect: true,
        attribute: 'node-id'
      },

      /**
      * An xml:id to be displayed. If specified, this determines the root of the fragment to be
      * displayed. Use to directly navigate to a specific section.
      */
      xmlId: {
        type: Array,
        reflect: true,
        attribute: 'xml-id'
      },

      /**
      * An optional XPath expression: the root of the fragment to be processed is determined
      * by evaluating the given XPath expression. The XPath expression should be absolute.
      * The namespace of the document is declared as default namespace, so no prefixes should
      * be used.
      *
      * If the `map` property is used, it may change scope for the displayed fragment.
      */
      xpath: {
        type: String,
        reflect: true
      },

      /**
      * If defined denotes the local name of an XQuery function in `modules/map.xql`, which will be called
      * with the current root node and should return the node of a mapped fragment. This is helpful if one
      * wants, for example, to show a translation fragment aligned with the part of the transcription currently
      * shown. In this case, the properties of the `pb-view` would still point to the transcription, but the function
      * identified by map would return the corresponding fragment from the translation to be processed.
      *
      * Navigation in the document is still determined by the current root as defined through the `root`, `xpath`
      * and `xmlId` properties.
      */
      map: {
        type: String
      },

      /**
      * If set to true, the component will not load automatically. Instead it will wait until it receives a `pb-update`
      * event. Use this to make one `pb-view` component dependent on another one. Default is 'false'.
      */
      onUpdate: {
        type: Boolean,
        attribute: 'on-update'
      },

      /**
      * Message to display if no content was returned by the server.
      * Set to empty string to show nothing.
      */
      notFound: {
        type: String,
        attribute: 'not-found'
      },

      /**
      * The relative URL to the script on the server which will be called for loading content.
      */
      url: {
        type: String
      },

      /**
       * If set, rewrite URLs to load pages as static HTML files,
       * so no TEI Publisher instance is required. Use this in combination with
       * [tei-publisher-static](https://github.com/eeditiones/tei-publisher-static).
       * The value should point to the HTTP root path under which the static version
       * will be hosted. This is used to resolve CSS stylesheets.
       */
      static: {
        type: String
      },

      /**
      * The server returns footnotes separately. Set this property
      * if you wish to append them to the main text.
      */
      appendFootnotes: {
        type: Boolean,
        attribute: 'append-footnotes'
      },

      /**
      * Should matches be highlighted if a search has been executed?
      */
      suppressHighlight: {
        type: Boolean,
        attribute: 'suppress-highlight',
        reflect: true
      },

      /**
      * CSS selector to find column breaks in the content returned
      * from the server. If this property is set and column breaks
      * are found, the component will display two columns side by side.
      */
      columnSeparator: {
        type: String,
        attribute: 'column-separator'
      },

      /**
      * The reading direction, i.e. 'ltr' or 'rtl'.
      * 
      * @type {"ltr"|"rtl"}
      */
      direction: {
        type: String
      },

      /**
       * If set, points to an external stylesheet which should be applied to
       * the text *after* the ODD-generated styles.
       */
      loadCss: {
        type: String,
        attribute: 'load-css'
      },

      /**
       * If set, relative links (img, a) will be made absolute.
       */
      fixLinks: {
        type: Boolean,
        attribute: 'fix-links'
      },

      /**
       * If set, a refresh will be triggered if a `pb-i18n-update` event is received,
       * e.g. due to the user selecting a different interface language.
       * 
       * Also requires `requireLanguage` to be set on the surrounding `pb-page`.
       * See there for more information.
       */
      useLanguage: {
        type: Boolean,
        attribute: 'use-language'
      },

      /**
      * wether to animate the view when new page is loaded. Defaults to 'false' meaning that no
      * animation takes place. If 'true' will apply a translateX transistion in forward/backward direction.
      */
      animation: {
        type: Boolean
      },

      /**
       * Experimental: if enabled, the view will incrementally load new document fragments if the user tries to scroll
       * beyond the start or end of the visible text. The feature inserts a small blank section at the top
       * and bottom. If this section becomes visible, a load operation will be triggered.
       * 
       * Note: only browsers implementing the `IntersectionObserver` API are supported. Also the feature
       * does not work in two-column mode or with animations.
       */
      infiniteScroll: {
        type: Boolean,
        attribute: 'infinite-scroll'
      },

      /**
       * Maximum number of fragments to keep in memory if `infinite-scroll`
       * is enabled. If the user is scrolling beyond the maximum, fragements
       * will be removed from the DOM before or after the current reading position.
       * Default is 10. Set to zero to allow loading the entire document.
       */
      infiniteScrollMax: {
        type: Number,
        attribute: 'infinite-scroll-max'
      },

      /**
       * A selector pointing to other components this component depends on.
       * When method `wait` is called, it will wait until all referenced
       * components signal with a `pb-ready` event that they are ready and listening
       * to events.
       * 
       * `pb-view` by default sets this property to select `pb-toggle-feature` and `pb-select-feature` 
       * elements.
       */
      waitFor: {
        type: String,
        attribute: 'wait-for'
      },

      /**
       * By default, navigating to next/previous page will update browser parameters,
       * so reloading the page will load the correct position within the document.
       * 
       * Set this property to disable location tracking for the component altogether.
       */
      disableHistory: {
        type: Boolean,
        attribute: 'disable-history'
      },

      /**
       * If set to the name of an event, the content of the pb-view will not be replaced
       * immediately upon updates. Instead, an event is emitted, which contains the new content
       * in property `root`. An event handler intercepting the event can thus modify the content.
       * Once it is done, it should pass the modified content to the callback function provided
       * in the event detail under the name `render`. See the demo for an example.
       */
      beforeUpdate: {
        type: String,
        attribute: 'before-update-event'
      },

      /**
       * If set, do not scroll the view to target node (e.g. given in URL hash) 
       * after content was loaded.
       */
      noScroll: {
        type: Boolean,
        attribute: 'no-scroll'
      },
      _features: {
        type: Object
      },
      _content: {
        type: Node,
        attribute: false
      },
      _column1: {
        type: Node,
        attribute: false
      },
      _column2: {
        type: Node,
        attribute: false
      },
      _footnotes: {
        type: Node,
        attribute: false
      },
      _style: {
        type: Node,
        attribute: false
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.src = null;
    this.url = null;
    this.onUpdate = false;
    this.appendFootnotes = false;
    this.notFound = "the server did not return any content";
    this.animation = false;
    this.direction = 'ltr';
    this.suppressHighlight = false;
    this.highlight = false;
    this.infiniteScrollMax = 10;
    this.disableHistory = false;
    this.beforeUpdate = null;
    this.noScroll = false;
    this._features = {};
    this._selector = new Map();
    this._chunks = [];
    this._scrollTarget = null;
    this.static = null;
  }

  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);

    switch (name) {
      case 'src':
        this._updateSource(newVal, oldVal);

        break;
    }
  }

  connectedCallback() {
    super.connectedCallback();

    if (this.infiniteScroll) {
      this.columnSeparator = null;
      this.animation = false;
      this._content = document.createElement('div');
      this._content.className = 'infinite-content';
    }

    if (!this.disableHistory) {
      const id = this.getParameter('id');

      if (id && !this.xmlId) {
        this.xmlId = id;
      }

      const action = this.getParameter('action');

      if (action && action === 'search') {
        this.highlight = true;
      }

      const nodeId = this.getParameter('root');

      if (this.view === 'single') {
        this.nodeId = null;
      } else if (nodeId && !this.nodeId) {
        this.nodeId = nodeId;
      }
    }

    if (!this.waitFor) {
      this.waitFor = 'pb-toggle-feature,pb-select-feature,pb-navigation';
    }

    this.subscribeTo('pb-navigate', ev => {
      if (ev.detail.source && ev.detail.source === this) {
        return;
      }

      this.navigate(ev.detail.direction);
    });
    this.subscribeTo('pb-refresh', this._refresh.bind(this));
    this.subscribeTo('pb-toggle', ev => {
      this.toggleFeature(ev);
    });
    this.subscribeTo('pb-zoom', ev => {
      this.zoom(ev.detail.direction);
    });
    this.subscribeTo('pb-i18n-update', ev => {
      const needsRefresh = this._features.language && this._features.language !== ev.detail.language;
      this._features.language = ev.detail.language;

      if (this.useLanguage && needsRefresh) {
        this._refresh();
      }
    }, []);
    this.signalReady();

    if (this.onUpdate) {
      this.subscribeTo('pb-update', this._refresh.bind(this));
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    if (this._scrollObserver) {
      this._scrollObserver.disconnect();
    }
  }

  firstUpdated() {
    super.firstUpdated();
    this.enableScrollbar(true);

    if (this.infiniteScroll) {
      this._topObserver = this.shadowRoot.getElementById('top-observer');
      this._bottomObserver = this.shadowRoot.getElementById('bottom-observer');
      this._bottomObserver.style.display = 'none';
      this._topObserver.style.display = 'none';
      this._scrollObserver = new IntersectionObserver(entries => {
        if (!this._content) {
          return;
        }

        entries.forEach(entry => {
          if (entry.isIntersecting) {
            if (entry.target.id === 'bottom-observer') {
              const lastChild = this._content.lastElementChild;

              if (lastChild) {
                const next = lastChild.getAttribute('data-next');

                if (next && !this._content.querySelector(`[data-root="${next}"]`)) {
                  console.log('<pb-view> Loading next page: %s', next);

                  this._checkChunks('forward');

                  this._load(next, 'forward');
                }
              }
            } else {
              const firstChild = this._content.firstElementChild;

              if (firstChild) {
                const previous = firstChild.getAttribute('data-previous');

                if (previous && !this._content.querySelector(`[data-root="${previous}"]`)) {
                  this._checkChunks('backward');

                  this._load(previous, 'backward');
                }
              }
            }
          }
        });
      });
    }

    if (!this.onUpdate) {
      PbView.waitOnce('pb-page-ready', data => {
        if (data && data.language) {
          this._features.language = data.language;
        }

        this.wait(() => this._refresh());
      });
    }
  }
  /**
   * Returns the ODD used to render content.
   * 
   * @returns the ODD being used
   */


  getOdd() {
    return this.odd || this.getDocument().odd || "teipublisher";
  }

  getView() {
    return this.view || this.getDocument().view || "single";
  }
  /**
   * Trigger an update of this element's content
   */


  forceUpdate() {
    this._load(this.nodeId);
  }

  animate() {
    // animate new element if 'animation' property is 'true'
    if (this.animation) {
      if (this.lastDirection === 'forward') {
        anime$1({
          targets: this.shadowRoot.getElementById('view'),
          opacity: [0, 1],
          translateX: [1000, 0],
          duration: 300,
          easing: 'linear'
        });
      } else {
        anime$1({
          targets: this.shadowRoot.getElementById('view'),
          opacity: [0, 1],
          translateX: [-1000, 0],
          duration: 300,
          easing: 'linear'
        });
      }
    }
  }

  enableScrollbar(enable) {
    if (enable) {
      this.classList.add('noscroll');
    } else {
      this.classList.remove('noscroll');
    }
  }

  _refresh(ev) {
    if (ev && ev.detail) {
      if (ev.detail.hash && !this.noScroll && !(ev.detail.id || ev.detail.path || ev.detail.odd || ev.detail.view || ev.detail.position)) {
        // if only the scroll target has changed: scroll to the element without reloading
        this._scrollTarget = ev.detail.hash;
        const target = this.shadowRoot.getElementById(this._scrollTarget);

        if (target) {
          setTimeout(() => target.scrollIntoView({
            block: 'nearest'
          }));
        }

        return;
      }

      if (ev.detail.path) {
        const doc = this.getDocument();
        doc.path = ev.detail.path;
      }

      if (ev.detail.id) {
        this.xmlId = ev.detail.id;
      }

      this.odd = ev.detail.odd || this.odd;

      if (ev.detail.columnSeparator !== undefined) {
        this.columnSeparator = ev.detail.columnSeparator;
      }

      this.view = ev.detail.view || this.view;

      if (ev.detail.xpath) {
        this.xpath = ev.detail.xpath;
        this.nodeId = null;
      } // clear nodeId if set to null


      if (ev.detail.position === null) {
        this.nodeId = null;
      } else {
        this.nodeId = ev.detail.position || this.nodeId;
      }

      if (!this.noScroll) {
        this._scrollTarget = ev.detail.hash;
      }
    }

    this._updateStyles();

    if (this.infiniteScroll) {
      this._clear();
    }

    this._load(this.nodeId);
  }

  _load(pos, direction) {
    const doc = this.getDocument();

    if (!doc.path) {
      console.log("No path");
      return;
    }

    if (this._loading) {
      return;
    }

    this._loading = true;
    const params = this.getParameters(pos);

    if (direction) {
      params._dir = direction;
    } // this.$.view.style.opacity=0;


    this._doLoad(params);
  }

  _doLoad(params) {
    this.emitTo('pb-start-update', params);
    console.log("<pb-view> Loading view with params %o", params);

    if (!this.infiniteScroll) {
      this._clear();
    }

    if (this._scrollObserver) {
      if (this._bottomObserver) {
        this._scrollObserver.unobserve(this._bottomObserver);
      }

      if (this._topObserver) {
        this._scrollObserver.unobserve(this._topObserver);
      }
    }

    const loadContent = this.shadowRoot.getElementById('loadContent');

    if (this.static !== null) {
      this._staticUrl(params).then(url => {
        loadContent.url = url;
        loadContent.generateRequest();
      });
    } else {
      if (!this.url) {
        if (this.minApiVersion('1.0.0')) {
          this.url = "api/parts";
        } else {
          this.url = "modules/lib/components.xql";
        }
      }

      if (this.minApiVersion('1.0.0')) {
        loadContent.url = `${this.getEndpoint()}/${this.url}/${encodeURIComponent(this.getDocument().path)}/json`;
      } else {
        loadContent.url = `${this.getEndpoint()}/${this.url}`;
      }

      loadContent.params = params;
      loadContent.generateRequest();
    }
  }
  /**
   * Use a static URL to load pre-generated content.
   */


  async _staticUrl(params) {
    function createKey(paramNames) {
      const urlComponents = [];
      paramNames.sort().forEach(key => {
        if (params.hasOwnProperty(key)) {
          urlComponents.push(`${key}=${params[key]}`);
        }
      });
      return urlComponents.join('&');
    }

    const index = await fetch(`index.json`).then(response => response.json());
    const paramNames = ['odd', 'view', 'xpath', 'map'];
    this.querySelectorAll('pb-param').forEach(param => paramNames.push(`user.${param.getAttribute('name')}`));
    let url = params.id ? createKey([...paramNames, 'id']) : createKey([...paramNames, 'root']);
    let file = index[url];

    if (!file) {
      url = createKey(paramNames);
      file = index[url];
    }

    console.log('<pb-view> Static lookup %s: %s', url, file);
    return `${file}`;
  }

  _clear() {
    if (this.infiniteScroll) {
      this._content = document.createElement('div');
      this._content.className = 'infinite-content';
    } else {
      this._content = null;
    }

    this._column1 = null;
    this._column2 = null;
    this._footnotes = null;
    this._chunks = [];
  }

  _handleError() {
    this._clear();

    const loader = this.shadowRoot.getElementById('loadContent');
    let message;
    const {
      response
    } = loader.lastError;

    if (response) {
      message = response.description;
    } else {
      message = '<pb-i18n key="dialogs.serverError"></pb-i18n>';
    }

    const content = `
            <p>${this.notFound}</p>
            <p><pb-i18n key="dialogs.serverError"></pb-i18n>: ${message} </p>
        `;

    this._replaceContent({
      content
    });

    this.emitTo('pb-end-update');
  }

  _handleContent() {
    const loader = this.shadowRoot.getElementById('loadContent');
    const resp = loader.lastResponse;

    if (!resp) {
      console.error('<pb-view> No response received');
      return;
    }

    if (resp.error) {
      if (this.notFound) {
        this._content = this.notFound;
      }

      this.emitTo('pb-end-update', null);
      return;
    }

    this._replaceContent(resp, loader.params._dir);

    this.animate();

    if (this._scrollTarget) {
      this.updateComplete.then(() => {
        const target = this.shadowRoot.getElementById(this._scrollTarget) || this.shadowRoot.querySelector(`[node-id="${this._scrollTarget}"]`);

        if (target) {
          window.requestAnimationFrame(() => setTimeout(() => {
            target.scrollIntoView({
              block: 'nearest'
            });
          }, 400));
        }

        this._scrollTarget = null;
      });
    }

    this.next = resp.next;
    this.nextId = resp.nextId;
    this.previous = resp.previous;
    this.previousId = resp.previousId;
    this.nodeId = resp.root;
    this.switchView = resp.switchView;

    if (!this.disableHistory && this.xmlId && !this.map) {
      //this.setParameter('root', this.nodeId);
      this.setParameter('id', this.xmlId);
      this.pushHistory('Navigate to xml:id');
    }

    this.xmlId = null;
    this.updateComplete.then(() => {
      const view = this.shadowRoot.getElementById('view');

      this._applyToggles(view);

      this._fixLinks(view);

      typesetMath(view);
      const eventOptions = {
        data: resp,
        root: view,
        params: loader.params,
        id: this.xmlId,
        position: this.nodeId
      };
      this.emitTo('pb-update', eventOptions);

      this._scroll();
    });
    this.emitTo('pb-end-update', null);
  }

  _replaceContent(resp, direction) {
    const fragment = document.createDocumentFragment();
    const elem = document.createElement('div'); // elem.style.opacity = 0; //hide it - animation has to make sure to blend it in

    fragment.appendChild(elem);
    elem.innerHTML = resp.content; // if before-update-event is set, we do not replace the content immediately,
    // but emit an event

    if (this.beforeUpdate) {
      this.emitTo(this.beforeUpdate, {
        data: resp,
        root: elem,
        render: content => {
          this._doReplaceContent(content, resp, direction);
        }
      });
    } else {
      this._doReplaceContent(elem, resp, direction);
    }
  }

  _doReplaceContent(elem, resp, direction) {
    if (this.columnSeparator) {
      this._replaceColumns(elem);

      this._loading = false;
    } else if (this.infiniteScroll) {
      elem.className = 'scroll-fragment';
      elem.setAttribute('data-root', resp.root);

      if (resp.next) {
        elem.setAttribute('data-next', resp.next);
      }

      if (resp.previous) {
        elem.setAttribute('data-previous', resp.previous);
      }

      let refNode;

      switch (direction) {
        case 'backward':
          refNode = this._content.firstElementChild;

          this._chunks.unshift(elem);

          this.updateComplete.then(() => {
            refNode.scrollIntoView(true);
            this._loading = false;

            this._checkVisibility();

            this._scrollObserver.observe(this._bottomObserver);

            this._scrollObserver.observe(this._topObserver);
          });

          this._content.insertBefore(elem, refNode);

          break;

        default:
          this.updateComplete.then(() => {
            this._loading = false;

            this._checkVisibility();

            this._scrollObserver.observe(this._bottomObserver);

            this._scrollObserver.observe(this._topObserver);
          });

          this._chunks.push(elem);

          this._content.appendChild(elem);

          break;
      }
    } else {
      this._content = elem;
      this._loading = false;
    }

    if (this.appendFootnotes) {
      const footnotes = document.createElement('div');

      if (resp.footnotes) {
        footnotes.innerHTML = resp.footnotes;
      }

      this._footnotes = footnotes;
    }

    this._initFootnotes(this._footnotes);

    return elem;
  }

  _checkVisibility() {
    const bottomActive = this._chunks[this._chunks.length - 1].hasAttribute('data-next');

    this._bottomObserver.style.display = bottomActive ? '' : 'none';

    const topActive = this._chunks[0].hasAttribute('data-previous');

    this._topObserver.style.display = topActive ? '' : 'none';
  }

  _replaceColumns(elem) {
    let cb;

    if (this.columnSeparator) {
      const cbs = elem.querySelectorAll(this.columnSeparator); // use last separator only

      if (cbs.length > 0) {
        cb = cbs[cbs.length - 1];
      }
    }

    if (!cb) {
      this._content = elem;
    } else {
      const fragmentBefore = this._getFragmentBefore(elem, cb);

      const fragmentAfter = this._getFragmentAfter(elem, cb);

      if (this.direction === 'ltr') {
        this._column1 = fragmentBefore;
        this._column2 = fragmentAfter;
      } else {
        this._column2 = fragmentBefore;
        this._column1 = fragmentAfter;
      }
    }
  }

  _scroll() {
    if (this.noScroll) {
      return;
    }

    const {
      hash
    } = this.getUrl();

    if (hash) {
      const target = this.shadowRoot.getElementById(hash.substring(1));
      console.log('hash target: %o', target);

      if (target) {
        window.requestAnimationFrame(() => setTimeout(() => {
          target.scrollIntoView({
            block: 'nearest'
          });
        }, 400));
      }
    }
  }

  _scrollToElement(ev, link) {
    const target = this.shadowRoot.getElementById(link.hash.substring(1));

    if (target) {
      ev.preventDefault();
      console.log('<pb-view> Scrolling to element %s', target.id);
      target.scrollIntoView({
        block: "center",
        inline: "nearest"
      });
    }
  }

  _updateStyles() {
    const links = [];
    let link = document.createElement('link');
    link.setAttribute('rel', 'stylesheet');
    link.setAttribute('type', 'text/css');

    if (this.static !== null) {
      link.setAttribute('href', `${this.static}/css/${this.getOdd()}.css`);
    } else {
      link.setAttribute('href', `${this.getEndpoint()}/transform/${this.getOdd()}.css`);
    }

    links.push(link);

    if (this.loadCss) {
      link = document.createElement('link');
      link.setAttribute('rel', 'stylesheet');
      link.setAttribute('type', 'text/css');
      link.setAttribute('href', this.toAbsoluteURL(this.loadCss));
      links.push(link);
    }

    this._style = links;
  }

  _fixLinks(content) {
    if (this.fixLinks) {
      const doc = this.getDocument();
      const base = this.toAbsoluteURL(doc.path);
      content.querySelectorAll('img').forEach(image => {
        const oldSrc = image.getAttribute('src');
        const src = new URL(oldSrc, base);
        image.src = src;
      });
      content.querySelectorAll('a').forEach(link => {
        const oldHref = link.getAttribute('href');

        if (oldHref === link.hash) {
          link.addEventListener('click', ev => this._scrollToElement(ev, link));
        } else {
          const href = new URL(oldHref, base);
          link.href = href;
        }
      });
    } else {
      content.querySelectorAll('a').forEach(link => {
        const oldHref = link.getAttribute('href');

        if (oldHref === link.hash) {
          link.addEventListener('click', ev => this._scrollToElement(ev, link));
        }
      });
    }
  }

  _initFootnotes(content) {
    if (content) {
      content.querySelectorAll('.note, .fn-back').forEach(elem => {
        elem.addEventListener('click', ev => {
          ev.preventDefault();
          const fn = this.shadowRoot.getElementById('content').querySelector(elem.hash);

          if (fn) {
            fn.scrollIntoView();
          }
        });
      });
    }
  }

  _getParameters() {
    const params = [];
    this.querySelectorAll('pb-param').forEach(function (param) {
      params['user.' + param.getAttribute('name')] = param.getAttribute('value');
    }); // add parameters for features set with pb-toggle-feature

    for (const [key, value] of Object.entries(this._features)) {
      params['user.' + key] = value;
    }

    return params;
  }
  /**
   * Return the parameter object which would be passed to the server by this component
   */


  getParameters(pos) {
    pos = pos || this.nodeId;
    const doc = this.getDocument();

    const params = this._getParameters();

    if (!this.minApiVersion('1.0.0')) {
      params.doc = doc.path;
    }

    params.odd = this.getOdd() + '.odd';
    params.view = this.getView();

    if (pos) {
      params['root'] = pos;
    }

    if (this.xpath) {
      params.xpath = this.xpath;
    }

    if (this.xmlId) {
      params.id = this.xmlId;
    }

    if (!this.suppressHighlight && this.highlight) {
      params.highlight = "yes";
    }

    if (this.map) {
      params.map = this.map;
    }

    return params;
  }

  _applyToggles(elem) {
    if (this._selector.size === 0) {
      return;
    }

    this._selector.forEach((setting, selector) => {
      elem.querySelectorAll(selector).forEach(node => {
        const command = setting.command || 'toggle';

        if (node.command) {
          node.command(command, setting.state);
        }

        if (setting.state) {
          node.classList.add(command);
        } else {
          node.classList.remove(command);
        }
      });
    });
  }
  /**
   * Load a part of the document identified by the given eXist nodeId
   *
   * @param {String} nodeId The eXist nodeId of the root element to load
   */


  goto(nodeId) {
    this._load(nodeId);
  }
  /**
   * Load a part of the document identified by the given xml:id
   *
   * @param {String} xmlId The xml:id to be loaded
   */


  gotoId(xmlId) {
    this.xmlId = xmlId;

    this._load();
  }
  /**
   * Navigate the document either forward or backward and refresh the view.
   * The navigation method is determined by property `view`.
   *
   * @param {string} direction either `backward` or `forward`
   */


  navigate(direction) {
    this.lastDirection = direction;

    if (direction === 'backward') {
      if (this.previous) {
        if (!this.disableHistory && !this.map) {
          if (this.previousId) {
            this.setParameter('id', this.previousId);
          } else {
            this.setParameter('root', this.previous);
          }

          this.pushHistory('Navigate backward');
        }

        this._load(this.previous, direction);
      }
    } else if (this.next) {
      if (!this.disableHistory && !this.map) {
        if (this.nextId) {
          this.setParameter('id', this.nextId);
        } else {
          this.setParameter('root', this.next);
        }

        this.pushHistory('Navigate forward');
      }

      this._load(this.next, direction);
    }
  }
  /**
   * Check the number of fragments which were already loaded in infinite
   * scroll mode. If they exceed `infiniteScrollMax`, remove either the
   * first or last fragment from the DOM, depending on the scroll direction.
   * 
   * @param {string} direction either 'forward' or 'backward'
   */


  _checkChunks(direction) {
    if (!this.infiniteScroll || this.infiniteScrollMax === 0) {
      return;
    }

    if (this._chunks.length === this.infiniteScrollMax) {
      switch (direction) {
        case 'forward':
          this._content.removeChild(this._chunks.shift());

          break;

        default:
          this._content.removeChild(this._chunks.pop());

          break;
      }
    }

    this.emitTo('pb-navigate', {
      direction,
      source: this
    });
  }
  /**
   * Zoom the displayed content by increasing or decreasing font size.
   *
   * @param {string} direction either `in` or `out`
   */


  zoom(direction) {
    const view = this.shadowRoot.getElementById('view');
    const fontSize = window.getComputedStyle(view).getPropertyValue('font-size');
    const size = parseInt(fontSize.replace(/^(\d+)px/, "$1"));

    if (direction === 'in') {
      view.style.fontSize = size + 1 + 'px';
    } else {
      view.style.fontSize = size - 1 + 'px';
    }
  }

  toggleFeature(ev) {
    const applyToggles = () => {
      const view = this.shadowRoot.getElementById('view');

      this._applyToggles(view);
    };

    const properties = ev.detail.properties;

    for (const [key, value] of Object.entries(properties)) {
      switch (key) {
        case 'odd':
        case 'view':
        case 'columnSeparator':
        case 'xpath':
        case 'nodeId':
          break;

        default:
          this._features[key] = value;
          break;
      }
    }

    if (properties) {
      if (properties.odd) {
        this.odd = properties.odd;
      }

      if (properties.view) {
        this.view = properties.view;

        if (this.view === 'single') {
          // when switching to single view, clear current node id
          this.nodeId = null;
        } else {
          // otherwise use value for alternate view returned from server
          this.nodeId = this.switchView;
        }
      }

      if (properties.xpath) {
        this.xpath = properties.xpath;
      }

      if (properties.hasOwnProperty('columnSeparator')) {
        this.columnSeparator = properties.columnSeparator;
      }
    }

    if (ev.detail.selectors) {
      ev.detail.selectors.forEach(sc => {
        this._selector.set(sc.selector, {
          state: sc.state,
          command: sc.command || 'toggle'
        });
      });
    }

    if (ev.detail.action === 'refresh') {
      if (Object.keys(properties).length > 0) {
        this._updateStyles();

        this._load();
      } else {
        applyToggles();
      }
    }
  }

  _getFragmentBefore(node, ms) {
    const range = document.createRange();
    range.setStartBefore(node);
    range.setEndBefore(ms);
    return range.cloneContents();
  }

  _getFragmentAfter(node, ms) {
    const range = document.createRange();
    range.setStartBefore(ms);
    range.setEndAfter(node);
    return range.cloneContents();
  }

  _updateSource(newVal, oldVal) {
    if (typeof oldVal !== 'undefined' && newVal !== oldVal) {
      this.xpath = null;
      this.odd = null;
      this.xmlId = null;
      this.nodeId = null;
    }
  }

  static get styles() {
    return css`
            :host {
                display: block;
                background: transparent;
            }

            :host(.noscroll) {
                scrollbar-width: none; /* Firefox 64 */
                -ms-overflow-style: none;
            }

            :host(.noscroll)::-webkit-scrollbar { 
                width: 0 !important;
                display: none; 
            }

            [id] {
                scroll-margin-top: var(--pb-view-scroll-margin-top);
            }

            #view {
                position: relative;
            }

            .columns {
                display: grid;
                grid-template-columns: calc(50% - var(--pb-view-column-gap, 10px) / 2) calc(50% - var(--pb-view-column-gap, 10px) / 2);
                grid-column-gap: var(--pb-view-column-gap, 10px);
            }

            .margin-note {
                display: none;
            }

            @media (min-width: 769px) {
                .content.margin-right {
                    margin-right: 200px;
                }

                .margin-note {
                    background: rgba(153, 153, 153, 0.2);
                    display: block;
                    font-size: small;
                    margin-right: -200px;
                    margin-bottom: 5px;
                    padding: 5px 0;
                    float: right;
                    clear: both;
                    width: 180px;
                }

                .margin-note .n {
                  color: #777777;
                }
            }

            a[rel=footnote] {
                font-size: var(--pb-footnote-font-size, var(--pb-content-font-size, 75%));
                font-family: var(--pb-footnote-font-family, --pb-content-font-family);
                vertical-align: super;
                color: var(--pb-footnote-color, var(--pb-color-primary, #333333));
                text-decoration: none;
                padding: var(--pb-footnote-padding, 0 0 0 .25em);
            }

            .list dt {
                float: left;
            }

            .footnote .fn-number {
                float: left;
                font-size: var(--pb-footnote-font-size, var(--pb-content-font-size, 75%));
            }

            .observer {
                display: block;
                width: 100%;
                height: var(--pb-view-loader-height, 16px);
                font-family: var(--pb-view-loader-font, --pb-base-font);
                color: var(--pb-view-loader-color, black);
                background: var(--pb-view-loader-background, #909090);
                background-image: var(--pb-view-loader-background-image, repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(255,255,255,.5) 35px, rgba(255,255,255,.5) 70px));
                animation-name: loader;
                animation-timing-function: linear;
                animation-duration: 2s;
                animation-fill-mode: forwards;
                animation-iteration-count: infinite;
            }

            @keyframes loader {
                0% {
                    background-position: 3rem 0;
                }
                
                100% {
                    background-position: 0 0;
                }
            }

            .scroll-fragment {
                animation: fadeIn ease 500ms;
            }

            @keyframes fadeIn {
                0% {opacity:0;}
                100% {opacity:1;}
            }
        `;
  }

  render() {
    return [html$1`
                <div id="view" part="content">
                    ${this._style}
                    ${this.infiniteScroll ? html$1`<div id="top-observer" class="observer"></div>` : null}
                    <div class="columns">
                        <div id="column1">${this._column1}</div>
                        <div id="column2">${this._column2}</div>
                    </div>
                    <div id="content">${this._content}</div>
                    ${this.infiniteScroll ? html$1`<div id="bottom-observer" class="observer"></div>` : null}
                    <div id="footnotes" part="footnotes">${this._footnotes}</div>
                </div>
                <paper-dialog id="errorDialog">
                    <h2>${translate('dialogs.error')}</h2>
                    <paper-dialog-scrollable></paper-dialog-scrollable>
                    <div class="buttons">
                        <paper-button dialog-confirm="dialog-confirm" autofocus="autofocus">
                        ${translate('dialogs.close')}
                        </paper-button>
                    </div>
                </paper-dialog>
                <iron-ajax
                    id="loadContent"
                    verbose
                    handle-as="json"
                    method="get"
                    with-credentials
                    @response="${this._handleContent}"
                    @error="${this._handleError}"></iron-ajax>
            `];
  }

}
customElements.define('pb-view', PbView);

const SATURATION_BOUND = [0, 100];
const LIGHTNESS_BOUND = [0, 100];

const pad2 = str => `${str.length === 1 ? '0' : ''}${str}`;

const clamp = (num, min, max) => Math.max(Math.min(num, max), min);

const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
/**
 * Generate hashCode
 * @param  {string} str
 * @return {number}
 */


const hashCode = str => {
  const len = str.length;
  let hash = 0;

  for (let i = 0; i < len; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
};
/**
* Clamps `num` within the inclusive `range` bounds
* @param  {number}       num
* @param  {number|Array} range
* @return {number}
*/


const boundHashCode = (num, range) => {
  if (typeof range === 'number') {
    return range;
  }

  return num % Math.abs(range[1] - range[0]) + range[0];
};
/**
 * Sanitizing the `range`
 * @param  {number|Array} range
 * @param  {Array}        bound
 * @return {number|Array}
 */


const sanitizeRange = (range, bound) => {
  if (typeof range === 'number') {
    return clamp(Math.abs(range), ...bound);
  }

  if (range.length === 1 || range[0] === range[1]) {
    return clamp(Math.abs(range[0]), ...bound);
  }

  return [Math.abs(clamp(range[0], ...bound)), clamp(Math.abs(range[1]), ...bound)];
};
/**
 * @param  {number} p
 * @param  {number} q
 * @param  {number} t
 * @return {number}
 */


const hueToRgb = (p, q, t) => {
  if (t < 0) {
    t += 1;
  } else if (t > 1) {
    t -= 1;
  }

  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }

  if (t < 1 / 2) {
    return q;
  }

  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }

  return p;
};
/**
 * Converts an HSL color to RGB
 * @param  {number} h Hue
 * @param  {number} s Saturation
 * @param  {number} l Lightness
 * @return {Array}
 */


const hslToRgb = (h, s, l) => {
  let r;
  let g;
  let b;
  h /= 360;
  s /= 100;
  l /= 100;

  if (s === 0) {
    // achromatic
    r = g = b = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hueToRgb(p, q, h + 1 / 3);
    g = hueToRgb(p, q, h);
    b = hueToRgb(p, q, h - 1 / 3);
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};
/**
 * Determines whether the RGB color is light or not
 * http://www.w3.org/TR/AERT#color-contrast
 * @param  {number}  r               Red
 * @param  {number}  g               Green
 * @param  {number}  b               Blue
 * @param  {number}  differencePoint
 * @return {boolean}
 */


const rgbIsLight = (r, g, b, differencePoint) => (r * 299 + g * 587 + b * 114) / 1000 >= differencePoint; // eslint-disable-line max-len

/**
 * Converts an HSL color to string format
 * @param  {number} h Hue
 * @param  {number} s Saturation
 * @param  {number} l Lightness
 * @return {string}
 */


const hslToString = (h, s, l) => `hsl(${h}, ${s}%, ${l}%)`;
/**
 * Converts RGB color to string format
 * @param  {number}  r      Red
 * @param  {number}  g      Green
 * @param  {number}  b      Blue
 * @param  {string}  format Color format
 * @return {string}
 */


const rgbFormat = (r, g, b, format) => {
  switch (format) {
    case 'rgb':
      return `rgb(${r}, ${g}, ${b})`;

    case 'hex':
    default:
      return `#${pad2(r.toString(16))}${pad2(g.toString(16))}${pad2(b.toString(16))}`;
  }
};
/**
 * Generate unique color from `value`
 * @param  {string|number} value
 * @param  {Object}        [options={}]
 * @param  {string}        [options.format='hex']
 *  The color format, it can be one of `hex`, `rgb` or `hsl`
 * @param  {number|Array}  [options.saturation=[50, 55]]
 *  Determines the color saturation, it can be a number or a range between 0 and 100
 * @param  {number|Array}  [options.lightness=[50, 60]]
 *  Determines the color lightness, it can be a number or a range between 0 and 100
 * @param  {number}        [options.differencePoint=130]
 *  Determines the color brightness difference point. We use it to obtain the `isLight` value
 *  in the output, it can be a number between 0 and 255
 * @return {Object}
 * @example
 *
 * uniqolor('Hello world!')
 * // { color: "#5cc653", isLight: true }
 *
 * uniqolor('Hello world!', { format: 'rgb' })
 * // { color: "rgb(92, 198, 83)", isLight: true }
 *
 * uniqolor('Hello world!', {
 *   saturation: 30,
 *   lightness: [70, 80],
 * })
 * // { color: "#afd2ac", isLight: true }
 *
 * uniqolor('Hello world!', {
 *   saturation: 30,
 *   lightness: [70, 80],
 *   differencePoint: 200,
 * })
 * // { color: "#afd2ac", isLight: false }
 */


const uniqolor = (value, {
  format = 'hex',
  saturation = [50, 55],
  lightness = [50, 60],
  differencePoint = 130
} = {}) => {
  const hash = Math.abs(hashCode(String(value)));
  const h = boundHashCode(hash, [0, 360]);
  const s = boundHashCode(hash, sanitizeRange(saturation, SATURATION_BOUND));
  const l = boundHashCode(hash, sanitizeRange(lightness, LIGHTNESS_BOUND));
  const [r, g, b] = hslToRgb(h, s, l);
  return {
    color: format === 'hsl' ? hslToString(h, s, l) : rgbFormat(r, g, b, format),
    isLight: rgbIsLight(r, g, b, differencePoint)
  };
};
/**
 * Generate random color
 * @param  {Object}       [options={}]
 * @param  {string}       [options.format='hex']
 *  The color format, it can be one of `hex`, `rgb` or `hsl`
 * @param  {number|Array} [options.saturation=[50, 55]]
 *  Determines the color saturation, it can be a number or a range between 0 and 100
 * @param  {number|Array} [options.lightness=[50, 60]]
 *  Determines the color lightness, it can be a number or a range between 0 and 100
 * @param  {number}       [options.differencePoint=130]
 *  Determines the color brightness difference point. We use it to obtain the `isLight` value
 *  in the output, it can be a number between 0 and 255
 * @return {Object}
 * @example
 *
 * uniqolor.random()
 * // { color: "#644cc8", isLight: false }
 *
 * uniqolor.random({ format: 'rgb' })
 * // { color: "rgb(195, 65, 126)", isLight: false }
 *
 * uniqolor.random({
 *   saturation: 30,
 *   lightness: [70, 80],
 * })
 * // { color: "#c7b9da", isLight: true }
 *
 * uniqolor.random({
 *   saturation: 30,
 *   lightness: [70, 80],
 *   differencePoint: 255,
 * })
 * // { color: "#afd2ac", isLight: false }
 */


uniqolor.random = ({
  format = 'hex',
  saturation = [50, 55],
  lightness = [50, 60],
  differencePoint = 130
} = {}) => {
  saturation = sanitizeRange(saturation, SATURATION_BOUND);
  lightness = sanitizeRange(lightness, LIGHTNESS_BOUND);
  const h = random(0, 360);
  const s = typeof saturation === 'number' ? saturation : random(...saturation);
  const l = typeof lightness === 'number' ? lightness : random(...lightness);
  const [r, g, b] = hslToRgb(h, s, l);
  return {
    color: format === 'hsl' ? hslToString(h, s, l) : rgbFormat(r, g, b, format),
    isLight: rgbIsLight(r, g, b, differencePoint)
  };
};

/**
 * Return the first child of ancestor which contains current.
 * Used to adjust nested anchor points.
 * 
 * @param {Node} current the anchor node
 * @param {Node} ancestor the context ancestor node
 * @returns {Node} first child of ancestor containing current
 */

function extendRange(current, ancestor) {
  let parent = current;

  while (parent.parentNode !== ancestor) {
    parent = parent.parentElement;
  }

  return parent;
}
/**
 * Check if the nodeToCheck should be ignored when computing offsets.
 * Applies e.g. to footnote markers.
 * 
 * @param {Node} nodeToCheck the node to check
 * @returns true if node should be ignored
 */


function isSkippedNode(nodeToCheck) {
  let node = nodeToCheck;

  if (node.nodeType === Node.TEXT_NODE) {
    node = node.parentNode;
  }

  const href =
  /** @type {Element} */
  node.getAttribute('href');
  return href && /^#fn_.*$/.test(href);
}
/**
 * For a given HTML node, compute the number of characters from the start
 * of the parent element.
 *
 * @param {Node} node the node for which to compute an absolute offset
 * @param {Number} offset start offset
 * @returns {Number} absolute offset
 */


function absoluteOffset(container, node, offset) {
  const walker = document.createTreeWalker(container);
  walker.currentNode = node;

  while (walker.previousNode()) {
    const sibling = walker.currentNode;

    if (!(sibling.nodeType === Node.ELEMENT_NODE || isSkippedNode(sibling))) {
      // eslint-disable-next-line no-param-reassign
      offset += sibling.textContent.length;
    }
  }

  return offset;
}
/**
 * Convert the start or end boundary of a browser range by computing
 * the number of characters from the start of the parent element.
 *
 * @param {Node} node input node
 * @param {Number} offset offset relative to the parent element
 * @returns
 */


function rangeToPoint(node, offset, position = 'start') {
  if (node.nodeType === Node.ELEMENT_NODE) {
    const container =
    /** @type {Element} */
    node.closest('[data-tei]');

    if (offset === 0) {
      return {
        parent: container.getAttribute('data-tei'),
        offset: 0
      };
    }

    const child = container.childNodes[offset];
    return {
      parent: container.getAttribute('data-tei'),
      offset: position === 'end' ? absoluteOffset(container, child, 0) - 1 : absoluteOffset(container, child, 0)
    };
  }

  const container =
  /** @type {Element} */
  node.parentNode.closest('[data-tei]');

  if (container) {
    return {
      parent: container.getAttribute('data-tei'),
      offset: absoluteOffset(container, node, offset)
    };
  } else {
    console.error('No container with data-tei found for %o', node.parentNode);
  }
}

function ancestors(node, selector) {
  let count = 0;
  let parent = node.parentNode;

  while (parent && parent !== node.getRootNode()) {
    if (parent.classList.contains(selector)) {
      count += 1;
    }

    parent = parent.parentNode;
  }

  return count;
}
/**
 * Find the next text node after the current node.
 * Descends into elements.
 * 
 * @param {Node} node the current node
 * @returns next text node or the current node if none is found
 */


function nextTextNode(context, node) {
  const walker = document.createTreeWalker(context, NodeFilter.SHOW_TEXT);
  walker.currentNode = node;

  if (walker.nextNode()) {
    return walker.currentNode;
  }

  return node;
}
/**
 * Convert a point given as number of characters from the start of the container element
 * to a coordinate relative to a DOM element.
 *
 * @param {Node} container the container element
 * @param {*} offset absolute offset
 * @returns
 */


function pointToRange(container, offset) {
  let relOffset = offset;
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);

  while (walker.nextNode()) {
    // skip footnote links and empty text nodes (chrome sometimes inserts those)
    if (!isSkippedNode(walker.currentNode) && walker.currentNode.textContent.length > 0) {
      if (relOffset - walker.currentNode.textContent.length <= 0) {
        return [walker.currentNode, relOffset];
      }

      relOffset -= walker.currentNode.textContent.length;
    }
  }

  return null;
}

function kwicText(str, start, end, words = 3) {
  let p0 = start - 1;
  let count = 0;

  while (p0 >= 0) {
    if (/[\p{P}\s]/.test(str.charAt(p0))) {
      while (p0 > 1 && /[\p{P}\s]/.test(str.charAt(p0 - 1))) {
        p0 -= 1;
      }

      count += 1;

      if (count === words) {
        break;
      }
    }

    p0 -= 1;
  }

  let p1 = end + 1;
  count = 0;

  while (p1 < str.length) {
    if (/[\p{P}\s]/.test(str.charAt(p1))) {
      while (p1 < str.length - 1 && /[\p{P}\s]/.test(str.charAt(p1 + 1))) {
        p1 += 1;
      }

      count += 1;

      if (count === words) {
        break;
      }
    }

    p1 += 1;
  }

  return `... ${str.substring(p0, start)}<mark>${str.substring(start, end)}</mark>${str.substring(end, p1 + 1)} ...`;
}

function collectText(node) {
  let parent = node.parentElement;

  if (parent.textContent.length < 40) {
    parent = parent.parentNode;
  }

  const walker = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT);
  let offset = 0;
  let start = 0;
  const str = [];

  while (walker.nextNode()) {
    if (walker.currentNode === node) {
      start = offset;
    }

    offset += walker.currentNode.textContent.length;
    str.push(walker.currentNode.textContent);
  }

  return [str.join(''), start];
}

function clearProperties(teiRange) {
  const cleaned = {};
  Object.keys(teiRange.properties).forEach(key => {
    const val = teiRange.properties[key];

    if (val && val.length > 0) {
      cleaned[key] = val;
    }
  });
  return Object.assign(teiRange, {
    properties: cleaned
  });
}
/**
 * An extended `PbView`, which supports annotations to be added
 * and edited by the user. Handles mouse selection and keeps track
 * of the annotations made.
 * 
 * Interaction with the actual editing form is entirely done via events.
 * The class itself does not provide any editing facility, except for
 * handling deletions.
 * 
 * @fires pb-selection-changed - fired when user selects text
 * @fires pb-annotations-changed - fired when an annotation was added or changed
 * @fires pb-annotation-detail - fired to request additional details about an annotation
 */


class PbViewAnnotate extends PbView {
  static get properties() {
    return Object.assign({
      /**
       * Configures the default annotation property containing the key for authority entries.
       * Default: 'ref', corresponding to TEI attribute @ref. Change to 'corresp' or 'key' when
       * using those attributes instead.
       * 
       * You can also define a custom mapping of annotation types to key properties, e.g. if you would
       * like to use @key for some elements, but @corresp for others.
       */
      key: {
        type: String
      },

      /**
       * Optional mapping of annotation type names to key properties
       */
      keyMap: {
        type: Object,
        attribute: 'key-map'
      },

      /**
       * When searching the displayed text for other potential occurrences of an entity,
       * should the search be done in case-sensitive manner?
       */
      caseSensitive: {
        type: Boolean
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.key = 'ref';
    this.keyMap = {};
    this.caseSensitive = false;
    this._ranges = [];
    this._rangesMap = new Map();
    this._history = [];
  }

  connectedCallback() {
    super.connectedCallback();
    let isMouseDown = false;
    this._inHandler = false;
    this._pendingCallback = null;

    const scheduleCallback = (delay = 10) => {
      this._pendingCallback = setTimeout(() => {
        this._selectionChanged();
      }, delay);
    };
    /** @param {Event} event */


    this._eventHandler = event => {
      if (event.type === 'selectionchange' && this._inHandler) {
        return;
      }

      if (event.type === 'mousedown') {
        isMouseDown = true;
      }

      if (event.type === 'mouseup') {
        isMouseDown = false;
      } // If the user makes a selection with the mouse, wait until they release
      // it before reporting a selection change.


      if (isMouseDown) {
        return;
      }

      this._cancelPendingCallback(); // Schedule a notification after a short delay. The delay serves two
      // purposes:
      //
      // - If this handler was called as a result of a 'mouseup' event then the
      //   selection will not be updated until the next tick of the event loop.
      //   In this case we only need a short delay.
      //
      // - If the user is changing the selection with a non-mouse input (eg.
      //   keyboard or selection handles on mobile) this buffers updates and
      //   makes sure that we only report one when the update has stopped
      //   changing. In this case we want a longer delay.


      const delay = event.type === 'mouseup' ? 10 : 100;
      scheduleCallback(delay);
    };

    document.addEventListener('selectionchange', this._eventHandler.bind(this));
    this.shadowRoot.addEventListener('mousedown', this._eventHandler.bind(this));
    this.shadowRoot.addEventListener('mouseup', this._eventHandler.bind(this));
    this.subscribeTo('pb-add-annotation', ev => this.addAnnotation(ev.detail));
    this.subscribeTo('pb-edit-annotation', this._editAnnotation.bind(this));
    this.subscribeTo('pb-refresh', () => {
      this._ranges = [];

      this._rangesMap.clear();

      this._currentSelection = null;

      this._clearMarkers();

      this.emitTo('pb-annotations-changed', {
        ranges: this._ranges,
        refresh: true
      });
    });

    this._resizeHandler();
  }

  get annotations() {
    return this._ranges;
  }

  set annotations(annoData) {
    this._ranges = annoData;
    this.updateAnnotations(true);

    this._initAnnotationColors();

    this._annotationStyles();
  }

  saveHistory() {
    this._history.push(JSON.stringify(this._ranges));

    this.emitTo('pb-annotations-history', this._history);
  }

  getHistory() {
    return this._history;
  }

  popHistory() {
    if (this._history.length === 0) {
      console.warn('<pb-view-annotate> history is empty');
      return;
    }

    this._scrollTop = this.scrollTop;

    const lastEntry = this._history.pop();

    this._clearMarkers();

    this._ranges = JSON.parse(lastEntry);

    this._rangesMap.clear();

    this._refresh();

    this.emitTo('pb-annotations-changed', {
      ranges: this._ranges
    });
    this.emitTo('pb-annotations-history', this._history);
  }

  clearHistory(data) {
    this._history = data || [];
  }

  firstUpdated() {
    super.firstUpdated();
    this.enableScrollbar(false);
    loadTippyStyles(this.shadowRoot, 'light-border');
  }

  render() {
    return [...super.render(), html$1`<div id="marker-layer"></div>`];
  }

  zoom(direction) {
    super.zoom(direction);
    window.requestAnimationFrame(() => this.refreshMarkers());
  }

  getKey(type) {
    return this.keyMap[type] || this.key;
  }

  _resizeHandler() {
    let _pendingCallback = null;

    const scheduleCallback = () => {
      _pendingCallback = setTimeout(() => {
        _pendingCallback = null;
        this.refreshMarkers();
      }, 200);
    };

    window.addEventListener('resize', () => {
      if (!_pendingCallback) {
        this._clearMarkers();
      }

      if (_pendingCallback) {
        clearTimeout(_pendingCallback);
      }

      scheduleCallback();
    });
  }

  _refresh(ev) {
    super._refresh(ev);

    if (ev && ev.detail && ev.detail.preserveScroll) {
      this._scrollTop = this.scrollTop;
    }
  }

  _handleContent() {
    super._handleContent();

    this.updateComplete.then(() => setTimeout(() => {
      this._initAnnotationColors();

      this._annotationStyles();

      this.updateAnnotations();

      this._markIncompleteAnnotations();

      if (this._scrollTop) {
        this.scrollTop = this._scrollTop;
        this._scrollTop = undefined;
      }
    }, 300));
  }

  _updateAnnotation(teiRange, silent = false, batch = false) {
    const view = this.shadowRoot.getElementById('view');
    const context = Array.from(view.querySelectorAll(`[data-tei="${teiRange.context}"]`)).filter(node => node.closest('pb-popover') === null && node.getAttribute('rel') !== 'footnote')[0];

    if (!context) {
      return null;
    }

    const range = document.createRange();
    const startPoint = pointToRange(context, teiRange.start);
    const endPoint = pointToRange(context, teiRange.end);

    if (!(startPoint && endPoint)) {
      console.error('<pb-view-annotate> Invalid range for %o', context);
      return null;
    }

    console.log('<pb-view-annotate> Range before adjust: %o %o', startPoint, endPoint);

    if (startPoint[1] === startPoint[0].textContent.length) {
      // try to find the next text node
      const nextNode = nextTextNode(context, startPoint[0]); // next text node is the endpoint: start there

      if (nextNode === endPoint[0]) {
        range.setStart(nextNode, 0); // adjust startPoint for check below

        startPoint[0] = nextNode;
        startPoint[1] = 0;
      } else {
        range.setStartBefore(startPoint[0].nextSibling || nextNode);
      }
    } else if (startPoint[0] !== endPoint[0] && startPoint[1] === 0) {
      range.setStartBefore(extendRange(startPoint[0], context));
    } else {
      range.setStart(startPoint[0], startPoint[1]);
    }

    if (startPoint[0] !== endPoint[0] && endPoint[0].textContent.length - 1 === endPoint[1]) {
      range.setEndAfter(extendRange(endPoint[0], context));
    } else {
      range.setEnd(endPoint[0], endPoint[1]);
    }

    console.log('<pb-view-annotate> Range: %o', range);
    const span = document.createElement('span');
    const addClass = teiRange.properties[this.getKey(teiRange.type)] === '' ? 'incomplete' : '';
    span.className = `annotation annotation-${teiRange.type} ${teiRange.type} ${addClass}`;
    span.dataset.type = teiRange.type;
    span.dataset.annotation = JSON.stringify(teiRange.properties);

    try {
      range.surroundContents(span);
    } catch (e) {
      if (silent) {
        return null;
      }

      throw new Error('An error occurred. The annotation may not be displayed. You should consider saving and reloading the document.');
    }

    this._rangesMap.set(span, teiRange);

    if (!batch) {
      this.refreshMarkers();
    }

    return span;
  }

  updateAnnotations(silent = false) {
    this._ranges.forEach(teiRange => {
      let span;

      switch (teiRange.type) {
        case 'delete':
          span = this.shadowRoot.querySelector(`[data-tei="${teiRange.node}"]`);

          if (span) {
            this._deleteAnnotation(span);
          } else {
            console.error('Annotation %s not found', teiRange.context);
          }

          break;

        case 'modify':
          span = this.shadowRoot.querySelector(`[data-tei="${teiRange.node}"]`);
          span.dataset.annotation = JSON.stringify(teiRange.properties);
          break;

        default:
          this._updateAnnotation(teiRange, silent, true);

          break;
      }
    });

    window.requestAnimationFrame(() => this.refreshMarkers());
  }

  _getSelection() {
    return this.shadowRoot.getSelection ? this.shadowRoot.getSelection() : window.getSelection();
  }

  _selectionChanged() {
    const selection = this._getSelection();

    const range = this._selectedRange(selection);

    if (range) {
      let changed = false;
      const ancestor = range.commonAncestorContainer;

      if (ancestor.nodeType === Node.ELEMENT_NODE) {
        if (range.startContainer.parentElement !== ancestor) {
          const parent = extendRange(range.startContainer, ancestor);
          range.setStartBefore(parent);
          changed = true;
        }

        if (range.endContainer.parentElement !== ancestor) {
          const parent = extendRange(range.endContainer, ancestor);
          range.setEndAfter(parent);
          changed = true;
        }
      }

      this._currentSelection = range;
      console.log('<pb-view-annotate> selection: %o', range);

      if (changed) {
        this._inHandler = true;
        setTimeout(() => {
          selection.removeAllRanges();
          selection.addRange(range);
          this.inHandler = false;
        }, 100);
      }

      this.emitTo('pb-selection-changed', {
        hasContent: true,
        range
      });
    } else {
      this.emitTo('pb-selection-changed', {
        hasContent: false
      });
    }
  }

  updateAnnotation(teiRange, batch = false) {
    teiRange = clearProperties(teiRange);

    const result = this._updateAnnotation(teiRange, batch);

    if (result) {
      this._ranges.push(teiRange);

      this.emitTo('pb-annotations-changed', {
        type: teiRange.type,
        text: teiRange.text,
        ranges: this._ranges
      });
    }

    return result;
  }

  addAnnotation(info) {
    const range = info.range || this._currentSelection;
    const startRange = rangeToPoint(range.startContainer, range.startOffset);
    const endRange = rangeToPoint(range.endContainer, range.endOffset, 'end');
    const adjustedRange = {
      context: startRange.parent,
      start: startRange.offset,
      end: endRange.offset,
      text: range.cloneContents().textContent
    };

    if (info.type) {
      adjustedRange.type = info.type;
    }

    if (info.properties) {
      adjustedRange.properties = info.properties;
    }

    console.log('<pb-view-annotate> range adjusted: %o', adjustedRange);

    this._ranges.push(clearProperties(adjustedRange));

    this.emitTo('pb-annotations-changed', {
      type: adjustedRange.type,
      text: adjustedRange.text,
      ranges: this._ranges
    });

    this._checkAnnotationColor(adjustedRange.type);

    return this._updateAnnotation(adjustedRange);
  }

  deleteAnnotation(span) {
    // delete an existing annotation element in the TEI source
    if (span.dataset.tei) {
      // first check if we have pending modifications and remove them
      const idx = this._ranges.findIndex(r => r.type === 'modify' && r.node === span.dataset.tei);

      if (idx > -1) {
        this._ranges.splice(idx, 1);
      }

      const context = span.parentNode.closest('[data-tei]');
      const range = {
        type: 'delete',
        node: span.dataset.tei,
        context: context.dataset.tei
      };

      this._ranges.push(range);
    } else {
      const teiRange = this._rangesMap.get(span);

      this._rangesMap.delete(span);

      const pos = this._ranges.indexOf(teiRange);

      console.log('<pb-view-annotate> deleting annotation %o', teiRange);

      this._ranges.splice(pos, 1);
    }

    this._deleteAnnotation(span);
  }

  _deleteAnnotation(span) {
    const newRange = document.createRange();

    for (let i = 0; i < span.childNodes.length; i++) {
      const copy = span.childNodes[i].cloneNode(true);
      span.parentNode.insertBefore(copy, span);

      if (i === 0) {
        newRange.setStartBefore(copy);
      }

      if (i === span.childNodes.length - 1) {
        newRange.setEndAfter(copy);
      }
    }

    span.parentNode.removeChild(span);
    this.emitTo('pb-annotations-changed', {
      ranges: this._ranges
    });
    window.requestAnimationFrame(() => this.refreshMarkers());

    const selection = this._getSelection();

    selection.removeAllRanges();
    selection.addRange(newRange);
  }

  editAnnotation(span, properties) {
    if (span.dataset.type === 'edit') {
      let range = this._rangesMap.get(span);

      if (range) {
        range.properties = properties;
        range = clearProperties(range);
        this.emitTo('pb-annotations-changed', {
          ranges: this._ranges
        });
      } else {
        console.error('no range found for edit span %o', span);
      }
    } else if (span.dataset.tei) {
      // TODO: check in _ranges if it has already been modified
      const context = span.closest('[data-tei]');

      let range = this._ranges.find(r => r.type === 'modify' && r.node === span.dataset.tei);

      if (!range) {
        range = {
          type: 'modify',
          node: span.dataset.tei,
          context: context.dataset.tei
        };

        this._ranges.push(range);
      }

      range.properties = properties;
      range = clearProperties(range);
      this.emitTo('pb-annotations-changed', {
        ranges: this._ranges
      });
    }

    const jsonOld = JSON.parse(span.dataset.annotation);
    const json = Object.assign(jsonOld || {}, properties);
    span.dataset.annotation = JSON.stringify(json);

    if (json[this.getKey(span.dataset.type)] !== '') {
      span.classList.remove('incomplete');
    }
  }

  _editAnnotation(ev) {
    this.editAnnotation(ev.detail.target, ev.detail.properties);
  }
  /**
   *
   * @returns {Range|null} the selected range, if any
   */


  _selectedRange(selection) {
    if (!selection || selection.rangeCount === 0) {
      return null;
    }

    if (selection.anchorNode.getRootNode() !== this.shadowRoot) {
      return null;
    }

    const range = selection.getRangeAt(0);

    if (range.collapsed) {
      return null;
    }

    return range;
  }

  _cancelPendingCallback() {
    if (this._pendingCallback) {
      clearTimeout(this._pendingCallback);
      this._pendingCallback = null;
    }
  }

  _createTooltip(span) {
    if (span._tippy || !span.dataset.annotation) {
      return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'annotation-popup';
    const info = document.createElement('div');
    info.className = 'info';
    wrapper.appendChild(info);
    const div = document.createElement('div');
    div.className = 'toolbar';
    const typeInd = document.createElement('span');
    typeInd.className = 'annotation-type';
    div.appendChild(typeInd);

    if (span.dataset.annotation) {
      const editBtn = document.createElement('paper-icon-button');
      editBtn.setAttribute('icon', 'icons:create');
      editBtn.setAttribute('title', get$1('annotations.edit'));
      editBtn.addEventListener('click', () => {
        const data = JSON.parse(span.dataset.annotation);
        this.emitTo('pb-annotation-edit', Object.assign({}, {
          target: span,
          type: span.dataset.type,
          properties: data
        }));
      });
      div.appendChild(editBtn);
    }

    const delBtn = document.createElement('paper-icon-button');
    delBtn.setAttribute('icon', 'icons:delete');
    delBtn.setAttribute('title', get$1('annotations.delete'));
    delBtn.addEventListener('click', () => {
      this.saveHistory();
      this.deleteAnnotation(span);
    });
    div.appendChild(delBtn);
    wrapper.appendChild(div);
    const root = this.shadowRoot.getElementById('view');
    tippy(span, {
      content: wrapper,
      allowHTML: true,
      interactive: true,
      appendTo: root.nodeType === Node.DOCUMENT_NODE ? document.body : root,
      theme: 'light-border',
      hideOnClick: false,
      maxWidth: 'auto',
      trigger: 'click',
      placement: 'left',
      popperOptions: {
        modifiers: [{
          name: 'flip',
          options: {
            fallbackPlacements: ['right', 'top', 'bottom']
          }
        }]
      },
      onTrigger: (instance, ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const type = span.dataset.type;
        const data = JSON.parse(span.dataset.annotation) || {};

        const color = this._annotationColors.get(type);

        typeInd.innerHTML = type;
        typeInd.style.backgroundColor = `var(--pb-annotation-${type})`;
        typeInd.style.color = `var(${color && color.isLight ? '--pb-color-primary' : '--pb-color-inverse'})`;

        if (data[this.getKey(type)]) {
          this.emitTo('pb-annotation-detail', {
            type,
            id: data[this.getKey(type)],
            container: info,
            span
          });
        } else {
          // show properties as key/value table
          info.innerHTML = '';
          const keys = Object.keys(data);

          if (keys.length === 0) {
            const p = document.createElement('p');
            p.innerHTML = get$1('annotations.no-properties');
            info.appendChild(p);
          } else {
            const table = document.createElement('table');
            keys.forEach(key => {
              const tr = document.createElement('tr');
              const tdKey = document.createElement('td');
              tdKey.innerHTML = key;
              tr.appendChild(tdKey);
              const tdValue = document.createElement('td');
              tdValue.innerHTML = JSON.stringify(data[key], null, 2);
              tr.appendChild(tdValue);
              table.appendChild(tr);
            });
            info.appendChild(table);
          }
        }
      },
      onClickOutside: (instance, ev) => {
        instance.hideWithInteractivity(ev);
      }
    });
  }
  /**
   * Create a marker for an annotation. Position it absolute next to the annotation.
   *
   * @param {HTMLElement} span the span for which to display the marker
   * @param {DOMRectList} rootRect element with relative position
   * @param {Number} margin additional margin to avoid overlapping markers
   */


  _showMarker(span, root, rootRect, margin = 0) {
    const rects = span.getClientRects();
    const type = span.dataset.type;

    for (let i = 0; i < rects.length; i++) {
      const rect = rects[i];
      const marker = document.createElement('div');
      marker.className = `marker annotation-${type}`;
      marker.style.position = 'absolute';
      marker.style.left = `${rect.left - rootRect.left}px`;
      marker.style.top = `${rect.top - rootRect.top + rect.height}px`;
      marker.style.marginTop = `${margin}px`;
      marker.style.width = `${rect.width}px`;
      marker.style.height = `3px`;
      marker.style.backgroundColor = `var(--pb-annotation-${type})`;
      marker.part = 'annotation';
      root.appendChild(marker);
    }

    this._createTooltip(span);
  }

  _clearMarkers() {
    this.shadowRoot.getElementById('marker-layer').innerHTML = '';
  }
  /**
   * For all annotations currently shown, create a marker element and position
   * it absolute next to the annotation
   *
   * @param {HTMLElement} root element containing the markers
   */


  refreshMarkers() {
    const root = this.shadowRoot.getElementById('view');
    const rootRect = root.getBoundingClientRect();
    const markerLayer = this.shadowRoot.getElementById('marker-layer');
    markerLayer.style.display = 'none';

    this._clearMarkers();

    root.querySelectorAll('.annotation').forEach(span => {
      if (span._tippy) {
        span._tippy.destroy();
      }

      this._showMarker(span, markerLayer, rootRect, ancestors(span, 'annotation') * 5);
    });
    markerLayer.style.display = 'block';
  }

  search(type, tokens) {
    function escape(token) {
      let regex = token.replace(/[/.?+*\\]/g, m => `\\${m}`).replace(/[\s\n\t]+/g, '\\s+');

      if (/^\w/.test(regex)) {
        regex = `\\b${regex}`;
      }

      if (/\w$/.test(regex)) {
        regex = `${regex}\\b`;
      }

      return regex;
    }

    function filter(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        return NodeFilter.FILTER_ACCEPT;
      }

      if (node.classList.contains('annotation-popup')) {
        return NodeFilter.FILTER_REJECT;
      }

      return NodeFilter.FILTER_SKIP;
    }

    filter.acceptNode = filter;
    const result = [];

    if (!tokens || tokens.length === 0) {
      return result;
    }

    const expr = tokens.filter(token => token && token.length > 0).map(token => escape(token)).join('|');
    console.log(`<pb-view-annotate> Searching content for ${expr}...`);
    const regex = new RegExp(expr, this.caseSensitive ? 'g' : 'gi');
    const walker = document.createTreeWalker(this.shadowRoot.getElementById('view'), NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, filter);

    while (walker.nextNode()) {
      let node = walker.currentNode;
      const matches = Array.from(node.textContent.matchAll(regex));

      for (const match of matches) {
        const end = match.index + match[0].length;
        let isAnnotated = false;
        let ref = null;
        const annoData = node.parentNode.dataset.annotation;
        const annoType = node.parentNode.dataset.type;

        if (annoData && annoType) {
          const parsed = JSON.parse(annoData) || {};
          isAnnotated = annoType === type;
          ref = parsed[this.getKey(type)];
        }

        const startRange = rangeToPoint(node, match.index);
        const endRange = rangeToPoint(node, end, 'end');
        const [str, start] = collectText(node);
        const entry = {
          annotated: isAnnotated,
          context: startRange.parent,
          start: startRange.offset,
          end: endRange.offset,
          textNode: node,
          kwic: kwicText(str, start + match.index, start + end)
        };
        entry[this.getKey(type)] = ref;
        result.push(entry);
      }
    }

    return result;
  }

  scrollTo(teiRange) {
    const root = this.shadowRoot.getElementById('view');
    const range = document.createRange();

    if (teiRange.annotated) {
      range.selectNode(teiRange.textNode);
    } else {
      const context = Array.from(root.querySelectorAll(`[data-tei="${teiRange.context}"]`)).filter(node => node.closest('pb-popover') === null && node.getAttribute('rel') !== 'footnote')[0];
      const startPoint = pointToRange(context, teiRange.start);
      const endPoint = pointToRange(context, teiRange.end);
      range.setStart(startPoint[0], startPoint[1]);
      range.setEnd(endPoint[0], endPoint[1]);
    }

    const rootRect = root.getBoundingClientRect();
    const rect = range.getBoundingClientRect();
    let marker = root.querySelector('[part=highlight]');

    if (!marker) {
      marker = document.createElement('div');
      marker.part = 'highlight';
      marker.style.position = 'absolute';
      root.appendChild(marker);
    }

    marker.style.left = `${rect.left - rootRect.left - 4}px`;
    marker.style.top = `${rect.top - rootRect.top - 4}px`;
    marker.style.width = `${rect.width + 4}px`;
    marker.style.height = `${rect.height}px`;
    range.startContainer.parentNode.scrollIntoView(true);
  }

  hideMarker() {
    const root = this.shadowRoot.getElementById('view');
    const marker = root.querySelector('[part=highlight]');

    if (marker) {
      marker.style.top = '-1000px';
    }
  }

  _markIncompleteAnnotations() {
    const elem = this.shadowRoot.getElementById('view');
    elem.querySelectorAll('.annotation.authority').forEach(annotation => {
      if (annotation.dataset.type) {
        const data = JSON.parse(annotation.dataset.annotation);
        const key = this.getKey(annotation.dataset.type);

        if (!data[key] || data[key].length === 0) {
          annotation.classList.add('incomplete');
        }
      }
    });
  }

  _initAnnotationColors() {
    this._annotationColors = new Map();
    const types = new Set();
    const elem = this.shadowRoot.getElementById('view');
    elem.querySelectorAll('.annotation').forEach(annotation => {
      if (annotation.dataset.type) {
        types.add(annotation.dataset.type);
      }
    });
    types.forEach(type => {
      this._annotationColors.set(type, uniqolor(`annotation-${type.repeat(4)}`, {
        saturation: 70,
        lightness: [30, 60]
      }));
    });
    this.emitTo('pb-annotation-colors', {
      colors: this._annotationColors
    });
  }

  _checkAnnotationColor(type) {
    if (this._annotationColors.has(type)) {
      return;
    }

    this._annotationColors.set(type, uniqolor(`annotation-${type.repeat(4)}`, {
      saturation: 70,
      lightness: [30, 60]
    }));

    this._annotationStyles();

    this.emitTo('pb-annotation-colors', {
      colors: this._annotationColors
    });
  }

  _annotationStyles() {
    const view = this.shadowRoot.getElementById('view');
    let styles = view.querySelector('_annotation-styles');

    if (styles) {
      styles.parentNode.removeChild(styles);
    }

    const colorDefs = [];
    const classes = [];

    this._annotationColors.forEach((color, type) => {
      colorDefs.push(`--pb-annotation-${type}: ${color.color};`);
      colorDefs.push(`--pb-annotation-${type}-border: 2px solid var(--pb-annotation-${type});`);
      classes.push(`
        .annotation-${type}::after {
          background-color: var(--pb-annotation-${type});
          border-color: var(--pb-annotation-${type});
          color: var(${color.isLight ? '--pb-color-primary' : '--pb-color-inverse'});
        }
        .annotation-${type}.incomplete::after {
          background: repeating-linear-gradient(
            315deg,
            var(--pb-annotation-${type}),
            var(--pb-annotation-${type}) 5px,
            var(${color.isLight ? '--pb-annotation-stripes-light' : '--pb-annotation-stripes-dark'}) 5px,
            var(${color.isLight ? '--pb-annotation-stripes-light' : '--pb-annotation-stripes-dark'}) 10px
          );
          color: var(${color.isLight ? '--pb-color-primary' : '--pb-color-inverse'});
        }
      `);
    });

    const css = `
      :host {
        ${colorDefs.join('\n')}
      }

      ${classes.join('\n')}
    `;
    styles = document.createElement('style');
    styles.className = '_annotation-styles';
    styles.innerHTML = css;
    view.insertBefore(styles, view.firstChild);
  }

  static get styles() {
    return [super.styles, css`
        .annotation-type {
            display: inline-block;
            text-align: right;
            padding: 4px;
        }

        .annotation-popup .toolbar {
            margin-top: 1em;
        }

        .annotation-popup table {
          width: 100%;
        }

        .annotation-popup td:nth-child(1) {
          font-weight: bold;
        }

        .annotation-popup td:nth-child(1)::after {
          content: ': ';
        }

        .annotation {
            pointer-events: none;
            cursor: pointer;
        }

        .annotation::after {
            content: attr(data-type);
            margin-left: 4px;
            pointer-events: all;
            font-family: var(--pb-base-font-family);
            font-size: .8rem;
            font-style: normal;
            font-weight: normal;
            text-decoration: none;
            font-variant: normal;
            padding: 2px;
        }

        [part=highlight] {
          border: 3px solid rgb(255, 174, 0);
          border-radius: 8px;
        }`];
  }

}
customElements.define('pb-view-annotate', PbViewAnnotate);

/**
 * Zoom button to enlarge/shrink the font for the views. This component does not
 * implement any functionality itself, but just emits a `pb-zoom` event.
 *
 * @fires pb-zoom - sends an event for e.g. pb-views to react to
 */

class PbZoom extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The icon to use
       */
      icon: {
        type: String
      },

      /**
       * Either 'in' or 'out'
       */
      direction: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.icon = "icons:zoom-in";
    this.direction = 'in';
  }

  connectedCallback() {
    super.connectedCallback();
  }

  _handleClick() {
    this.emitTo('pb-zoom', {
      direction: this.direction
    });
  }

  render() {
    return html$1`
            <paper-icon-button icon="${this.icon}" @click="${this._handleClick}"></paper-icon-button>
        `;
  }
  /**
   * Fired when the user clicks the element.
   *
   * @event pb-zoom
   * @param {String} direction: either 'in' or 'out'
   */


}
customElements.define('pb-zoom', PbZoom);

/**
 * A drawer component used e.g. for table-of-contents.
 *
 * @slot - unnamed default slot for the content
 * @fires pb-load - Fires a load request when opened
 * @fires pb-refresh - When received, closes the drawer
 * @cssprop [--pb-drawer-width=448px] - width of the drawer
 * @cssprop [--pb-drawer-transition=.5s] - transition to use for sliding in
 * @csspart content - the inner div wrapping around the drawer content
 */

class PbDrawer extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * optional id reference to a component that allows opening/closing the drawer.
       * If `maxWidth` is set and the viewport width is larger, the toggle's display
       * style will be set to 'none'.
       */
      toggle: {
        type: String
      },

      /**
       * Boolean reflecting the opened/closed state of the drawer
       */
      opened: {
        type: Boolean,
        reflect: true
      },

      /**
       * Defines a breakpoint width: if the viewport width is below the width given in
       * this property, the drawer is turned into an overlay, which only reveals if the
       * toggle is activated.
       */
      maxWidth: {
        type: String,
        attribute: 'max-width'
      },

      /**
       * Determines the position at which the drawer will appear in overlay mode.
       * Should be either 'left' or 'right'.
       */
      position: {
        type: String,
        reflect: true
      }
    });
  }

  constructor() {
    super();
    this.opened = false;
    this.position = 'left';
  }

  connectedCallback() {
    super.connectedCallback();
    const toggle = this.toggle ? document.getElementById(this.toggle) : null;

    if (toggle) {
      toggle.addEventListener('click', this._toggle.bind(this));
    }

    document.body.addEventListener('click', () => {
      if (this.opened) {
        this.opened = false;
      }
    });
    this.addEventListener('click', ev => ev.stopPropagation());
    this.subscribeTo('pb-refresh', this._close.bind(this));
  }

  firstUpdated() {
    if (!this.maxWidth) {
      this.classList.add('overlay');
      return;
    } // Check if Visual Viewport API is supported


    if (typeof window.visualViewport !== 'undefined') {
      window.visualViewport.addEventListener('resize', () => {
        this._handleResize();
      });
    } else {
      window.addEventListener('resize', () => {
        this._handleResize();
      });
    }

    this._handleResize();
  }

  _handleResize() {
    const toggle = document.getElementById(this.toggle);
    const query = `(max-width: ${this.maxWidth})`;

    if (window.matchMedia(query).matches) {
      console.log('<pb-drawer> entering overlay mode');
      this.classList.add('overlay');

      if (toggle) {
        toggle.style.display = '';
      }
    } else {
      console.log('<pb-drawer> leaving overlay mode');
      this.classList.remove('overlay');

      if (toggle) {
        toggle.style.display = 'none';
      }
    }
  }

  _toggle(ev) {
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
    }

    if (this.opened) {
      this.opened = false;
    } else {
      this.opened = true;
      this.emitTo('pb-load');
    }
  }

  _close() {
    this.opened = false;
  }

  render() {
    return html$1`
            <div part="content"><slot></slot></div>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            :host(.overlay) {
                position: fixed;
                bottom: 0;
                width: var(--pb-drawer-width, 448px);
                height: 100vh;
                z-index: 1000;
                overflow: auto;
                display: block;
                transition: var(--pb-drawer-transition, .5s);
            }
            :host(.overlay[position="left"]) {
                left: calc(0px - var(--pb-drawer-width, 448px));
            }
            :host(.overlay[position="right"]) {
                right: calc(0px - var(--pb-drawer-width, 448px));
            }

            :host([opened][position="left"]) {
                left: 0;
                transition: var(--pb-drawer-transition, .5s);
            }
            :host([opened][position="right"]) {
                right: 0;
                transition: var(--pb-drawer-transition, .5s);
            }

            div {
                padding: 10px;
            }
        `;
  }

}
customElements.define('pb-drawer', PbDrawer);

/**
 * Show or hide contents depending on a media query. This is used to toggle the menubar and drawer.
 * On small displays, the menu will move into the drawer.
 *
 * @slot - default unnamed slot
 * 
 */

class PbMediaQuery extends LitElement {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * Media query to be watched by the element.
       *
       * Can be modified at run time by setting a new value.
       */
      query: {
        type: String
      },
      match: {
        type: Boolean,
        reflect: true
      }
    });
  }

  constructor() {
    super();
    this.query = '(max-width:460px)';
    this.match = false;
  }

  firstUpdated() {
    // Check if Visual Viewport API is supported
    if (typeof window.visualViewport !== 'undefined') {
      window.visualViewport.addEventListener('resize', () => {
        this._handleResize();
      });
    } else {
      window.addEventListener('resize', () => {
        this._handleResize();
      });
    }

    this._handleResize();
  }

  _handleResize() {
    let {
      query
    } = this;

    if (!/\(.*\)$/.test(query)) {
      query = `(${query})`;
    }

    if (window.matchMedia(query).matches) {
      // From no match to match
      if (this.match === false) {
        this.dispatchEvent(new CustomEvent('changed', {
          detail: {
            value: true
          },
          composed: true,
          bubbles: true
        }));
        this.match = true;
      }
    } else if (this.match === true) {
      this.dispatchEvent(new CustomEvent('changed', {
        detail: {
          value: false
        },
        composed: true,
        bubbles: true
      }));
      this.match = false;
    }
  }

  render() {
    return html$1`
            ${this.match ? html$1`<slot></slot>` : null}
        `;
  }

  static get styles() {
    return css`
            :host {
                display: inherit;
            }
        `;
  }

}
customElements.define('pb-media-query', PbMediaQuery);

/**
 * A custom form element which loads the actual form from a server-side script using AJAX.
 * Emits `pb-search-resubmit` and `pb-submit` events, signalling the receiver that it should
 * refresh.
 *
 * The component is currently used to implement the additional search facets on the start and
 * search result page. It can also be combined with `pb-split-list` to contain an additional form
 * with options.
 *
 * @fires pb-custom-form-loaded - Fired before the element updates its content
 * @fires pb-search-resubmit - Fired when the form is submitted
 * @fires pb-submit - Fired when the form is submitted
 */

class PbCustomForm extends PbLoad {
  firstUpdated() {
    this.shadowRoot.getElementById('ironform').addEventListener('iron-form-presubmit', ev => {
      ev.preventDefault();

      this._submit();
    });
    this.addEventListener('click', e => {
      if (e.target.slot === 'searchButtonTop') {
        this.submit();
      }

      if (e.target.slot === 'searchButtonBottom') {
        this.submit();
      }

      if (e.target.slot === 'resetButton') {
        this._reset();
      }
    });

    this._submissionHandlers();
  }

  render() {
    return html$1`
            <iron-form id="ironform">
                <form action="" accept="text/html" method="GET">
                    <slot name="searchButtonTop"></slot>
                    <slot></slot>
                    <slot name="searchButtonBottom"></slot>
                    <slot name="resetButton"></slot>
                </form>
            </iron-form>

            <iron-ajax
                id="loadContent"
                verbose
                handle-as="text"
                method="get"
                with-credentials
                @response="${this._handleContent}"
                @error="${this._handleError}"></iron-ajax>
            <paper-dialog id="errorDialog">
                <h2>Error</h2>
                <paper-dialog-scrollable></paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm="dialog-confirm" autofocus="autofocus">
                        Close
                    </paper-button>
                </div>
            </paper-dialog>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
        `;
  }

  submit() {
    this.shadowRoot.getElementById('ironform').submit();
  }

  _submit() {
    const json = this.serializeForm();
    this.emitTo('pb-search-resubmit', {
      params: json
    });
    this.emitTo('pb-submit', {
      params: json
    });
  }

  _reset() {
    this.shadowRoot.getElementById('ironform').reset();
  }

  serializeForm() {
    return this.shadowRoot.getElementById('ironform').serializeForm();
  }

  _parseHeaders(xhr) {// overwrite to avoid `pb-results-received` event being sent
  }

  _onLoad(content) {
    super._onLoad(content);

    this.dispatchEvent(new CustomEvent('pb-custom-form-loaded', {
      detail: content
    }));
  }

  _submissionHandlers() {
    if (!this.autoSubmit) {
      return;
    }

    this.querySelectorAll(this.autoSubmit).forEach(control => {
      const name = control.nodeName.toLowerCase();
      let event = 'change';

      if (control instanceof HTMLButtonElement || name === 'paper-icon-button' || name === 'paper-button' || name === 'input' && (control.type === 'button' || control.type === 'submit' || control.type === 'reset')) {
        event = 'click';
      } else if (name === 'paper-input' || control instanceof HTMLInputElement && control.type === 'text') {
        event = 'keyup';
      } else if (name === 'paper-dropdown-menu') {
        event = 'value-changed';
      }

      control.addEventListener(event, this._submit.bind(this));
    });
  }

  static get properties() {
    return Object.assign({
      /**
       * Register event handlers on all inputs and submit the form
       * automatically if any of those changes. For button-like controls,
       * a submit is triggered on click, for text input on keyUp, and for
       * all other form components on change.
       */
      autoSubmit: {
        type: String,
        attribute: 'auto-submit'
      }
    }, super.properties);
  }
  /**
   * Fired before the element updates its content
   *
   * @event pb-custom-form-loaded
   * @param {string} the loaded content
   */

  /**
   * Fired when form is submitted
   *
   * @event pb-search-resubmit
   * @param {object} params: serialized form parameters as json object
   */


}
customElements.define('pb-custom-form', PbCustomForm);

/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */

(function (factory) {
  var registeredInModuleLoader;

  if (typeof define === 'function' && define.amd) {
    define(factory);
    registeredInModuleLoader = true;
  }

  if (typeof exports === 'object') {
    module.exports = factory();
    registeredInModuleLoader = true;
  }

  if (!registeredInModuleLoader) {
    var OldCookies = window.Cookies;
    var api = window.Cookies = factory();

    api.noConflict = function () {
      window.Cookies = OldCookies;
      return api;
    };
  }
})(function () {
  function extend() {
    var i = 0;
    var result = {};

    for (; i < arguments.length; i++) {
      var attributes = arguments[i];

      for (var key in attributes) {
        result[key] = attributes[key];
      }
    }

    return result;
  }

  function decode(s) {
    return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
  }

  function init(converter) {
    function api() {}

    function set(key, value, attributes) {
      if (typeof document === 'undefined') {
        return;
      }

      attributes = extend({
        path: '/'
      }, api.defaults, attributes);

      if (typeof attributes.expires === 'number') {
        attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
      } // We're using "expires" because "max-age" is not supported by IE


      attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

      try {
        var result = JSON.stringify(value);

        if (/^[\{\[]/.test(result)) {
          value = result;
        }
      } catch (e) {}

      value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
      key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
      var stringifiedAttributes = '';

      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue;
        }

        stringifiedAttributes += '; ' + attributeName;

        if (attributes[attributeName] === true) {
          continue;
        } // Considers RFC 6265 section 5.2:
        // ...
        // 3.  If the remaining unparsed-attributes contains a %x3B (";")
        //     character:
        // Consume the characters of the unparsed-attributes up to,
        // not including, the first %x3B (";") character.
        // ...


        stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
      }

      return document.cookie = key + '=' + value + stringifiedAttributes;
    }

    function get(key, json) {
      if (typeof document === 'undefined') {
        return;
      }

      var jar = {}; // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all.

      var cookies = document.cookie ? document.cookie.split('; ') : [];
      var i = 0;

      for (; i < cookies.length; i++) {
        var parts = cookies[i].split('=');
        var cookie = parts.slice(1).join('=');

        if (!json && cookie.charAt(0) === '"') {
          cookie = cookie.slice(1, -1);
        }

        try {
          var name = decode(parts[0]);
          cookie = (converter.read || converter)(cookie, name) || decode(cookie);

          if (json) {
            try {
              cookie = JSON.parse(cookie);
            } catch (e) {}
          }

          jar[name] = cookie;

          if (key === name) {
            break;
          }
        } catch (e) {}
      }

      return key ? jar[key] : jar;
    }

    api.set = set;

    api.get = function (key) {
      return get(key, false
      /* read as raw */
      );
    };

    api.getJSON = function (key) {
      return get(key, true
      /* read as json */
      );
    };

    api.remove = function (key, attributes) {
      set(key, '', extend(attributes, {
        expires: -1
      }));
    };

    api.defaults = {};
    api.withConverter = init;
    return api;
  }

  return init(function () {});
});

/**
 * Generate a link to download a resource. Optionally shows a dialog during the download.
 * This component is mainly used for creating the links for downloading PDFs, epubs etc.
 *
 * @slot - unnamed default slot for link text
 * @fires pb-document - When received, updates the odd to the one passed from the event
 * @cssprop --pb-download-color - Color of the download title label
 * @cssprop --pb-download-text-decoration - Extra effects for the download title label
 */

class PbDownload extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * optional id reference to a pb-document. If `url` is not specified, 
       * a correct download URL is constructed using the given document path and parameters.
       * Otherwise `url` will be used as main URL.
       */
      src: {
        type: String
      },

      /**
       * the base URL to construct the link from. If specified, only the ODD and optional parameters
       * will be appended to the URL.
       */
      url: {
        type: String
      },

      /**
       * optional suffix to append to the constructed URL. Use for getting a PDF, epub or similar.
       */
      type: {
        type: String
      },

      /**
       * extra odd parameter to be added. This will correspond to the ODD used by the document, if given.
       */
      odd: {
        type: String
      },

      /**
       * id of dialog component to show when downloading. A paper-dialog component with this id must
       * exist.
       */
      dialog: {
        type: String
      },

      /**
       * title to show in the dialog while download is in progress
       */
      title: {
        type: String
      },

      /**
       * add a special parameter 'source=yes' if true. For PDF this will result
       * in generated source code to be displayed
       */
      source: {
        type: Boolean
      },

      /**
       *  extra params to be added
       */
      params: {
        type: String
      },
      _target: {
        type: String,
        reflect: true
      },
      _href: {
        type: String,
        reflect: true
      },
      _token: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.source = false;
    this._target = '_self';
    this.type = '';
  }

  firstUpdated() {
    if (this.src) {
      this.subscribeTo('pb-document', ev => {
        if (ev.detail.id === this.src) {
          this.odd = ev.detail.odd;
        }
      });
    }

    this.subscribeTo('pb-refresh', ev => {
      if (ev.detail.odd) {
        this.odd = ev.detail.odd;
        this._href = this._computeURL();
      }
    });
    PbDownload.waitOnce('pb-page-ready', () => {
      this._target = this._computeTarget();
      this._href = this._computeURL();
    });
  }

  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);

    if (!oldVal) {
      return;
    }

    switch (name) {
      case 'source':
        this._target = this._computeTarget();
        break;

      case 'src':
      case 'type':
      case 'file':
      case 'odd':
      case 'params':
      case 'url':
        this._href = this._computeURL();
        break;
    }
  }

  render() {
    return html$1`
            <a id="button" @click="${this._handleClick}" title="${this.title}" target="${this._target}" href="${this._href}"><slot></slot></a>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: inline-block;
            }

            a {
                text-decoration: var(--pb-download-text-decoration, none);
                color: var(--pb-download-color);
            }
        `;
  }

  _computeTarget() {
    return this.source ? '_blank' : '_self';
  }

  _computeURL() {
    this._token = new Date().getTime() * 797;
    let url;
    const doc = this.getDocument();

    if (doc) {
      if (this.url) {
        url = `${this.toAbsoluteURL(this.url)}?odd=${this.odd ? this.odd : doc.odd}.odd`;
      } else {
        const serverPart = `${this.getEndpoint()}/`;

        if (this.lessThanApiVersion('1.0.0')) {
          url = `${doc.getFileName()}${this.type ? `.${this.type}` : ''}?odd=${this.odd ? this.odd : doc.odd}.odd&cache=no&token=${this._token}`;
        } else {
          url = `${serverPart}api/document/${encodeURIComponent(doc.path)}/${this.type || 'html'}?odd=${this.odd ? this.odd : doc.odd}.odd&token=${this._token}`;
        }
      }
    } else {
      url = /^(?:[a-z]+:)?\/\//i.test(this.url) ? this.url : `${this.getEndpoint()}/${this.url}`;

      if (this.lessThanApiVersion('1.0.0')) {
        url = `${url}${this.type ? `.${this.type}` : ''}?odd=${this.odd}&cache=no&token='${this._token}`;
      } else {
        url = `${url}/${this.type}?odd=${this.odd}&token='${this._token}`;
      }
    }

    if (this.params) {
      url += `&${this.params}`;
    }

    if (this.source) {
      url += '&source=true';
    }

    return url;
  }
  /**
   *
   * triggers a document download
   *
   * @param ev
   * @private
   */


  _handleClick(ev) {
    if (this.dialog) {
      const dialog = document.getElementById(this.dialog); //todo: this will error when dialog is not found or defined on element.

      dialog.open();
      const token = this._token;
      const downloadCheck = window.setInterval(() => {
        const cookieValue = Cookies.get("simple.token");

        if (cookieValue === token) {
          window.clearInterval(downloadCheck);
          Cookies.remove("simple.token");
          dialog.close();
        }
      });
    }

    if (this._target === '_self') {
      ev.preventDefault();
      window.location = this._href;
    }
  }

}
customElements.define('pb-download', PbDownload);

/**
 * Handles login/logout. Shows a link which opens a login dialog if clicked.
 * If a user is logged in, clicking the link will log him out instead.
 *
 * @slot information - Additional information to be presented on the login dialog
 * @fires pb-login - Sends results of checking user credentials
 * @cssprop --pb-login-link-color - Color of the link text
 * @csspart message-invalid - Block displayed if login is invalid
 * @csspart group-invalid - Text displayed if login is invalid concerning group
 */

class PbLogin extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** True if user is currently logged in */
      loggedIn: {
        type: Boolean,
        attribute: 'logged-in',
        reflect: true
      },

      /**
       * The currently logged in user.
       */
      user: {
        type: String
      },
      password: {
        type: String
      },

      /**
       * If set, only users being members of the specified group are
       * allowed to log in.
       */
      group: {
        type: String
      },

      /**
       * Array of groups the current user is a member of.
       */
      groups: {
        type: Array
      },

      /**
       * If set to true, automatically show login dialog if user is not logged in
       */
      auto: {
        type: Boolean
      },

      /**
       * Label to show if not logged in
       */
      loginLabel: {
        type: String,
        reflect: true,
        attribute: 'login-label'
      },

      /**
       * Label to show before user name if logged in
       */
      logoutLabel: {
        type: String,
        reflect: true,
        attribute: 'logout-label'
      },
      loginIcon: {
        type: String,
        attribute: 'login-icon'
      },
      logoutIcon: {
        type: String,
        attribute: 'logout-icon'
      },
      _invalid: {
        type: Boolean
      },
      _hasFocus: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.loggedIn = false;
    this.loginLabel = 'login.login';
    this.logoutLabel = 'login.as';
    this.user = '';
    this.groups = [];
    this.loginIcon = 'account-circle';
    this.logoutIcon = 'supervisor-account';
    this._hasFocus = true;
  }

  firstUpdated() {
    super.firstUpdated();
    this._checkLogin = this.shadowRoot.getElementById('checkLogin');
    this._loginDialog = this.shadowRoot.getElementById('loginDialog');
    window.addEventListener('blur', () => {
      this._hasFocus = false;
    });
    window.addEventListener('focus', () => {
      if (!this._hasFocus) {
        this._hasFocus = true;
        this._checkLogin.body = null;

        this._checkLogin.generateRequest();
      }
    });
    PbLogin.waitOnce('pb-page-ready', detail => {
      if (minVersion(detail.apiVersion, '1.0.0')) {
        this._checkLogin.url = `${detail.endpoint}/api/login/`;
      } else {
        this._checkLogin.url = `${detail.endpoint}/login`;
      }

      this._checkLogin.body = {
        user: this.user,
        password: this.password
      };

      this._checkLogin.generateRequest();
    });
  }

  render() {
    return html$1`
            <a href="#" @click="${this._show}" title="${this.user}">
                ${this.loggedIn ? html$1`<iron-icon icon="${this.logoutIcon}"></iron-icon> <span class="label">${translate(this.logoutLabel, {
      user: this.user
    })}</span>` : html$1`<iron-icon icon="${this.loginIcon}"></iron-icon> <span class="label">${translate(this.loginLabel)}</span>`}                
            </a>

            <paper-dialog id="loginDialog">
                <h2>${translate('login.login')}</h2>
                <paper-dialog-scrollable>
                    <form action="login">
                        <paper-input id="user" name="user" label="${translate('login.user')}" value="${this.user}" autofocus></paper-input>
                        <paper-input id="password" name="password" label="${translate('login.password')}" type="password"></paper-input>
                        <input id="logout" type="hidden" name="logout"></input>
                    </form>
                    <slot name="information"></slot>
                    ${this._invalid ? html$1`
                            <p id="message" part="message-invalid">${translate('login.invalid')}<span part="group-invalid">${this.group ? html$1` (${translate('login.requiredGroup', {
      group: this.group
    })})` : null}</span>.
                            </p>
                        ` : null}
                </paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button autofocus @click="${this._confirmLogin}">${translate(this.loginLabel)}</paper-button>
                </div>
            </paper-dialog>

            <iron-ajax id="checkLogin" with-credentials
                handle-as="json" @response="${this._handleResponse}" @error="${this._handleError}"
                method="post"
                content-type="application/x-www-form-urlencoded"></iron-ajax>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            paper-dialog {
                min-width: 320px;
                max-width: 640px;
                min-height: 128px;
            }

            paper-dialog h2 {
                background-color: #607D8B;
                padding: 16px 8px;
                margin-top: 0;
                color: #F0F0F0;
            }

            a {
                color: var(--pb-login-link-color, --pb-link-color);
                text-decoration: none;
            }

            @media (max-width: 1024px) {
                .label {
                    display: none;
                }
            }

            #message {
                color: var(--paper-red-800);
            }
        `;
  }

  _show(ev) {
    ev.preventDefault();

    if (this.loggedIn) {
      this._checkLogin.body = {
        logout: this.user
      };

      this._checkLogin.generateRequest();
    } else {
      this._loginDialog.open();
    }
  }

  _confirmLogin() {
    this.user = this.shadowRoot.getElementById('user').value;
    this.password = this.shadowRoot.getElementById('password').value;
    this._checkLogin.body = {
      user: this.user,
      password: this.password
    };

    this._checkLogin.generateRequest();
  }

  _handleResponse() {
    const resp = this._checkLogin.lastResponse;

    if (resp.user && this._checkGroup(resp)) {
      resp.userChanged = !this.loggedIn || this.user !== resp.user;
      this.loggedIn = true;
      this.user = resp.user;
      this.groups = resp.groups;
      this._invalid = false;

      this._loginDialog.close();
    } else {
      resp.userChanged = this.loggedIn;
      this.loggedIn = false;
      this.password = null;

      if (this._loginDialog.opened) {
        this._invalid = true;
      } else if (this.auto) {
        this._loginDialog.open();
      }
    }

    this.emitTo('pb-login', resp);
  }

  _handleError() {
    const resp = {
      userChanged: this.loggedIn,
      user: null
    };
    this.loggedIn = false;
    this.password = null;

    if (this._loginDialog.opened) {
      this._invalid = true;
    } else if (this.auto) {
      this._loginDialog.open();
    }

    this.emitTo('pb-login', resp);
  }

  _checkGroup(info) {
    if (this.group) {
      return info.groups && info.groups.indexOf(this.group) > -1;
    }

    return true;
  }
  /**
   * Fired on successful login.
   *
   * @event pb-login
   * @param {String} user logged in user
   * @param {Array<String>} groups groups the user is a member of
   */


}
customElements.define('pb-login', PbLogin);

/**
 * Triggers an action on the server and shows a dialog
 * upon completion. Used for the "recompile ODD" and other
 * actions.
 *
 * The parameters sent to the server-side script will be copied
 * from the `pb-view` to which this component subscribes, see pb-update event.
 *
 * @slot - unnamed slot for link text
 * @slot title - dialog title
 * 
 * @fires pb-start-update - Fired before the element updates its content
 * @fires pb-end-update - Fired after the element has finished updating its content 
 * @fires pb-update - When received, copies request parameters from the event 

 */

class PbAjax extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * the URL to send a request to
       */
      url: {
        type: String
      },

      /**
       * Title of link that triggers the request
       */
      title: {
        type: String
      },

      /**
       * HTTP method to use, e.g. 'get', 'post', 'delete' ...
       */
      method: {
        type: String
      },

      /**
       * If set, emits an event with the given name to the channel
       * this component is subscribed to.
       */
      event: {
        type: String
      },
      _message: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.method = 'get';
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-update', this._onUpdate.bind(this));
  }

  render() {
    return html$1`
            <a id="button" @click="${this._handleClick}" title="${this.title}"><slot></slot></a>
            <iron-ajax
                id="loadContent"
                verbose
                handle-as="text"
                method="${this.method}"
                with-credentials
                @error="${this._handleError}"
                @response="${this._handleResponse}"></iron-ajax>
            ${this.dialogTemplate}
        `;
  }

  get dialogTemplate() {
    return html$1`
            <paper-dialog id="messageDialog">
                <h2><slot name="title">Action</slot></h2>
                <paper-dialog-scrollable>${unsafeHTML(this._message)}</paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm="dialog-confirm" autofocus="autofocus">
                    ${translate('dialogs.close')}
                    </paper-button>
                </div>
            </paper-dialog>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
            slot[name="title"] {
                margin: 0;
            }
        `;
  }

  _handleClick(ev) {
    ev.preventDefault();
    this.trigger();
  }

  trigger() {
    const loader = this.shadowRoot.getElementById('loadContent');
    loader.url = `${this.getEndpoint()}/${this.url}`;
    this.emitTo('pb-start-update');
    this.shadowRoot.getElementById('loadContent').generateRequest();
  }

  _handleResponse() {
    const resp = this.shadowRoot.getElementById('loadContent').lastResponse;
    this._message = resp;
    const dialog = this.shadowRoot.getElementById('messageDialog');
    dialog.open();
    this.emitTo('pb-end-update');

    if (this.event) {
      this.emitTo(this.event);
    }
  }

  _handleError() {
    const loader = this.shadowRoot.getElementById('loadContent');
    const msg = loader.lastError.response;
    const parser = new DOMParser();
    const doc = parser.parseFromString(msg, "application/xml");
    const node = doc.querySelector('message');

    if (node) {
      this._message = node.textContent;
    } else {
      this._message = msg;
    }

    const dialog = this.shadowRoot.getElementById('messageDialog');
    dialog.open();
    this.emitTo('pb-end-update');
  }

  _onUpdate(ev) {
    this.shadowRoot.getElementById('loadContent').params = ev.detail.params;
  }

}
customElements.define('pb-ajax', PbAjax);

/**
 * A dropdown for switching the interface language.
 *
 * @slot - unnamed default slot for dropdown menu options
 * @fires pb-i18n-language - Sends selected language
 * @fires pb-i18n-update - When received, sets the selected language to the one received from the event
 * @cssprop --pb-lang-input-color - Color of the text in the language field
 * @cssprop --pb-lang-label-color - Color of the language field label
 */

class PbLang extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The label for a language in the dropdown
       */
      label: {
        type: String
      },
      selected: {
        type: String
      },

      /**
       * suppresses the label
       */
      nolabel: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.label = 'language';
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-i18n-update', ev => {
      this.selected = ev.detail.language.replace(/^([^-]+).*$/, '$1');
    }, []);
    PbLang.waitOnce('pb-i18n-update', options => {
      this.selected = options.language.replace(/^([^-]+).*$/, '$1');
    });
  }

  render() {
    return html$1`
            ${this.nolabel ? html$1`
                    <paper-dropdown-menu>
                        <paper-listbox id="menu" slot="dropdown-content" class="dropdown-content" selected="${this.selected}"
                            attr-for-selected="value" @selected-item-changed="${this._changed}">
                            <slot></slot>
                        </paper-listbox>
                    </paper-dropdown-menu>` : html$1`
                    <paper-dropdown-menu label="${translate(this.label)}">
                        <paper-listbox id="menu" slot="dropdown-content" class="dropdown-content" selected="${this.selected}"
                            attr-for-selected="value" @selected-item-changed="${this._changed}">
                            <slot></slot>
                        </paper-listbox>
                    </paper-dropdown-menu>`}
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
                --paper-input-container-input-color: var(--pb-lang-input-color, black);
                --paper-input-container-color: var(--pb-lang-label-color, --paper-grey-100);
            }
        `;
  }

  _changed() {
    const lang = this.shadowRoot.getElementById('menu').selected;

    if (lang !== this.selected) {
      console.log('<pb-lang> Language changed to %s', lang);
      this.emitTo('pb-i18n-language', {
        'language': lang
      });
      this.selected = lang;
    }
  }

}
customElements.define('pb-lang', PbLang);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const template$1 = html`<iron-iconset-svg name="paper-tabs" size="24">
<svg><defs>
<g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
</defs></svg>
</iron-iconset-svg>`;
document.head.appendChild(template$1.content);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
`paper-tab` is styled to look like a tab. It should be used in conjunction with
`paper-tabs`.

Example:

    <paper-tabs selected="0">
      <paper-tab>TAB 1</paper-tab>
      <paper-tab>TAB 2</paper-tab>
      <paper-tab>TAB 3</paper-tab>
    </paper-tabs>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-tab-ink` | Ink color | `--paper-yellow-a100`
`--paper-tab` | Mixin applied to the tab | `{}`
`--paper-tab-content` | Mixin applied to the tab content | `{}`
`--paper-tab-content-focused` | Mixin applied to the tab content when the tab is focused | `{}`
`--paper-tab-content-unselected` | Mixin applied to the tab content when the tab is not selected | `{}`

This element applies the mixin `--paper-font-common-base` but does not import
`paper-styles/typography.html`. In order to apply the `Roboto` font to this
element, make sure you've imported `paper-styles/typography.html`.
*/

Polymer({
  _template: html`
    <style>
      :host {
        @apply --layout-inline;
        @apply --layout-center;
        @apply --layout-center-justified;
        @apply --layout-flex-auto;

        position: relative;
        padding: 0 12px;
        overflow: hidden;
        cursor: pointer;
        vertical-align: middle;

        @apply --paper-font-common-base;
        @apply --paper-tab;
      }

      :host(:focus) {
        outline: none;
      }

      :host([link]) {
        padding: 0;
      }

      .tab-content {
        height: 100%;
        transform: translateZ(0);
          -webkit-transform: translateZ(0);
        transition: opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);
        @apply --layout-horizontal;
        @apply --layout-center-center;
        @apply --layout-flex-auto;
        @apply --paper-tab-content;
      }

      :host(:not(.iron-selected)) > .tab-content {
        opacity: 0.8;

        @apply --paper-tab-content-unselected;
      }

      :host(:focus) .tab-content {
        opacity: 1;
        font-weight: 700;

        @apply --paper-tab-content-focused;
      }

      paper-ripple {
        color: var(--paper-tab-ink, var(--paper-yellow-a100));
      }

      .tab-content > ::slotted(a) {
        @apply --layout-flex-auto;

        height: 100%;
      }
    </style>

    <div class="tab-content">
      <slot></slot>
    </div>
`,
  is: 'paper-tab',
  behaviors: [IronControlState, IronButtonState, PaperRippleBehavior],
  properties: {
    /**
     * If true, the tab will forward keyboard clicks (enter/space) to
     * the first anchor element found in its descendants
     */
    link: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },

  /** @private */
  hostAttributes: {
    role: 'tab'
  },
  listeners: {
    down: '_updateNoink',
    tap: '_onTap'
  },
  attached: function () {
    this._updateNoink();
  },

  get _parentNoink() {
    var parent = dom(this).parentNode;
    return !!parent && !!parent.noink;
  },

  _updateNoink: function () {
    this.noink = !!this.noink || !!this._parentNoink;
  },
  _onTap: function (event) {
    if (this.link) {
      var anchor = this.queryEffectiveChildren('a');

      if (!anchor) {
        return;
      } // Don't get stuck in a loop delegating
      // the listener from the child anchor


      if (event.target === anchor) {
        return;
      }

      anchor.click();
    }
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * `IronMenubarBehavior` implements accessible menubar behavior.
 *
 * @polymerBehavior IronMenubarBehavior
 */

const IronMenubarBehaviorImpl = {
  hostAttributes: {
    'role': 'menubar'
  },

  /**
   * @type {!Object}
   */
  keyBindings: {
    'left': '_onLeftKey',
    'right': '_onRightKey'
  },
  _onUpKey: function (event) {
    this.focusedItem.click();
    event.detail.keyboardEvent.preventDefault();
  },
  _onDownKey: function (event) {
    this.focusedItem.click();
    event.detail.keyboardEvent.preventDefault();
  },

  get _isRTL() {
    return window.getComputedStyle(this)['direction'] === 'rtl';
  },

  _onLeftKey: function (event) {
    if (this._isRTL) {
      this._focusNext();
    } else {
      this._focusPrevious();
    }

    event.detail.keyboardEvent.preventDefault();
  },
  _onRightKey: function (event) {
    if (this._isRTL) {
      this._focusPrevious();
    } else {
      this._focusNext();
    }

    event.detail.keyboardEvent.preventDefault();
  },
  _onKeydown: function (event) {
    if (this.keyboardEventMatchesKeys(event, 'up down left right esc')) {
      return;
    } // all other keys focus the menu item starting with that character


    this._focusWithKeyboardEvent(event);
  }
};
/** @polymerBehavior */

const IronMenubarBehavior = [IronMenuBehavior, IronMenubarBehaviorImpl];

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/**
Material design: [Tabs](https://www.google.com/design/spec/components/tabs.html)

`paper-tabs` makes it easy to explore and switch between different views or
functional aspects of an app, or to browse categorized data sets.

Use `selected` property to get or set the selected tab.

Example:

    <paper-tabs selected="0">
      <paper-tab>TAB 1</paper-tab>
      <paper-tab>TAB 2</paper-tab>
      <paper-tab>TAB 3</paper-tab>
    </paper-tabs>

See <a href="?active=paper-tab">paper-tab</a> for more information about
`paper-tab`.

A common usage for `paper-tabs` is to use it along with `iron-pages` to switch
between different views.

    <paper-tabs selected="{{selected}}">
      <paper-tab>Tab 1</paper-tab>
      <paper-tab>Tab 2</paper-tab>
      <paper-tab>Tab 3</paper-tab>
    </paper-tabs>

    <iron-pages selected="{{selected}}">
      <div>Page 1</div>
      <div>Page 2</div>
      <div>Page 3</div>
    </iron-pages>

To use links in tabs, add `link` attribute to `paper-tab` and put an `<a>`
element in `paper-tab` with a `tabindex` of -1.

Example:

<pre><code>
&lt;style is="custom-style">
  .link {
    &#64;apply --layout-horizontal;
    &#64;apply --layout-center-center;
  }
&lt;/style>

&lt;paper-tabs selected="0">
  &lt;paper-tab link>
    &lt;a href="#link1" class="link" tabindex="-1">TAB ONE&lt;/a>
  &lt;/paper-tab>
  &lt;paper-tab link>
    &lt;a href="#link2" class="link" tabindex="-1">TAB TWO&lt;/a>
  &lt;/paper-tab>
  &lt;paper-tab link>
    &lt;a href="#link3" class="link" tabindex="-1">TAB THREE&lt;/a>
  &lt;/paper-tab>
&lt;/paper-tabs>
</code></pre>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-tabs-selection-bar-color` | Color for the selection bar | `--paper-yellow-a100`
`--paper-tabs-selection-bar` | Mixin applied to the selection bar | `{}`
`--paper-tabs` | Mixin applied to the tabs | `{}`
`--paper-tabs-content` | Mixin applied to the content container of tabs | `{}`
`--paper-tabs-container` | Mixin applied to the layout container of tabs | `{}`

@demo demo/index.html
*/

Polymer({
  _template: html`
    <style>
      :host {
        @apply --layout;
        @apply --layout-center;

        height: 48px;
        font-size: 14px;
        font-weight: 500;
        overflow: hidden;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;

        /* NOTE: Both values are needed, since some phones require the value to be \`transparent\`. */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;

        @apply --paper-tabs;
      }

      :host(:dir(rtl)) {
        @apply --layout-horizontal-reverse;
      }

      #tabsContainer {
        position: relative;
        height: 100%;
        white-space: nowrap;
        overflow: hidden;
        @apply --layout-flex-auto;
        @apply --paper-tabs-container;
      }

      #tabsContent {
        height: 100%;
        -moz-flex-basis: auto;
        -ms-flex-basis: auto;
        flex-basis: auto;
        @apply --paper-tabs-content;
      }

      #tabsContent.scrollable {
        position: absolute;
        white-space: nowrap;
      }

      #tabsContent:not(.scrollable),
      #tabsContent.scrollable.fit-container {
        @apply --layout-horizontal;
      }

      #tabsContent.scrollable.fit-container {
        min-width: 100%;
      }

      #tabsContent.scrollable.fit-container > ::slotted(*) {
        /* IE - prevent tabs from compressing when they should scroll. */
        -ms-flex: 1 0 auto;
        -webkit-flex: 1 0 auto;
        flex: 1 0 auto;
      }

      .hidden {
        display: none;
      }

      .not-visible {
        opacity: 0;
        cursor: default;
      }

      paper-icon-button {
        width: 48px;
        height: 48px;
        padding: 12px;
        margin: 0 4px;
      }

      #selectionBar {
        position: absolute;
        height: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border-bottom: 2px solid var(--paper-tabs-selection-bar-color, var(--paper-yellow-a100));
          -webkit-transform: scale(0);
        transform: scale(0);
          -webkit-transform-origin: left center;
        transform-origin: left center;
          transition: -webkit-transform;
        transition: transform;

        @apply --paper-tabs-selection-bar;
      }

      #selectionBar.align-bottom {
        top: 0;
        bottom: auto;
      }

      #selectionBar.expand {
        transition-duration: 0.15s;
        transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
      }

      #selectionBar.contract {
        transition-duration: 0.18s;
        transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
      }

      #tabsContent > ::slotted(:not(#selectionBar)) {
        height: 100%;
      }
    </style>

    <paper-icon-button icon="paper-tabs:chevron-left" class$="[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onLeftScrollButtonDown" tabindex="-1"></paper-icon-button>

    <div id="tabsContainer" on-track="_scroll" on-down="_down">
      <div id="tabsContent" class$="[[_computeTabsContentClass(scrollable, fitContainer)]]">
        <div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]" on-transitionend="_onBarTransitionEnd"></div>
        <slot></slot>
      </div>
    </div>

    <paper-icon-button icon="paper-tabs:chevron-right" class$="[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]" on-up="_onScrollButtonUp" on-down="_onRightScrollButtonDown" tabindex="-1"></paper-icon-button>
`,
  is: 'paper-tabs',
  behaviors: [IronResizableBehavior, IronMenubarBehavior],
  properties: {
    /**
     * If true, ink ripple effect is disabled. When this property is changed,
     * all descendant `<paper-tab>` elements have their `noink` property
     * changed to the new value as well.
     */
    noink: {
      type: Boolean,
      value: false,
      observer: '_noinkChanged'
    },

    /**
     * If true, the bottom bar to indicate the selected tab will not be shown.
     */
    noBar: {
      type: Boolean,
      value: false
    },

    /**
     * If true, the slide effect for the bottom bar is disabled.
     */
    noSlide: {
      type: Boolean,
      value: false
    },

    /**
     * If true, tabs are scrollable and the tab width is based on the label
     * width.
     */
    scrollable: {
      type: Boolean,
      value: false
    },

    /**
     * If true, tabs expand to fit their container. This currently only applies
     * when scrollable is true.
     */
    fitContainer: {
      type: Boolean,
      value: false
    },

    /**
     * If true, dragging on the tabs to scroll is disabled.
     */
    disableDrag: {
      type: Boolean,
      value: false
    },

    /**
     * If true, scroll buttons (left/right arrow) will be hidden for scrollable
     * tabs.
     */
    hideScrollButtons: {
      type: Boolean,
      value: false
    },

    /**
     * If true, the tabs are aligned to bottom (the selection bar appears at the
     * top).
     */
    alignBottom: {
      type: Boolean,
      value: false
    },
    selectable: {
      type: String,
      value: 'paper-tab'
    },

    /**
     * If true, tabs are automatically selected when focused using the
     * keyboard.
     */
    autoselect: {
      type: Boolean,
      value: false
    },

    /**
     * The delay (in milliseconds) between when the user stops interacting
     * with the tabs through the keyboard and when the focused item is
     * automatically selected (if `autoselect` is true).
     */
    autoselectDelay: {
      type: Number,
      value: 0
    },
    _step: {
      type: Number,
      value: 10
    },
    _holdDelay: {
      type: Number,
      value: 1
    },
    _leftHidden: {
      type: Boolean,
      value: false
    },
    _rightHidden: {
      type: Boolean,
      value: false
    },
    _previousTab: {
      type: Object
    }
  },

  /** @private */
  hostAttributes: {
    role: 'tablist'
  },
  listeners: {
    'iron-resize': '_onTabSizingChanged',
    'iron-items-changed': '_onTabSizingChanged',
    'iron-select': '_onIronSelect',
    'iron-deselect': '_onIronDeselect'
  },

  /**
   * @type {!Object}
   */
  keyBindings: {
    'left:keyup right:keyup': '_onArrowKeyup'
  },
  created: function () {
    this._holdJob = null;
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
    this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
    this.addEventListener('blur', this._onBlurCapture.bind(this), true);
  },
  ready: function () {
    this.setScrollDirection('y', this.$.tabsContainer);
  },
  detached: function () {
    this._cancelPendingActivation();
  },
  _noinkChanged: function (noink) {
    var childTabs = dom(this).querySelectorAll('paper-tab');
    childTabs.forEach(noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
  },
  _setNoinkAttribute: function (element) {
    element.setAttribute('noink', '');
  },
  _removeNoinkAttribute: function (element) {
    element.removeAttribute('noink');
  },
  _computeScrollButtonClass: function (hideThisButton, scrollable, hideScrollButtons) {
    if (!scrollable || hideScrollButtons) {
      return 'hidden';
    }

    if (hideThisButton) {
      return 'not-visible';
    }

    return '';
  },
  _computeTabsContentClass: function (scrollable, fitContainer) {
    return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') : ' fit-container';
  },
  _computeSelectionBarClass: function (noBar, alignBottom) {
    if (noBar) {
      return 'hidden';
    } else if (alignBottom) {
      return 'align-bottom';
    }

    return '';
  },
  // TODO(cdata): Add `track` response back in when gesture lands.
  _onTabSizingChanged: function () {
    this.debounce('_onTabSizingChanged', function () {
      this._scroll();

      this._tabChanged(this.selectedItem);
    }, 10);
  },
  _onIronSelect: function (event) {
    this._tabChanged(event.detail.item, this._previousTab);

    this._previousTab = event.detail.item;
    this.cancelDebouncer('tab-changed');
  },
  _onIronDeselect: function (event) {
    this.debounce('tab-changed', function () {
      this._tabChanged(null, this._previousTab);

      this._previousTab = null; // See polymer/polymer#1305
    }, 1);
  },
  _activateHandler: function () {
    // Cancel item activations scheduled by keyboard events when any other
    // action causes an item to be activated (e.g. clicks).
    this._cancelPendingActivation();

    IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
  },

  /**
   * Activates an item after a delay (in milliseconds).
   */
  _scheduleActivation: function (item, delay) {
    this._pendingActivationItem = item;
    this._pendingActivationTimeout = this.async(this._bindDelayedActivationHandler, delay);
  },

  /**
   * Activates the last item given to `_scheduleActivation`.
   */
  _delayedActivationHandler: function () {
    var item = this._pendingActivationItem;
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
    item.fire(this.activateEvent, null, {
      bubbles: true,
      cancelable: true
    });
  },

  /**
   * Cancels a previously scheduled item activation made with
   * `_scheduleActivation`.
   */
  _cancelPendingActivation: function () {
    if (this._pendingActivationTimeout !== undefined) {
      this.cancelAsync(this._pendingActivationTimeout);
      this._pendingActivationItem = undefined;
      this._pendingActivationTimeout = undefined;
    }
  },
  _onArrowKeyup: function (event) {
    if (this.autoselect) {
      this._scheduleActivation(this.focusedItem, this.autoselectDelay);
    }
  },
  _onBlurCapture: function (event) {
    // Cancel a scheduled item activation (if any) when that item is
    // blurred.
    if (event.target === this._pendingActivationItem) {
      this._cancelPendingActivation();
    }
  },

  get _tabContainerScrollSize() {
    return Math.max(0, this.$.tabsContainer.scrollWidth - this.$.tabsContainer.offsetWidth);
  },

  _scroll: function (e, detail) {
    if (!this.scrollable) {
      return;
    }

    var ddx = detail && -detail.ddx || 0;

    this._affectScroll(ddx);
  },
  _down: function (e) {
    // go one beat async to defeat IronMenuBehavior
    // autorefocus-on-no-selection timeout
    this.async(function () {
      if (this._defaultFocusAsync) {
        this.cancelAsync(this._defaultFocusAsync);
        this._defaultFocusAsync = null;
      }
    }, 1);
  },
  _affectScroll: function (dx) {
    this.$.tabsContainer.scrollLeft += dx;
    var scrollLeft = this.$.tabsContainer.scrollLeft;
    this._leftHidden = scrollLeft === 0;
    this._rightHidden = scrollLeft === this._tabContainerScrollSize;
  },
  _onLeftScrollButtonDown: function () {
    this._scrollToLeft();

    this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
  },
  _onRightScrollButtonDown: function () {
    this._scrollToRight();

    this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
  },
  _onScrollButtonUp: function () {
    clearInterval(this._holdJob);
    this._holdJob = null;
  },
  _scrollToLeft: function () {
    this._affectScroll(-this._step);
  },
  _scrollToRight: function () {
    this._affectScroll(this._step);
  },
  _tabChanged: function (tab, old) {
    if (!tab) {
      // Remove the bar without animation.
      this.$.selectionBar.classList.remove('expand');
      this.$.selectionBar.classList.remove('contract');

      this._positionBar(0, 0);

      return;
    }

    var r = this.$.tabsContent.getBoundingClientRect();
    var w = r.width;
    var tabRect = tab.getBoundingClientRect();
    var tabOffsetLeft = tabRect.left - r.left;
    this._pos = {
      width: this._calcPercent(tabRect.width, w),
      left: this._calcPercent(tabOffsetLeft, w)
    };

    if (this.noSlide || old == null) {
      // Position the bar without animation.
      this.$.selectionBar.classList.remove('expand');
      this.$.selectionBar.classList.remove('contract');

      this._positionBar(this._pos.width, this._pos.left);

      return;
    }

    var oldRect = old.getBoundingClientRect();
    var oldIndex = this.items.indexOf(old);
    var index = this.items.indexOf(tab);
    var m = 5; // bar animation: expand

    this.$.selectionBar.classList.add('expand');
    var moveRight = oldIndex < index;
    var isRTL = this._isRTL;

    if (isRTL) {
      moveRight = !moveRight;
    }

    if (moveRight) {
      this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m, this._left);
    } else {
      this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m, this._calcPercent(tabOffsetLeft, w) + m);
    }

    if (this.scrollable) {
      this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
    }
  },
  _scrollToSelectedIfNeeded: function (tabWidth, tabOffsetLeft) {
    var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;

    if (l < 0) {
      this.$.tabsContainer.scrollLeft += l;
    } else {
      l += tabWidth - this.$.tabsContainer.offsetWidth;

      if (l > 0) {
        this.$.tabsContainer.scrollLeft += l;
      }
    }
  },
  _calcPercent: function (w, w0) {
    return 100 * w / w0;
  },
  _positionBar: function (width, left) {
    width = width || 0;
    left = left || 0;
    this._width = width;
    this._left = left;
    this.transform('translateX(' + left + '%) scaleX(' + width / 100 + ')', this.$.selectionBar);
  },
  _onBarTransitionEnd: function (e) {
    var cl = this.$.selectionBar.classList; // bar animation: expand -> contract

    if (cl.contains('expand')) {
      cl.remove('expand');
      cl.add('contract');

      this._positionBar(this._pos.width, this._pos.left); // bar animation done

    } else if (cl.contains('contract')) {
      cl.remove('contract');
    }
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
`iron-pages` is used to select one of its children to show. One use is to cycle
through a list of children "pages".

Example:

    <iron-pages selected="0">
      <div>One</div>
      <div>Two</div>
      <div>Three</div>
    </iron-pages>

    <script>
      document.addEventListener('click', function(e) {
        var pages = document.querySelector('iron-pages');
        pages.selectNext();
      });
    </script>

@group Iron Elements
@demo demo/index.html
*/

Polymer({
  _template: html`
    <style>
      :host {
        display: block;
      }

      :host > ::slotted(:not(slot):not(.iron-selected)) {
        display: none !important;
      }
    </style>

    <slot></slot>
`,
  is: 'iron-pages',
  behaviors: [IronResizableBehavior, IronSelectableBehavior],
  properties: {
    // as the selected page is the only one visible, activateEvent
    // is both non-sensical and problematic; e.g. in cases where a user
    // handler attempts to change the page and the activateEvent
    // handler immediately changes it back
    activateEvent: {
      type: String,
      value: null
    }
  },
  observers: ['_selectedPageChanged(selected)'],
  _selectedPageChanged: function (selected, old) {
    this.async(this.notifyResize);
  }
});

/**
 * Combines a row of tabs with associated content.
 * 
 * @slot tab - tab area
 * @slot page - page area
 * @csspart pages - wrapper around the tab pages
 */

class PbTabs extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      selected: {
        type: Number,
        reflect: true
      },
      _initial: {
        type: Number
      }
    });
  }

  constructor() {
    super();
    this._initial = this.getParameter('tab', 0);
    this.selected = this._initial;
  }

  _switchTab(ev) {
    this.selected = ev.detail.value;
    this.setParameter('tab', this.selected);
    this.pushHistory('browse', {
      tab: this.selected
    });
  }

  render() {
    return html$1`
            <paper-tabs id="tabs" selected="${this._initial}" @selected-changed="${this._switchTab}">
                <slot name="tab"></slot>
            </paper-tabs>
            <iron-pages part="pages" selected="${this.selected}">
                <slot name="page"></slot>
            </iron-pages>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
        `;
  }

}
customElements.define('pb-tabs', PbTabs);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
app-drawer is a navigation drawer that can slide in from the left or right.

Example:

Align the drawer at the start, which is left in LTR layouts (default):

```html
<app-drawer opened></app-drawer>
```

Align the drawer at the end:

```html
<app-drawer align="end" opened></app-drawer>
```

To make the contents of the drawer scrollable, create a wrapper for the scroll
content, and apply height and overflow styles to it.

```html
<app-drawer>
  <div style="height: 100%; overflow: auto;"></div>
</app-drawer>
```

### Styling

Custom property                  | Description                            | Default
---------------------------------|----------------------------------------|--------------------
`--app-drawer-width`             | Width of the drawer                    | 256px
`--app-drawer-content-container` | Mixin for the drawer content container | {}
`--app-drawer-scrim-background`  | Background for the scrim               | rgba(0, 0, 0, 0.5)

**NOTE:** If you use `<app-drawer>` with `<app-drawer-layout>` and specify a
value for
`--app-drawer-width`, that value must be accessible by both elements. This can
be done by defining the value on the `:host` that contains `<app-drawer-layout>`
(or `html` if outside a shadow root):

```css
:host {
  --app-drawer-width: 300px;
}
```

@element app-drawer
@demo app-drawer/demo/left-drawer.html Simple Left Drawer
@demo app-drawer/demo/right-drawer.html Right Drawer with Icons
*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        position: fixed;
        top: -120px;
        right: 0;
        bottom: -120px;
        left: 0;

        visibility: hidden;

        transition-property: visibility;
      }

      :host([opened]) {
        visibility: visible;
      }

      :host([persistent]) {
        width: var(--app-drawer-width, 256px);
      }

      :host([persistent][position=left]) {
        right: auto;
      }

      :host([persistent][position=right]) {
        left: auto;
      }

      #contentContainer {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;

        width: var(--app-drawer-width, 256px);
        padding: var(--app-drawer-content-padding, 120px 0);

        transition-property: -webkit-transform;
        transition-property: transform;
        -webkit-transform: translate3d(-100%, 0, 0);
        transform: translate3d(-100%, 0, 0);

        background-color: #FFF;

        @apply --app-drawer-content-container;
      }

      #contentContainer[persistent] {
        width: 100%;
      }

      #contentContainer[position=right] {
        right: 0;
        left: auto;

        -webkit-transform: translate3d(100%, 0, 0);
        transform: translate3d(100%, 0, 0);
      }

      #contentContainer[swipe-open]::after {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 100%;

        visibility: visible;

        width: 20px;

        content: '';
      }

      #contentContainer[swipe-open][position=right]::after {
        right: 100%;
        left: auto;
      }

      #contentContainer[opened] {
        -webkit-transform: translate3d(0, 0, 0);
        transform: translate3d(0, 0, 0);
      }

      #scrim {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;

        transition-property: opacity;
        -webkit-transform: translateZ(0);
        transform:  translateZ(0);

        opacity: 0;
        background: var(--app-drawer-scrim-background, rgba(0, 0, 0, 0.5));
      }

      #scrim.visible {
        opacity: 1;
      }

      :host([no-transition]) #contentContainer {
        transition-property: none;
      }
    </style>

    <div id="scrim" on-click="close"></div>

    <!-- HACK(keanulee): Bind attributes here (in addition to :host) for styling to workaround Safari
    bug. https://bugs.webkit.org/show_bug.cgi?id=170762 -->
    <div id="contentContainer" opened\$="[[opened]]" persistent\$="[[persistent]]" position\$="[[position]]" swipe-open\$="[[swipeOpen]]">
      <slot></slot>
    </div>
`,
  is: 'app-drawer',
  properties: {
    /**
     * The opened state of the drawer.
     */
    opened: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The drawer does not have a scrim and cannot be swiped close.
     */
    persistent: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * The transition duration of the drawer in milliseconds.
     */
    transitionDuration: {
      type: Number,
      value: 200
    },

    /**
     * The alignment of the drawer on the screen ('left', 'right', 'start' or
     * 'end'). 'start' computes to left and 'end' to right in LTR layout and
     * vice versa in RTL layout.
     */
    align: {
      type: String,
      value: 'left'
    },

    /**
     * The computed, read-only position of the drawer on the screen ('left' or
     * 'right').
     */
    position: {
      type: String,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * Create an area at the edge of the screen to swipe open the drawer.
     */
    swipeOpen: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * Trap keyboard focus when the drawer is opened and not persistent.
     */
    noFocusTrap: {
      type: Boolean,
      value: false
    },

    /**
     * Disables swiping on the drawer.
     */
    disableSwipe: {
      type: Boolean,
      value: false
    }
  },
  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],
  _translateOffset: 0,
  _trackDetails: null,
  _drawerState: 0,
  _boundEscKeydownHandler: null,
  _firstTabStop: null,
  _lastTabStop: null,

  /** @override */
  attached: function () {
    afterNextRender(this, function () {
      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);
      this.addEventListener('keydown', this._tabKeydownHandler.bind(this)); // Only listen for horizontal track so you can vertically scroll
      // inside the drawer.

      this.listen(this, 'track', '_track');
      this.setScrollDirection('y');
    });
    this.fire('app-reset-layout');
  },

  /** @override */
  detached: function () {
    document.removeEventListener('keydown', this._boundEscKeydownHandler);
  },

  /**
   * Opens the drawer.
   */
  open: function () {
    this.opened = true;
  },

  /**
   * Closes the drawer.
   */
  close: function () {
    this.opened = false;
  },

  /**
   * Toggles the drawer open and close.
   */
  toggle: function () {
    this.opened = !this.opened;
  },

  /**
   * Gets the width of the drawer.
   *
   * @return {number} The width of the drawer in pixels.
   */
  getWidth: function () {
    return this._savedWidth || this.$.contentContainer.offsetWidth;
  },
  _isRTL: function () {
    return window.getComputedStyle(this).direction === 'rtl';
  },
  _resetPosition: function () {
    switch (this.align) {
      case 'start':
        this._setPosition(this._isRTL() ? 'right' : 'left');

        return;

      case 'end':
        this._setPosition(this._isRTL() ? 'left' : 'right');

        return;
    }

    this._setPosition(this.align);
  },
  _escKeydownHandler: function (event) {
    var ESC_KEYCODE = 27;

    if (event.keyCode === ESC_KEYCODE) {
      // Prevent any side effects if app-drawer closes.
      event.preventDefault();
      this.close();
    }
  },
  _track: function (event) {
    if (this.persistent || this.disableSwipe) {
      return;
    } // Disable user selection on desktop.


    event.preventDefault();

    switch (event.detail.state) {
      case 'start':
        this._trackStart(event);

        break;

      case 'track':
        this._trackMove(event);

        break;

      case 'end':
        this._trackEnd(event);

        break;
    }
  },
  _trackStart: function (event) {
    this._drawerState = this._DRAWER_STATE.TRACKING;
    var rect = this.$.contentContainer.getBoundingClientRect();
    this._savedWidth = rect.width;

    if (this.position === 'left') {
      this._translateOffset = rect.left;
    } else {
      this._translateOffset = rect.right - window.innerWidth;
    }

    this._trackDetails = []; // Disable transitions since style attributes will reflect user track
    // events.

    this._styleTransitionDuration(0);

    this.style.visibility = 'visible';
  },
  _trackMove: function (event) {
    this._translateDrawer(event.detail.dx + this._translateOffset); // Use Date.now() since event.timeStamp is inconsistent across browsers
    // (e.g. most browsers use milliseconds but FF 44 uses microseconds).


    this._trackDetails.push({
      dx: event.detail.dx,
      timeStamp: Date.now()
    });
  },
  _trackEnd: function (event) {
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;

    if (!isInEndState) {
      // No longer need the track events after this method returns - allow them
      // to be GC'd.
      var trackDetails = this._trackDetails;
      this._trackDetails = null;

      this._flingDrawer(event, trackDetails);

      if (this._drawerState === this._DRAWER_STATE.FLINGING) {
        return;
      }
    } // If the drawer is not flinging, toggle the opened state based on the
    // position of the drawer.


    var halfWidth = drawerWidth / 2;

    if (event.detail.dx < -halfWidth) {
      this.opened = this.position === 'right';
    } else if (event.detail.dx > halfWidth) {
      this.opened = this.position === 'left';
    }

    if (isInEndState) {
      this.debounce('_resetDrawerState', this._resetDrawerState);
    } else {
      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
    }

    this._styleTransitionDuration(this.transitionDuration);

    this._resetDrawerTranslate();

    this.style.visibility = '';
  },
  _calculateVelocity: function (event, trackDetails) {
    // Find the oldest track event that is within 100ms using binary search.
    var now = Date.now();
    var timeLowerBound = now - 100;
    var trackDetail;
    var min = 0;
    var max = trackDetails.length - 1;

    while (min <= max) {
      // Floor of average of min and max.
      var mid = min + max >> 1;
      var d = trackDetails[mid];

      if (d.timeStamp >= timeLowerBound) {
        trackDetail = d;
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    if (trackDetail) {
      var dx = event.detail.dx - trackDetail.dx;
      var dt = now - trackDetail.timeStamp || 1;
      return dx / dt;
    }

    return 0;
  },
  _flingDrawer: function (event, trackDetails) {
    var velocity = this._calculateVelocity(event, trackDetails); // Do not fling if velocity is not above a threshold.


    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {
      return;
    }

    this._drawerState = this._DRAWER_STATE.FLINGING;
    var x = event.detail.dx + this._translateOffset;
    var drawerWidth = this.getWidth();
    var isPositionLeft = this.position === 'left';
    var isVelocityPositive = velocity > 0;
    var isClosingLeft = !isVelocityPositive && isPositionLeft;
    var isClosingRight = isVelocityPositive && !isPositionLeft;
    var dx;

    if (isClosingLeft) {
      dx = -(x + drawerWidth);
    } else if (isClosingRight) {
      dx = drawerWidth - x;
    } else {
      dx = -x;
    } // Enforce a minimum transition velocity to make the drawer feel snappy.


    if (isVelocityPositive) {
      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'left';
    } else {
      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);
      this.opened = this.position === 'right';
    } // Calculate the amount of time needed to finish the transition based on the
    // initial slope of the timing function.


    var t = this._FLING_INITIAL_SLOPE * dx / velocity;

    this._styleTransitionDuration(t);

    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);

    this._resetDrawerTranslate();

    this.debounce('_resetDrawerState', this._resetDrawerState, t);
  },
  _styleTransitionDuration: function (duration) {
    this.style.transitionDuration = duration + 'ms';
    this.$.contentContainer.style.transitionDuration = duration + 'ms';
    this.$.scrim.style.transitionDuration = duration + 'ms';
  },
  _styleTransitionTimingFunction: function (timingFunction) {
    this.$.contentContainer.style.transitionTimingFunction = timingFunction;
    this.$.scrim.style.transitionTimingFunction = timingFunction;
  },
  _translateDrawer: function (x) {
    var drawerWidth = this.getWidth();

    if (this.position === 'left') {
      x = Math.max(-drawerWidth, Math.min(x, 0));
      this.$.scrim.style.opacity = 1 + x / drawerWidth;
    } else {
      x = Math.max(0, Math.min(x, drawerWidth));
      this.$.scrim.style.opacity = 1 - x / drawerWidth;
    }

    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);
  },
  _resetDrawerTranslate: function () {
    this.$.scrim.style.opacity = '';
    this.transform('', this.$.contentContainer);
  },
  _resetDrawerState: function () {
    var oldState = this._drawerState; // If the drawer was flinging, we need to reset the style attributes.

    if (oldState === this._DRAWER_STATE.FLINGING) {
      this._styleTransitionDuration(this.transitionDuration);

      this._styleTransitionTimingFunction('');

      this.style.visibility = '';
    }

    this._savedWidth = null;

    if (this.opened) {
      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;
    } else {
      this._drawerState = this._DRAWER_STATE.CLOSED;
    }

    if (oldState !== this._drawerState) {
      if (this._drawerState === this._DRAWER_STATE.OPENED) {
        this._setKeyboardFocusTrap();

        document.addEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = 'hidden';
      } else {
        document.removeEventListener('keydown', this._boundEscKeydownHandler);
        document.body.style.overflow = '';
      } // Don't fire the event on initial load.


      if (oldState !== this._DRAWER_STATE.INIT) {
        this.fire('app-drawer-transitioned');
      }
    }
  },

  /**
   * Resets the layout.
   *
   * @method resetLayout
   */
  resetLayout: function () {
    this.fire('app-reset-layout');
  },
  _setKeyboardFocusTrap: function () {
    if (this.noFocusTrap) {
      return;
    } // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated),
    // this will not select focusable elements inside shadow roots.


    var focusableElementsSelector = ['a[href]:not([tabindex="-1"])', 'area[href]:not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'select:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', 'button:not([disabled]):not([tabindex="-1"])', 'iframe:not([tabindex="-1"])', '[tabindex]:not([tabindex="-1"])', '[contentEditable=true]:not([tabindex="-1"])'].join(',');
    var focusableElements = dom(this).querySelectorAll(focusableElementsSelector);

    if (focusableElements.length > 0) {
      this._firstTabStop = focusableElements[0];
      this._lastTabStop = focusableElements[focusableElements.length - 1];
    } else {
      // Reset saved tab stops when there are no focusable elements in the
      // drawer.
      this._firstTabStop = null;
      this._lastTabStop = null;
    } // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the
    // first focusable element in the drawer, if it exists. Use the tabindex
    // attribute since the this.tabIndex property in IE/Edge returns 0 (instead
    // of -1) when the attribute is not set.


    var tabindex = this.getAttribute('tabindex');

    if (tabindex && parseInt(tabindex, 10) > -1) {
      this.focus();
    } else if (this._firstTabStop) {
      this._firstTabStop.focus();
    }
  },
  _tabKeydownHandler: function (event) {
    if (this.noFocusTrap) {
      return;
    }

    var TAB_KEYCODE = 9;

    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {
      if (event.shiftKey) {
        if (this._firstTabStop && dom(event).localTarget === this._firstTabStop) {
          event.preventDefault();

          this._lastTabStop.focus();
        }
      } else {
        if (this._lastTabStop && dom(event).localTarget === this._lastTabStop) {
          event.preventDefault();

          this._firstTabStop.focus();
        }
      }
    }
  },
  _openedPersistentChanged: function (opened, persistent) {
    this.toggleClass('visible', opened && !persistent, this.$.scrim); // Use a debounce timer instead of transitionend since transitionend won't
    // fire when app-drawer is display: none.

    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);
  },
  _MIN_FLING_THRESHOLD: 0.2,
  _MIN_TRANSITION_VELOCITY: 1.2,
  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',
  _FLING_INITIAL_SLOPE: 1.5,
  _DRAWER_STATE: {
    INIT: 0,
    OPENED: 1,
    OPENED_PERSISTENT: 2,
    CLOSED: 3,
    TRACKING: 4,
    FLINGING: 5
  }
  /**
   * Fired when the layout of app-drawer has changed.
   *
   * @event app-reset-layout
   */

  /**
   * Fired when app-drawer has finished transitioning.
   *
   * @event app-drawer-transitioned
   */

});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
`iron-media-query` can be used to data bind to a CSS media query.
The `query` property is a bare CSS media query.
The `query-matches` property is a boolean representing whether the page matches
that media query.

Example:

```html
<iron-media-query query="(min-width: 600px)" query-matches="{{queryMatches}}">
</iron-media-query>
```

@group Iron Elements
@demo demo/index.html
@hero hero.svg
@element iron-media-query
*/

Polymer({
  is: 'iron-media-query',
  properties: {
    /**
     * The Boolean return value of the media query.
     */
    queryMatches: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true
    },

    /**
     * The CSS media query to evaluate.
     */
    query: {
      type: String,
      observer: 'queryChanged'
    },

    /**
     * If true, the query attribute is assumed to be a complete media query
     * string rather than a single media feature.
     */
    full: {
      type: Boolean,
      value: false
    },

    /**
     * @type {function(MediaQueryList)}
     */
    _boundMQHandler: {
      value: function () {
        return this.queryHandler.bind(this);
      }
    },

    /**
     * @type {MediaQueryList}
     */
    _mq: {
      value: null
    }
  },
  attached: function () {
    this.style.display = 'none';
    this.queryChanged();
  },
  detached: function () {
    this._remove();
  },
  _add: function () {
    if (this._mq) {
      this._mq.addListener(this._boundMQHandler);
    }
  },
  _remove: function () {
    if (this._mq) {
      this._mq.removeListener(this._boundMQHandler);
    }

    this._mq = null;
  },
  queryChanged: function () {
    this._remove();

    var query = this.query;

    if (!query) {
      return;
    }

    if (!this.full && query[0] !== '(') {
      query = '(' + query + ')';
    }

    this._mq = window.matchMedia(query);

    this._add();

    this.queryHandler(this._mq);
  },
  queryHandler: function (mq) {
    this._setQueryMatches(mq.matches);
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * @polymerBehavior
 */

const AppLayoutBehavior = [IronResizableBehavior, {
  listeners: {
    'app-reset-layout': '_appResetLayoutHandler',
    'iron-resize': 'resetLayout'
  },
  attached: function () {
    this.fire('app-reset-layout');
  },
  _appResetLayoutHandler: function (e) {
    if (dom(e).path[0] === this) {
      return;
    }

    this.resetLayout();
    e.stopPropagation();
  },
  _updateLayoutStates: function () {
    console.error('unimplemented');
  },

  /**
   * Resets the layout. If you changed the size of this element via CSS
   * you can notify the changes by either firing the `iron-resize` event
   * or calling `resetLayout` directly.
   *
   * @method resetLayout
   */
  resetLayout: function () {

    var cb = this._updateLayoutStates.bind(this);

    this._layoutDebouncer = Debouncer.debounce(this._layoutDebouncer, animationFrame, cb);
    enqueueDebouncer(this._layoutDebouncer);

    this._notifyDescendantResize();
  },
  _notifyLayoutChanged: function () {
    var self = this; // TODO: the event `app-reset-layout` can be fired synchronously
    // as long as `_updateLayoutStates` waits for all the microtasks after
    // rAF. E.g. requestAnimationFrame(setTimeOut())

    requestAnimationFrame(function () {
      self.fire('app-reset-layout');
    });
  },
  _notifyDescendantResize: function () {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function (resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);
  }
}];

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
app-drawer-layout is a wrapper element that positions an app-drawer and other
content. When the viewport width is smaller than `responsiveWidth`, this element
changes to narrow layout. In narrow layout, the drawer will be stacked on top of
the main content. The drawer will slide in/out to hide/reveal the main content.

By default the drawer is aligned to the start, which is left in LTR layouts:

```html
<app-drawer-layout>
  <app-drawer slot="drawer">
    drawer content
  </app-drawer>
  <div>
    main content
  </div>
</app-drawer-layout>
```

Align the drawer at the end:

```html
<app-drawer-layout>
  <app-drawer slot="drawer" align="end">
     drawer content
  </app-drawer>
  <div>
    main content
  </div>
</app-drawer-layout>
```

With an app-header-layout:

```html
<app-drawer-layout>
  <app-drawer slot="drawer">
    drawer-content
  </app-drawer>
  <app-header-layout>
    <app-header slot="header">
      <app-toolbar>
        <div main-title>App name</div>
      </app-toolbar>
    </app-header>

    main content

  </app-header-layout>
</app-drawer-layout>
```

Add the `drawer-toggle` attribute to elements inside `app-drawer-layout` that
toggle the drawer on click events:

```html
<app-drawer-layout>
  <app-drawer slot="drawer">
    drawer-content
  </app-drawer>
  <app-header-layout>
    <app-header slot="header">
      <app-toolbar>
        <paper-icon-button icon="menu" drawer-toggle></paper-icon-button>
        <div main-title>App name</div>
      </app-toolbar>
    </app-header>

    main content

  </app-header-layout>
</app-drawer-layout>
```

**NOTE:** With app-layout 2.0, the `drawer-toggle` element needs to be manually
hidden when app-drawer-layout is not in narrow layout. To add this, add the
following CSS rule where app-drawer-layout is used:

```css
app-drawer-layout:not([narrow]) [drawer-toggle] {
  display: none;
}
```

Add the `fullbleed` attribute to app-drawer-layout to make it fit the size of
its container:

```html
<app-drawer-layout fullbleed>
  <app-drawer slot="drawer">
     drawer content
  </app-drawer>
  <div>
    main content
  </div>
</app-drawer-layout>
```

### Styling

Custom property                          | Description                          | Default
-----------------------------------------|--------------------------------------|---------
`--app-drawer-width`                     | Width of the drawer                  | 256px
`--app-drawer-layout-content-transition` | Transition for the content container | none

**NOTE:** If you use <app-drawer> with <app-drawer-layout> and specify a value
for
`--app-drawer-width`, that value must be accessible by both elements. This can
be done by defining the value on the `:host` that contains <app-drawer-layout>
(or `html` if outside a shadow root):

```css
:host {
  --app-drawer-width: 300px;
}
```

@element app-drawer-layout
@demo app-drawer-layout/demo/index.html
*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        display: block;
        /**
         * Force app-drawer-layout to have its own stacking context so that its parent can
         * control the stacking of it relative to other elements.
         */
        position: relative;
        z-index: 0;
      }

      :host ::slotted([slot=drawer]) {
        z-index: 1;
      }

      :host([fullbleed]) {
        @apply --layout-fit;
      }

      #contentContainer {
        /* Create a stacking context here so that all children appear below the header. */
        position: relative;
        z-index: 0;
        height: 100%;
        transition: var(--app-drawer-layout-content-transition, none);
      }

      #contentContainer[drawer-position=left] {
        margin-left: var(--app-drawer-width, 256px);
      }

      #contentContainer[drawer-position=right] {
        margin-right: var(--app-drawer-width, 256px);
      }
    </style>

    <slot id="drawerSlot" name="drawer"></slot>

    <div id="contentContainer" drawer-position\$="[[_drawerPosition]]">
      <slot></slot>
    </div>

    <iron-media-query query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]" on-query-matches-changed="_onQueryMatchesChanged"></iron-media-query>
`,
  is: 'app-drawer-layout',
  behaviors: [AppLayoutBehavior],
  properties: {
    /**
     * If true, ignore `responsiveWidth` setting and force the narrow layout.
     */
    forceNarrow: {
      type: Boolean,
      value: false
    },

    /**
     * If the viewport's width is smaller than this value, the panel will change
     * to narrow layout. In the mode the drawer will be closed.
     */
    responsiveWidth: {
      type: String,
      value: '640px'
    },

    /**
     * Returns true if it is in narrow layout. This is useful if you need to
     * show/hide elements based on the layout.
     */
    narrow: {
      type: Boolean,
      reflectToAttribute: true,
      readOnly: true,
      notify: true
    },

    /**
     * If true, the drawer will initially be opened when in narrow layout mode.
     */
    openedWhenNarrow: {
      type: Boolean,
      value: false
    },
    _drawerPosition: {
      type: String
    }
  },
  listeners: {
    'click': '_clickHandler'
  },
  observers: ['_narrowChanged(narrow)'],

  /**
   * A reference to the app-drawer element.
   *
   * @property drawer
   */
  get drawer() {
    return dom(this.$.drawerSlot).getDistributedNodes()[0];
  },

  /** @override */
  attached: function () {
    // Disable drawer transitions until after app-drawer-layout sets the initial
    // opened state.
    var drawer = this.drawer;

    if (drawer) {
      drawer.setAttribute('no-transition', '');
    }
  },
  _clickHandler: function (e) {
    var target = dom(e).localTarget;

    if (target && target.hasAttribute('drawer-toggle')) {
      var drawer = this.drawer;

      if (drawer && !drawer.persistent) {
        drawer.toggle();
      }
    }
  },
  _updateLayoutStates: function () {
    var drawer = this.drawer;

    if (!this.isAttached || !drawer) {
      return;
    }

    this._drawerPosition = this.narrow ? null : drawer.position;

    if (this._drawerNeedsReset) {
      if (this.narrow) {
        drawer.opened = this.openedWhenNarrow;
        drawer.persistent = false;
      } else {
        drawer.opened = drawer.persistent = true;
      }

      if (drawer.hasAttribute('no-transition')) {
        // Enable drawer transitions after app-drawer-layout sets the initial
        // opened state.
        afterNextRender(this, function () {
          drawer.removeAttribute('no-transition');
        });
      }

      this._drawerNeedsReset = false;
    }
  },
  _narrowChanged: function () {
    this._drawerNeedsReset = true;
    this.resetLayout();
  },
  _onQueryMatchesChanged: function (event) {
    this._setNarrow(event.detail.value);
  },
  _computeMediaQuery: function (forceNarrow, responsiveWidth) {
    return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
  }
});

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const $_documentContainer = document.createElement('template');
$_documentContainer.setAttribute('style', 'display: none;');
$_documentContainer.innerHTML = `<dom-module id="app-grid-style">
  <template>
    <style>
      :host {
        /**
         * The width for the expandible item is:
         * ((100% - subPixelAdjustment) / columns * itemColumns - gutter
         *
         * - subPixelAdjustment: 0.1px (Required for IE 11)
         * - gutter: var(--app-grid-gutter)
         * - columns: var(--app-grid-columns)
         * - itemColumn: var(--app-grid-expandible-item-columns)
         */
        --app-grid-expandible-item: {
          -webkit-flex-basis: calc((100% - 0.1px) / var(--app-grid-columns, 1) * var(--app-grid-expandible-item-columns, 1) - var(--app-grid-gutter, 0px)) !important;
          flex-basis: calc((100% - 0.1px) / var(--app-grid-columns, 1) * var(--app-grid-expandible-item-columns, 1) - var(--app-grid-gutter, 0px)) !important;
          max-width: calc((100% - 0.1px) / var(--app-grid-columns, 1) * var(--app-grid-expandible-item-columns, 1) - var(--app-grid-gutter, 0px)) !important;
        };
      }

      .app-grid {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;

        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;

        -ms-flex-wrap: wrap;
        -webkit-flex-wrap: wrap;
        flex-wrap: wrap;

        padding-top: var(--app-grid-gutter, 0px);
        padding-left: var(--app-grid-gutter, 0px);
        box-sizing: border-box;
      }

      .app-grid > * {
        /* Required for IE 10 */
        -ms-flex: 1 1 100%;
        -webkit-flex: 1;
        flex: 1;

        /* The width for an item is: (100% - subPixelAdjustment - gutter * columns) / columns */
        -webkit-flex-basis: calc((100% - 0.1px - (var(--app-grid-gutter, 0px) * var(--app-grid-columns, 1))) / var(--app-grid-columns, 1));
        flex-basis: calc((100% - 0.1px - (var(--app-grid-gutter, 0px) * var(--app-grid-columns, 1))) / var(--app-grid-columns, 1));

        max-width: calc((100% - 0.1px - (var(--app-grid-gutter, 0px) * var(--app-grid-columns, 1))) / var(--app-grid-columns, 1));
        margin-bottom: var(--app-grid-gutter, 0px);
        margin-right: var(--app-grid-gutter, 0px);
        height: var(--app-grid-item-height);
        box-sizing: border-box;
      }

      .app-grid[has-aspect-ratio] > * {
        position: relative;
      }

      .app-grid[has-aspect-ratio] > *::before {
        display: block;
        content: "";
        padding-top: var(--app-grid-item-height, 100%);
      }

      .app-grid[has-aspect-ratio] > * > * {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }
    </style>
  </template>
</dom-module>`;
document.head.appendChild($_documentContainer.content);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
app-header is container element for app-toolbars at the top of the screen that
can have scroll effects. By default, an app-header moves away from the viewport
when scrolling down and if using `reveals`, the header slides back when
scrolling back up. For example:

```html
<app-header reveals>
  <app-toolbar>
    <div main-title>App name</div>
  </app-toolbar>
</app-header>
```

app-header can also condense when scrolling down. To achieve this behavior, the
header must have a larger height than the `sticky` element in the light DOM. For
example:

```html
<app-header style="height: 96px;" condenses fixed>
  <app-toolbar style="height: 64px;">
    <div main-title>App name</div>
  </app-toolbar>
</app-header>
```

In this case the header is initially `96px` tall, and it shrinks to `64px` when
scrolling down. That is what is meant by "condensing".

### Sticky element

The element that is positioned fixed to top of the header's `scrollTarget` when
a threshold is reached, similar to `position: sticky` in CSS. This element
**must** be an immediate child of app-header. By default, the `sticky` element
is the first `app-toolbar that is an immediate child of app-header.

```html
<app-header condenses>
  <app-toolbar> Sticky element </app-toolbar>
  <app-toolbar></app-toolbar>
</app-header>
```

#### Customizing the sticky element

```html
<app-header condenses>
  <app-toolbar></app-toolbar>
  <app-toolbar sticky> Sticky element </app-toolbar>
</app-header>
```

### Scroll target

The app-header's `scrollTarget` property allows to customize the scrollable
element to which the header responds when the user scrolls. By default,
app-header uses the document as the scroll target, but you can customize this
property by setting the id of the element, e.g.

```html
<div id="scrollingRegion" style="overflow-y: auto;">
  <app-header scroll-target="scrollingRegion">
  </app-header>
</div>
```

In this case, the `scrollTarget` property points to the outer div element.
Alternatively, you can set this property programmatically:

```js
appHeader.scrollTarget = document.querySelector("#scrollingRegion");
```

## Backgrounds
app-header has two background layers that can be used for styling when the
header is condensed or when the scrollable element is scrolled to the top.

## Scroll effects

Scroll effects are _optional_ visual effects applied in app-header based on
scroll position. For example, The [Material Design scrolling
techniques](https://www.google.com/design/spec/patterns/scrolling-techniques.html)
recommends effects that can be installed via the `effects` property. e.g.

```html
<app-header effects="waterfall">
  <app-toolbar>App name</app-toolbar>
</app-header>
```

#### Importing the effects

To use the scroll effects, you must explicitly import them in addition to
`app-header`:

```js
import '@polymer/app-layout/app-scroll-effects/app-scroll-effects.js';
```

#### List of effects

* **blend-background**
Fades in/out two background elements by applying CSS opacity based on scroll
position. You can use this effect to smoothly change the background color or
image of the header. For example, using the mixin
`--app-header-background-rear-layer` lets you assign a different background when
the header is condensed:

```css
app-header {
  background-color: red;
  --app-header-background-rear-layer: {
    /* The header is blue when condensed *\/
    background-color: blue;
  };
}
```

* **fade-background**
Upon scrolling past a threshold, this effect will trigger an opacity transition
to fade in/out the backgrounds. Compared to the `blend-background` effect, this
effect doesn't interpolate the opacity based on scroll position.


* **parallax-background**
A simple parallax effect that vertically translates the backgrounds based on a
fraction of the scroll position. For example:

```css
app-header {
  --app-header-background-front-layer: {
    background-image: url(...);
  };
}
```
```html
<app-header style="height: 300px;" effects="parallax-background">
  <app-toolbar>App name</app-toolbar>
</app-header>
```

The fraction determines how far the background moves relative to the scroll
position. This value can be assigned via the `scalar` config value and it is
typically a value between 0 and 1 inclusive. If `scalar=0`, the background
doesn't move away from the header.

* **resize-title**
Progressively interpolates the size of the title from the element with the
`main-title` attribute to the element with the `condensed-title` attribute as
the header condenses. For example:

```html
<app-header condenses reveals effects="resize-title">
  <app-toolbar>
      <h4 condensed-title>App name</h4>
  </app-toolbar>
  <app-toolbar>
      <h1 main-title>App name</h1>
  </app-toolbar>
</app-header>
```

* **resize-snapped-title**
Upon scrolling past a threshold, this effect fades in/out the titles using
opacity transitions. Similarly to `resize-title`, the `main-title` and
`condensed-title` elements must be placed in the light DOM.

* **waterfall**
Toggles the shadow property in app-header to create a sense of depth (as
recommended in the MD spec) between the header and the underneath content. You
can change the shadow by customizing the `--app-header-shadow` mixin. For
example:

```css
app-header {
  --app-header-shadow: {
    box-shadow: inset 0px 5px 2px -3px rgba(0, 0, 0, 0.2);
  };
}
```

```html
<app-header condenses reveals effects="waterfall">
  <app-toolbar>
      <h1 main-title>App name</h1>
  </app-toolbar>
</app-header>
```

* **material**
Installs the waterfall, resize-title, blend-background and parallax-background
effects.

### Content attributes

Attribute | Description         | Default
----------|---------------------|----------------------------------------
`sticky` | Element that remains at the top when the header condenses. | The first app-toolbar in the light DOM.


## Styling

Mixin | Description | Default
------|-------------|----------
`--app-header-background-front-layer` | Applies to the front layer of the background. | {}
`--app-header-background-rear-layer` | Applies to the rear layer of the background. | {}
`--app-header-shadow` | Applies to the shadow. | {}

@element app-header
@demo app-header/demo/blend-background-1.html Blend Background Image
@demo app-header/demo/blend-background-2.html Blend 2 Background Images
@demo app-header/demo/blend-background-3.html Blend Background Colors
@demo app-header/demo/contacts.html Contacts Demo
@demo app-header/demo/give.html Resize Snapped Title Demo
@demo app-header/demo/music.html Reveals Demo
@demo app-header/demo/no-effects.html Condenses and Reveals Demo
@demo app-header/demo/notes.html Fixed with Dynamic Shadow Demo
@demo app-header/demo/custom-sticky-element-1.html Custom Sticky Element Demo 1
@demo app-header/demo/custom-sticky-element-2.html Custom Sticky Element Demo 2

*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        position: relative;
        display: block;
        transition-timing-function: linear;
        transition-property: -webkit-transform;
        transition-property: transform;
      }

      :host::before {
        position: absolute;
        right: 0px;
        bottom: -5px;
        left: 0px;
        width: 100%;
        height: 5px;
        content: "";
        transition: opacity 0.4s;
        pointer-events: none;
        opacity: 0;
        box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
        will-change: opacity;
        @apply --app-header-shadow;
      }

      :host([shadow])::before {
        opacity: 1;
      }

      #background {
        @apply --layout-fit;
        overflow: hidden;
      }

      #backgroundFrontLayer,
      #backgroundRearLayer {
        @apply --layout-fit;
        height: 100%;
        pointer-events: none;
        background-size: cover;
      }

      #backgroundFrontLayer {
        @apply --app-header-background-front-layer;
      }

      #backgroundRearLayer {
        opacity: 0;
        @apply --app-header-background-rear-layer;
      }

      #contentContainer {
        position: relative;
        width: 100%;
        height: 100%;
      }

      :host([disabled]),
      :host([disabled])::after,
      :host([disabled]) #backgroundFrontLayer,
      :host([disabled]) #backgroundRearLayer,
      /* Silent scrolling should not run CSS transitions */
      :host([silent-scroll]),
      :host([silent-scroll])::after,
      :host([silent-scroll]) #backgroundFrontLayer,
      :host([silent-scroll]) #backgroundRearLayer {
        transition: none !important;
      }

      :host([disabled]) ::slotted(app-toolbar:first-of-type),
      :host([disabled]) ::slotted([sticky]),
      /* Silent scrolling should not run CSS transitions */
      :host([silent-scroll]) ::slotted(app-toolbar:first-of-type),
      :host([silent-scroll]) ::slotted([sticky]) {
        transition: none !important;
      }

    </style>
    <div id="contentContainer">
      <slot id="slot"></slot>
    </div>
`,
  is: 'app-header',
  behaviors: [AppScrollEffectsBehavior, AppLayoutBehavior],
  properties: {
    /**
     * If true, the header will automatically collapse when scrolling down.
     * That is, the `sticky` element remains visible when the header is fully
     *condensed whereas the rest of the elements will collapse below `sticky`
     *element.
     *
     * By default, the `sticky` element is the first toolbar in the light DOM:
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar>This toolbar remains on top</app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     * </app-header>
     * ```
     *
     * Additionally, you can specify which toolbar or element remains visible in
     *condensed mode by adding the `sticky` attribute to that element. For
     *example: if we want the last toolbar to remain visible, we can add the
     *`sticky` attribute to it.
     *
     *```html
     * <app-header condenses>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar></app-toolbar>
     *   <app-toolbar sticky>This toolbar remains on top</app-toolbar>
     * </app-header>
     * ```
     *
     * Note the `sticky` element must be a direct child of `app-header`.
     */
    condenses: {
      type: Boolean,
      value: false
    },

    /**
     * Mantains the header fixed at the top so it never moves away.
     */
    fixed: {
      type: Boolean,
      value: false
    },

    /**
     * Slides back the header when scrolling back up.
     */
    reveals: {
      type: Boolean,
      value: false
    },

    /**
     * Displays a shadow below the header.
     */
    shadow: {
      type: Boolean,
      reflectToAttribute: true,
      value: false
    }
  },
  observers: ['_configChanged(isAttached, condenses, fixed)'],

  /**
   * A cached offsetHeight of the current element.
   *
   * @type {number}
   */
  _height: 0,

  /**
   * The distance in pixels the header will be translated to when scrolling.
   *
   * @type {number}
   */
  _dHeight: 0,

  /**
   * The offsetTop of `_stickyEl`
   *
   * @type {number}
   */
  _stickyElTop: 0,

  /**
   * A reference to the element that remains visible when the header condenses.
   *
   * @type {HTMLElement}
   */
  _stickyElRef: null,

  /**
   * The header's top value used for the `transformY`
   *
   * @type {number}
   */
  _top: 0,

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,
  _wasScrollingDown: false,
  _initScrollTop: 0,
  _initTimestamp: 0,
  _lastTimestamp: 0,
  _lastScrollTop: 0,

  /**
   * The distance the header is allowed to move away.
   *
   * @type {number}
   */
  get _maxHeaderTop() {
    return this.fixed ? this._dHeight : this._height + 5;
  },

  /**
   * Returns a reference to the sticky element.
   *
   * @return {HTMLElement}?
   */
  get _stickyEl() {
    if (this._stickyElRef) {
      return this._stickyElRef;
    }

    var nodes = dom(this.$.slot).getDistributedNodes(); // Get the element with the sticky attribute on it or the first element in
    // the light DOM.

    for (var i = 0, node; node = nodes[i]; i++) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.hasAttribute('sticky')) {
          this._stickyElRef = node;
          break;
        } else if (!this._stickyElRef) {
          this._stickyElRef = node;
        }
      }
    }

    return this._stickyElRef;
  },

  _configChanged: function () {
    this.resetLayout();

    this._notifyLayoutChanged();
  },
  _updateLayoutStates: function () {
    if (this.offsetWidth === 0 && this.offsetHeight === 0) {
      return;
    }

    var scrollTop = this._clampedScrollTop;
    var firstSetup = this._height === 0 || scrollTop === 0;
    var currentDisabled = this.disabled;
    this._height = this.offsetHeight;
    this._stickyElRef = null;
    this.disabled = true; // prepare for measurement

    if (!firstSetup) {
      this._updateScrollState(0, true);
    }

    if (this._mayMove()) {
      this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
    } else {
      this._dHeight = 0;
    }

    this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;

    this._setUpEffect();

    if (firstSetup) {
      this._updateScrollState(scrollTop, true);
    } else {
      this._updateScrollState(this._lastScrollTop, true);

      this._layoutIfDirty();
    } // restore no transition


    this.disabled = currentDisabled;
  },

  /**
   * Updates the scroll state.
   *
   * @param {number} scrollTop
   * @param {boolean=} forceUpdate (default: false)
   */
  _updateScrollState: function (scrollTop, forceUpdate) {
    if (this._height === 0) {
      return;
    }

    var progress = 0;
    var top = 0;
    var lastTop = this._top;
    var lastScrollTop = this._lastScrollTop;
    var maxHeaderTop = this._maxHeaderTop;
    var dScrollTop = scrollTop - this._lastScrollTop;
    var absDScrollTop = Math.abs(dScrollTop);
    var isScrollingDown = scrollTop > this._lastScrollTop;
    var now = performance.now();

    if (this._mayMove()) {
      top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
    }

    if (scrollTop >= this._dHeight) {
      top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
      this.style.transitionDuration = '0ms';
    }

    if (this.reveals && !this.disabled && absDScrollTop < 100) {
      // set the initial scroll position
      if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
        this._initScrollTop = scrollTop;
        this._initTimestamp = now;
      }

      if (scrollTop >= maxHeaderTop) {
        // check if the header is allowed to snap
        if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
          if (isScrollingDown && scrollTop >= maxHeaderTop) {
            top = maxHeaderTop;
          } else if (!isScrollingDown && scrollTop >= this._dHeight) {
            top = this.condenses && !this.fixed ? this._dHeight : 0;
          }

          var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
          this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
        } else {
          top = this._top;
        }
      }
    }

    if (this._dHeight === 0) {
      progress = scrollTop > 0 ? 1 : 0;
    } else {
      progress = top / this._dHeight;
    }

    if (!forceUpdate) {
      this._lastScrollTop = scrollTop;
      this._top = top;
      this._wasScrollingDown = isScrollingDown;
      this._lastTimestamp = now;
    }

    if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
      this._progress = progress;

      this._runEffects(progress, top);

      this._transformHeader(top);
    }
  },

  /**
   * Returns true if the current header is allowed to move as the user scrolls.
   *
   * @return {boolean}
   */
  _mayMove: function () {
    return this.condenses || !this.fixed;
  },

  /**
   * Returns true if the current header will condense based on the size of the
   * header and the `consenses` property.
   *
   * @return {boolean}
   */
  willCondense: function () {
    return this._dHeight > 0 && this.condenses;
  },

  /**
   * Returns true if the current element is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function () {
    return this._height !== 0 && this._top < this._height;
  },

  /**
   * Returns true if there's content below the current element.
   *
   * @method isContentBelow
   * @return {boolean}
   */
  isContentBelow: function () {
    return this._top === 0 ? this._clampedScrollTop > 0 : this._clampedScrollTop - this._maxHeaderTop >= 0;
  },

  /**
   * Transforms the header.
   *
   * @param {number} y
   */
  _transformHeader: function (y) {
    this.translate3d(0, -y + 'px', 0);

    if (this._stickyEl) {
      this.translate3d(0, this.condenses && y >= this._stickyElTop ? Math.min(y, this._dHeight) - this._stickyElTop + 'px' : 0, 0, this._stickyEl);
    }
  },
  _clamp: function (v, min, max) {
    return Math.min(max, Math.max(min, v));
  },
  _ensureBgContainers: function () {
    if (!this._bgContainer) {
      this._bgContainer = document.createElement('div');
      this._bgContainer.id = 'background';
      this._bgRear = document.createElement('div');
      this._bgRear.id = 'backgroundRearLayer';

      this._bgContainer.appendChild(this._bgRear);

      this._bgFront = document.createElement('div');
      this._bgFront.id = 'backgroundFrontLayer';

      this._bgContainer.appendChild(this._bgFront);

      dom(this.root).insertBefore(this._bgContainer, this.$.contentContainer);
    }
  },
  _getDOMRef: function (id) {
    switch (id) {
      case 'backgroundFrontLayer':
        this._ensureBgContainers();

        return this._bgFront;

      case 'backgroundRearLayer':
        this._ensureBgContainers();

        return this._bgRear;

      case 'background':
        this._ensureBgContainers();

        return this._bgContainer;

      case 'mainTitle':
        return dom(this).querySelector('[main-title]');

      case 'condensedTitle':
        return dom(this).querySelector('[condensed-title]');
    }

    return null;
  },

  /**
   * Returns an object containing the progress value of the scroll effects
   * and the top position of the header.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function () {
    return {
      progress: this._progress,
      top: this._top
    };
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
app-header-layout is a wrapper element that positions an app-header and other
content. This element uses the document scroll by default, but it can also
define its own scrolling region.

Using the document scroll:

```html
<app-header-layout>
  <app-header slot="header" fixed condenses effects="waterfall">
    <app-toolbar>
      <div main-title>App name</div>
    </app-toolbar>
  </app-header>
  <div>
    main content
  </div>
</app-header-layout>
```

Using an own scrolling region:

```html
<app-header-layout has-scrolling-region style="width: 300px; height: 400px;">
  <app-header slot="header" fixed condenses effects="waterfall">
    <app-toolbar>
      <div main-title>App name</div>
    </app-toolbar>
  </app-header>
  <div>
    main content
  </div>
</app-header-layout>
```

Add the `fullbleed` attribute to app-header-layout to make it fit the size of
its container:

```html
<app-header-layout fullbleed>
 ...
</app-header-layout>
```

@element app-header-layout
@demo app-header-layout/demo/simple.html Simple Demo
@demo app-header-layout/demo/scrolling-region.html Scrolling Region
@demo app-header-layout/demo/music.html Music Demo
@demo app-header-layout/demo/footer.html Footer Demo
*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        display: block;
        /**
         * Force app-header-layout to have its own stacking context so that its parent can
         * control the stacking of it relative to other elements (e.g. app-drawer-layout).
         * This could be done using \`isolation: isolate\`, but that's not well supported
         * across browsers.
         */
        position: relative;
        z-index: 0;
      }

      #wrapper ::slotted([slot=header]) {
        @apply --layout-fixed-top;
        z-index: 1;
      }

      #wrapper.initializing ::slotted([slot=header]) {
        position: relative;
      }

      :host([has-scrolling-region]) {
        height: 100%;
      }

      :host([has-scrolling-region]) #wrapper ::slotted([slot=header]) {
        position: absolute;
      }

      :host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]) {
        position: relative;
      }

      :host([has-scrolling-region]) #wrapper #contentContainer {
        @apply --layout-fit;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      :host([has-scrolling-region]) #wrapper.initializing #contentContainer {
        position: relative;
      }

      :host([fullbleed]) {
        @apply --layout-vertical;
        @apply --layout-fit;
      }

      :host([fullbleed]) #wrapper,
      :host([fullbleed]) #wrapper #contentContainer {
        @apply --layout-vertical;
        @apply --layout-flex;
      }

      #contentContainer {
        /* Create a stacking context here so that all children appear below the header. */
        position: relative;
        z-index: 0;
      }

      @media print {
        :host([has-scrolling-region]) #wrapper #contentContainer {
          overflow-y: visible;
        }
      }

    </style>

    <div id="wrapper" class="initializing">
      <slot id="headerSlot" name="header"></slot>

      <div id="contentContainer">
        <slot></slot>
      </div>
    </div>
`,
  is: 'app-header-layout',
  behaviors: [AppLayoutBehavior],
  properties: {
    /**
     * If true, the current element will have its own scrolling region.
     * Otherwise, it will use the document scroll to control the header.
     */
    hasScrollingRegion: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    }
  },
  observers: ['resetLayout(isAttached, hasScrollingRegion)'],

  /**
   * A reference to the app-header element.
   *
   * @property header
   */
  get header() {
    return dom(this.$.headerSlot).getDistributedNodes()[0];
  },

  _updateLayoutStates: function () {
    var header = this.header;

    if (!this.isAttached || !header) {
      return;
    } // Remove the initializing class, which staticly positions the header and
    // the content until the height of the header can be read.


    this.$.wrapper.classList.remove('initializing'); // Update scroll target.

    header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement; // Get header height here so that style reads are batched together before
    // style writes (i.e. getBoundingClientRect() below).

    var headerHeight = header.offsetHeight; // Update the header position.

    if (!this.hasScrollingRegion) {
      requestAnimationFrame(function () {
        var rect = this.getBoundingClientRect();
        var rightOffset = document.documentElement.clientWidth - rect.right;
        header.style.left = rect.left + 'px';
        header.style.right = rightOffset + 'px';
      }.bind(this));
    } else {
      header.style.left = '';
      header.style.right = '';
    } // Update the content container position.


    var containerStyle = this.$.contentContainer.style;

    if (header.fixed && !header.condenses && this.hasScrollingRegion) {
      // If the header size does not change and we're using a scrolling region,
      // exclude the header area from the scrolling region so that the header
      // doesn't overlap the scrollbar.
      containerStyle.marginTop = headerHeight + 'px';
      containerStyle.paddingTop = '';
    } else {
      containerStyle.paddingTop = headerHeight + 'px';
      containerStyle.marginTop = '';
    }
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
app-toolbar is a horizontal toolbar containing items that can be used for
label, navigation, search and actions.

### Example

Add a title to the toolbar.

```html
<app-toolbar>
  <div main-title>App name</div>
</app-toolbar>
```

Add a button to the left and right side of the toolbar.

```html
<app-toolbar>
  <paper-icon-button icon="menu"></paper-icon-button>
  <div main-title>App name</div>
  <paper-icon-button icon="search"></paper-icon-button>
</app-toolbar>
```

You can use the attributes `top-item` or `bottom-item` to completely fit an
element to the top or bottom of the toolbar respectively.

### Content attributes

Attribute            | Description
---------------------|---------------------------------------------------------
`main-title`         | The main title element.
`condensed-title`    | The title element if used inside a condensed app-header.
`spacer`             | Adds a left margin of `64px`.
`bottom-item`        | Sticks the element to the bottom of the toolbar.
`top-item`           | Sticks the element to the top of the toolbar.

### Styling

Custom property              | Description                  | Default
-----------------------------|------------------------------|-----------------------
`--app-toolbar-font-size`    | Toolbar font size            | 20px

@element app-toolbar
@demo app-toolbar/demo/index.html
*/

Polymer({
  /** @override */
  _template: html`
    <style>

      :host {
        @apply --layout-horizontal;
        @apply --layout-center;
        position: relative;
        height: 64px;
        padding: 0 16px;
        pointer-events: none;
        font-size: var(--app-toolbar-font-size, 20px);
      }

      :host ::slotted(*) {
        pointer-events: auto;
      }

      :host ::slotted(paper-icon-button) {
        /* paper-icon-button/issues/33 */
        font-size: 0;
      }

      :host ::slotted([main-title]),
      :host ::slotted([condensed-title]) {
        pointer-events: none;
        @apply --layout-flex;
      }

      :host ::slotted([bottom-item]) {
        position: absolute;
        right: 0;
        bottom: 0;
        left: 0;
      }

      :host ::slotted([top-item]) {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
      }

      :host ::slotted([spacer]) {
        margin-left: 64px;
      }
    </style>

    <slot></slot>
`,
  is: 'app-toolbar'
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
app-box is a container element that can have scroll effects - visual effects
based on scroll position. For example, the parallax effect can be used to move
an image at a slower rate than the foreground.

```html
<app-box style="height: 100px;" effects="parallax-background">
  <img slot="background" src="picture.png" style="width: 100%; height: 600px;">
</app-box>
```

Notice the `background` attribute in the `img` element; this attribute specifies
that that image is used as the background. By adding the background to the light
dom, you can compose backgrounds that can change dynamically. Alternatively, the
mixin `--app-box-background-front-layer` allows to style the background. For
example:

```css
  .parallaxAppBox {
    --app-box-background-front-layer: {
      background-image: url(picture.png);
    };
  }
```

Finally, app-box can have content inside. For example:

```html
<app-box effects="parallax-background">
  <h2>Sub title</h2>
</app-box>
```

#### Importing the effects

To use the scroll effects, you must explicitly import them in addition to
`app-box`:

```js
import '@polymer/app-layout/app-scroll-effects/app-scroll-effects.js';
```

#### List of effects

* **parallax-background**
A simple parallax effect that vertically translates the backgrounds based on a
fraction of the scroll position. For example:

```css
app-header {
  --app-header-background-front-layer: {
    background-image: url(...);
  };
}
```
```html
<app-header style="height: 300px;" effects="parallax-background">
  <app-toolbar>App name</app-toolbar>
</app-header>
```

The fraction determines how far the background moves relative to the scroll
position. This value can be assigned via the `scalar` config value and it is
typically a value between 0 and 1 inclusive. If `scalar=0`, the background
doesn't move away from the header.

## Styling

Mixin | Description | Default
----------------|-------------|----------
`--app-box-background-front-layer` | Applies to the front layer of the background | {}

@element app-box
@demo app-box/demo/document-scroll.html Document Scroll
@demo app-box/demo/scrolling-region.html Scrolling Region
*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        position: relative;
        display: block;
      }

      #background {
        @apply --layout-fit;
        overflow: hidden;
        height: 100%;
      }

      #backgroundFrontLayer {
        min-height: 100%;
        pointer-events: none;
        background-size: cover;
        @apply --app-box-background-front-layer;
      }

      #contentContainer {
        position: relative;
        width: 100%;
        height: 100%;
      }

      :host([disabled]),
      :host([disabled]) #backgroundFrontLayer {
        transition: none !important;
      }
    </style>

    <div id="background">
      <div id="backgroundFrontLayer">
        <slot name="background"></slot>
      </div>
    </div>
    <div id="contentContainer">
      <slot></slot>
    </div>
`,
  is: 'app-box',
  behaviors: [AppScrollEffectsBehavior, IronResizableBehavior],
  listeners: {
    'iron-resize': '_resizeHandler'
  },

  /**
   * The current scroll progress.
   *
   * @type {number}
   */
  _progress: 0,

  /** @override */
  attached: function () {
    this.resetLayout();
  },
  _debounceRaf: function (fn) {
    var self = this;

    if (this._raf) {
      window.cancelAnimationFrame(this._raf);
    }

    this._raf = window.requestAnimationFrame(function () {
      self._raf = null;
      fn.call(self);
    });
  },

  /**
   * Resets the layout. This method is automatically called when the element is
   * attached to the DOM.
   *
   * @method resetLayout
   */
  resetLayout: function () {
    this._debounceRaf(function () {
      // noop if the box isn't in the rendered tree
      if (this.offsetWidth === 0 && this.offsetHeight === 0) {
        return;
      }

      var scrollTop = this._clampedScrollTop;
      var savedDisabled = this.disabled;
      this.disabled = true;
      this._elementTop = this._getElementTop();
      this._elementHeight = this.offsetHeight;
      this._cachedScrollTargetHeight = this._scrollTargetHeight;

      this._setUpEffect();

      this._updateScrollState(scrollTop);

      this.disabled = savedDisabled;
    });
  },
  _getElementTop: function () {
    var currentNode = this;
    var top = 0;

    while (currentNode && currentNode !== this.scrollTarget) {
      top += currentNode.offsetTop;
      currentNode = currentNode.offsetParent;
    }

    return top;
  },
  _updateScrollState: function (scrollTop) {
    if (this.isOnScreen()) {
      var viewportTop = this._elementTop - scrollTop;
      this._progress = 1 - (viewportTop + this._elementHeight) / this._cachedScrollTargetHeight;

      this._runEffects(this._progress, scrollTop);
    }
  },

  /**
   * Returns true if this app-box is on the screen.
   * That is, visible in the current viewport.
   *
   * @method isOnScreen
   * @return {boolean}
   */
  isOnScreen: function () {
    return this._elementTop < this._scrollTop + this._cachedScrollTargetHeight && this._elementTop + this._elementHeight > this._scrollTop;
  },
  _resizeHandler: function () {
    this.resetLayout();
  },
  _getDOMRef: function (id) {
    if (id === 'background') {
      return this.$.background;
    }

    if (id === 'backgroundFrontLayer') {
      return this.$.backgroundFrontLayer;
    }
  },

  /**
   * Returns an object containing the progress value of the scroll effects.
   *
   * @method getScrollState
   * @return {Object}
   */
  getScrollState: function () {
    return {
      progress: this._progress
    };
  }
});

/**
 * A container for different views. Only one view will be shown at a time.
 * Provides a dropdown for the user to switch between views. Views are
 * lazy loaded and should be provided as one or more `<template>` elements.
 * Each `<template>` may have a title attribute to specify the title to be shown
 * for it in the dropdown.
 *
 * @slot - unnamed default slot for content
 * @slot toolbar - toolbar area
 * @fires pb-panel - Fired whenever the component switches to a different content panel. Used by `pb-grid` to update its state.
 * @fires pb-refresh - Fired after a new content panel is shown to allow connected components to refresh.
 * @cssprop --pb-panel-max-height - The max height of the panel content. Set to enable scrolling.
 */

class PbPanel extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * the index of the active view
       */
      active: {
        type: Number,
        reflect: true
      },

      /**
       * the label displayed above the dropdown for selecting the view to show
       */
      label: {
        type: String
      },

      /**
       * a name for each available panel, to be displayed in the dropdown. If not set,
       * each template will be checked for a title attribute, which will be taken as name.
       */
      panels: {
        type: Array,
        reflect: true
      }
    });
  }

  constructor() {
    super();
    this.active = 0;
    this.label = 'View';
    this.panels = null;
  }

  connectedCallback() {
    super.connectedCallback();

    if (!this.panels) {
      const titles = [];
      this.querySelectorAll('template').forEach(template => titles.push(template.title));
      this.panels = titles;
    }

    this._show();
  }

  render() {
    return html$1`
            <app-toolbar>
                <paper-dropdown-menu id="menu" label="${this.label}">
                    <paper-listbox id="panels" slot="dropdown-content" class="dropdown-content" 
                        selected="${this.active}" @selected-item-changed="${this._update}">
                    ${this.panels.map(item => html$1`<paper-item>${item}</paper-item>`)}
                    </paper-listbox>
                </paper-dropdown-menu>
                <slot name="toolbar"></slot>
            </app-toolbar>
            <slot></slot>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            app-toolbar {
                padding: 0;
                justify-content: space-between;
            }

            ::slotted(._pb_panel) {
                overflow: auto;
                max-height: calc(var(--pb-panel-max-height) - 72px);
            }

            app-toolbar {
                font-size: 75%;
            }
        `;
  }

  _update() {
    const panel = this.shadowRoot.getElementById('panels').selected;

    if (this.active !== panel) {
      this.active = panel;

      this._show();
    }
  }

  _show() {
    const templates = this.querySelectorAll('template');

    if (this.active >= templates.length) {
      this.active = templates.length - 1;
    }

    console.log('<pb-panel> showing panel %s', this.active);
    this.querySelectorAll('._pb_panel').forEach(div => div.style.display = 'none');
    const existingPanel = this.querySelector('._pb_panel' + this.active);

    if (existingPanel) {
      existingPanel.style.display = '';
    } else {
      const template = templates[this.active];
      const clone = document.importNode(template.content, true);
      const div = document.createElement('div');
      div.className = '_pb_panel _pb_panel' + this.active;
      div.appendChild(clone);
      this.appendChild(div);
      this.emitTo('pb-panel', {
        panel: this,
        active: this.active
      }); // this.refresh();
    }
  }

  refresh() {
    this.emitTo('pb-refresh', null);
  }

}
customElements.define('pb-panel', PbPanel);

/**
 * A component to create a column layout based upon CSS grid. It offers methods for dynamically changing
 * the layout by adding or removing panels at runtime.
 *
 * @slot - default unnamed slot for the panel
 * @fires pb-refresh - Fired after a new column has been added to allow connected components to refresh.
 * @fires pb-panel - When received, updates the list of panels to show
 * @cssprop --pb-grid-column-widths - Columns width specified according to the grid-template-columns property of the CSS Grid Layout
 * @cssprop --pb-grid-column-gap - Width of the gap between columns
 */

class PbGrid extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * an array of panel items to display when the component is loaded. It should contain a
       * number for each panel to show, indicating the ordinal position of the template within the `<pb-panel>`
       * to initialize. For example, if you have two templates in `<pb-panel>`: "transcription" and "translation",
       * setting `panels="[0, 1]"` will show two columns, one with the transcription, the other with the translation.
       *
       * Passing in a browser parameter `panels` with a comma-separated list will set this property as well.
       */
      panels: {
        type: Array
      },
      direction: {
        type: String
      },

      /**
       * the number of columns
       */
      _columns: {
        type: Number
      },

      /**
       * CSS Selektor to choose elements to animate. If not specified all 'pb-view' elements will be animated by default.
       */
      animated: {
        type: String
      },

      /**
       * wether to animate the view when new page is loaded. Defaults to 'false' meaning that no
       * animation takes place.
       */
      animation: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.direction = 'ltr';
    this.animated = 'pb-view';
    this.animation = false;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-panel', ev => {
      const idx = Array.from(this.shadowRoot.querySelectorAll('._grid_panel')).indexOf(ev.detail.panel);

      if (idx > 0) {
        console.log('<pb-grid> Updating panel %d to show %s', idx, ev.detail.active);
        this.panels[idx] = ev.detail.active;
        localStorage.setItem('pb-grid.panels', this.panels.join('.'));
        this.setParameter('panels', this.panels.join('.'));
        this.pushHistory('added panel');
      }
    });
    const panelsParam = this.getParameter('panels');

    if (panelsParam) {
      this.panels = panelsParam.split('.').map(param => parseInt(param));
      localStorage.setItem('pb-grid.panels', this.panels.join('.'));
    } else {
      const panelsStored = localStorage.getItem('pb-grid.panels');

      if (panelsStored) {
        this.panels = panelsStored.split('.').map(param => parseInt(param));
      }
    }

    this._columns = this.panels.length;
    this.template = this.querySelector('template');
  }

  firstUpdated() {
    this.panels.forEach(panelNum => this._insertPanel(panelNum));

    this._animate();

    this._update();
  }
  /**
   * slides in all panels from left to right with a slight delay between the panels. If animejs is not
   * loaded nothing happens and content is displayed as usual.
   */


  _animate() {
    if (this.animation) {
      if (typeof anime && "anime" in window) {
        // console.log('animated elements', document.querySelectorAll('pb-panel'));
        const animated = document.querySelectorAll(this.animated);
        const anim = anime.timeline({
          easing: 'linear',
          duration: 400
        });
        anim.add({
          targets: animated,
          opacity: {
            value: [0, 0.6],
            duration: 200,
            delay: 100,
            easing: 'linear'
          },
          translateX: [2000, 0],
          duration: 400,
          delay: anime.stagger(100, {
            start: 100
          })
        });
        anim.add({
          targets: animated,
          opacity: [0.6, 1],
          duration: 200,
          delay: anime.stagger(50)
        });
        anim.play();
      }
    }
  }

  addPanel(initial) {
    if (!initial) {
      if (this.panels.length > 0) {
        const max = this.panels.reduce(function (a, b) {
          return Math.max(a, b);
        });
        initial = max + 1;
      } else {
        initial = 0;
      }
    }

    this._columns++;
    this.panels.push(initial);
    localStorage.setItem('pb-grid.panels', this.panels.join('.'));
    this.setParameter('panels', this.panels.join('.'));
    this.pushHistory('added panel');

    this._insertPanel(initial);

    this._update();

    this.emitTo('pb-refresh', null);
  }

  removePanel(panel) {
    const idx = Array.from(this.querySelectorAll('._grid_panel')).indexOf(panel);
    console.log('<pb-grid> Removing panel %d', idx);
    this.panels.splice(idx, 1);
    this.setParameter('panels', this.panels.join('.'));
    localStorage.setItem('pb-grid.panels', this.panels.join('.'));
    this.pushHistory('removed panel');
    panel.parentNode.removeChild(panel);
    this._columns--;

    this._update();
  }

  _insertPanel(active) {
    const clone = document.importNode(this.template.content.firstElementChild, true);
    clone.setAttribute('active', active);

    if (this.direction === 'ltr' || this.querySelectorAll('._grid_panel').length === 0) {
      this.appendChild(clone);
    } else {
      this.insertBefore(clone, this.firstElementChild);
    }

    clone.classList.add('_grid_panel');
  }

  _update() {
    const widths = [];
    Array.from(this.children).forEach(child => {
      if (child instanceof HTMLTemplateElement) {
        return;
      }

      const styles = window.getComputedStyle(child);
      const width = styles.getPropertyValue('max-width');

      if (width && width !== 'none') {
        widths.push(width);
      } else {
        widths.push('1fr');
      }
    });
    this.style.setProperty('--pb-computed-column-widths', widths.join(' '));
  }

  render() {
    return html$1`<slot></slot>`;
  }

  static get styles() {
    return css`
            :host {
                display: grid;
                grid-template-columns: var(--pb-grid-column-widths, var(--pb-computed-column-widths));
                grid-column-gap: var(--pb-grid-column-gap, 20px);
                justify-content: space-between;
            }
        `;
  }

}
customElements.define('pb-grid', PbGrid);

/**
 * an action component to execute an 'add panel' or 'remove panel' action on a pb-grid.
 *
 * @slot - default unnamed slot for content
 * 
 */

class PbGridAction extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * the type of action. Can be either `add` or `remove`
       *
       * Defaults to `add`
       */
      action: {
        type: String
      },

      /**
       * reference to a pb-grid element
       */
      grid: {
        type: String
      },
      initial: {
        type: Number
      }
    });
  }

  constructor() {
    super();
    this.action = 'add';
    this.initial = 0;
  }

  connectedCallback() {
    super.connectedCallback();
  }

  render() {
    return html$1`
            <a @click="${this._click}"><slot></slot></a>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
        `;
  }

  _click() {
    // todo: grid must be in lightDOM to be discovered. What is expected for this.grid? A string like '#myId'?
    const grid = document.querySelector(this.grid);

    if (!(grid && grid.addPanel)) {
      return console.error('<pb-grid-action> grid not found: %s', this.grid);
    }

    if (this.action === 'add') {
      grid.addPanel(this.initial);
    } else {
      grid.removePanel(this.parentNode);
    }
  }

}
customElements.define('pb-grid-action', PbGridAction);

/**
 * Show content if the user is logged in. Optionally requires the user
 * to be member of a specific group. Listens for the `pb-login` event
 * triggered by `pb-login` to be notified of user changes.
 * 
 * You may specify fallback content to be shown if the user is not logged in
 * within a slot named 'fallback'.
 *
 * @slot - unnamed default slot
 * @slot fallback - optional content to show if user is not logged in
 * @fires pb-login - When received, changes the state of the component according to the user info received
 */

class PbRestricted extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** Id of the pb-login element to connect to */
      login: {
        type: String
      },
      show: {
        type: Boolean,
        reflect: true
      },

      /**
       * If set, requires the logged in user to be member of
       * the given group.
       */
      group: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.show = false;
  }

  firstUpdated() {
    const fallback = this.shadowRoot.querySelector('slot[name=fallback]');
    const hasFallback = fallback.assignedNodes().length > 0;

    if (hasFallback) {
      console.log(this);
      this.classList.add('fallback');
    }

    const login = document.getElementById(this.login);

    if (!login) {
      console.error('<pb-restricted> connected pb-login element not found!');
      return;
    }

    this.subscribeTo('pb-login', ev => {
      this.show = this._loggedIn(ev.detail.user, ev.detail.groups);
    }, []);
    this.show = login.loggedIn && this._loggedIn(login.user, login.groups);
  }

  render() {
    return html$1`
            ${this.show && !this.disabled ? html$1`<slot></slot>` : html$1`<slot name="fallback"></slot>`}
        `;
  }

  static get styles() {
    return css`
            :host {
                display: none;
            }

            :host(.fallback), :host([show]) {
                display: block;
            }
        `;
  }

  _loggedIn(user, groups) {
    if (user == null) {
      return false;
    }

    if (this.group) {
      if (!groups) {
        return false;
      }

      return groups.indexOf(this.group) > -1;
    }

    return true;
  }

}
customElements.define('pb-restricted', PbRestricted);

/**
 * High-level component implementing the ODD management panel
 * on the start page.
 * @fires pb-start-update - Fired before the element updates its content
 * @fires pb-end-update - Fired after the element has finished updating its content
 * @fires pb-load - Sending the ODD to be used
 * @fires pb-refresh-odds When received, refresh the list of ODDs
 */

class PbManageOdds extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * array of ODD-files to be listed
       */
      odds: {
        type: Array
      },
      target: {
        type: String
      },
      _valid: {
        type: Boolean
      },
      _current: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.odds = [];
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-login', () => this._refresh(), []);
    this.subscribeTo('pb-refresh-odds', ev => {
      this._refresh(); // regenerate newly uploaded ODDs


      const regenAjax = this.shadowRoot.getElementById('regenerate');
      const params = ev.detail.odds.map(odd => `odd=${odd}`).join('&');

      if (this.minApiVersion('1.0.0')) {
        regenAjax.url = `api/odd?${params}`;
      } else {
        regenAjax.url = `modules/lib/regenerate.xql?${params}`;
      }

      regenAjax.trigger();
    });
  }

  firstUpdated() {
    super.firstUpdated();
    this._loader = this.shadowRoot.getElementById('load');
    PbManageOdds.waitOnce('pb-page-ready', options => {
      if (cmpVersion(options.apiVersion, '1.0.0') < 0) {
        this._loader.url = `${options.endpoint}/modules/lib/components-odd.xql`;
      } else {
        this._loader.url = `${options.endpoint}/api/odd`;
      }

      this._refresh();
    });
  }

  _refresh(params) {
    this.emitTo('pb-start-update');
    this._loader.params = params;

    this._loader.generateRequest();
  }

  _update() {
    this.emitTo('pb-end-update');
    this.odds = this._loader.lastResponse;
  }

  _selectODD(ev) {
    const selected = ev.model.itemsIndex;
    this.odds.forEach((odd, index) => {
      if (index !== selected && odd.current) {
        this.set('odds.' + index + '.current', false);
        this.set('odds.' + selected + '.current', true);
      }
    });
    const params = {
      odd: ev.model.item.name + '.odd'
    };
    console.log('<pb-manage-odds> selected ODD: %o', params);
    this.emitTo('pb-load', {
      "params": params
    });
  }

  _createODD() {
    const name = this.shadowRoot.querySelector('paper-input[name="new_odd"]').value;
    const title = this.shadowRoot.querySelector('paper-input[name="title"]').value;
    console.log('<pb-manage-odds> create ODD: %s, %s', name, title);

    if (this.lessThanApiVersion('1.0.0')) {
      this._refresh({
        new_odd: name,
        title
      });
    } else {
      const createRequest = this.shadowRoot.getElementById('create');
      createRequest.url = `${this.getEndpoint()}/api/odd/${name}`;
      createRequest.params = {
        title
      };
      this.emitTo('pb-start-update');
      createRequest.generateRequest();
    }
  }

  _created(ev) {
    this.emitTo('pb-end-update');

    if (ev.detail.status === 201) {
      this._refresh();
    } else {
      console.log('<pb-manage-odds> unexpected response for create odd: %o', ev.detail);
    }
  }

  _createByExample() {
    const name = this.shadowRoot.querySelector('paper-input[name="new_odd"]').value;
    const title = this.shadowRoot.querySelector('paper-input[name="title"]').value;
    const params = {
      new_odd: name,
      title
    };
    const fileBrowser = document.getElementById(this.target);

    if (!(fileBrowser || fileBrowser.getSelected)) {
      console.error('<pb-manage-odds> target %s not found', this.target);
    }

    const selected = fileBrowser.getSelected();
    document.querySelectorAll('.document-select paper-checkbox[checked]').forEach(checkbox => {
      selected.push(checkbox.value);
    });
    console.log('<pb-manage-odds> create ODD by example: %o', selected);
    params['byExample'] = selected;

    this._refresh(params);
  }

  _delete(odd) {
    this._current = odd;
    this.shadowRoot.getElementById('deleteDialog').open();
  }

  _confirmDelete() {
    if (this._current) {
      console.log('<pb-manage-odds> deleting ODD: %s', this._current);

      if (this.lessThanApiVersion('1.0.0')) {
        this._refresh({
          'delete': this._current
        });
      } else {
        this.emitTo('pb-start-update');
        const deleteRequest = this.shadowRoot.getElementById('delete');
        deleteRequest.url = `${this.getEndpoint()}/api/odd/${this._current}`;
        deleteRequest.generateRequest();
      }

      this._current = null;
    } else {
      console.error('<pb-manage-odds> no file marked for deletion');
    }
  }

  _deleted() {
    const deleteRequest = this.shadowRoot.getElementById('delete');
    const error = deleteRequest.lastError;

    if (error.status === 410) {
      this._refresh();
    } else {
      console.error('<pb-manage-odds> failed to delete odd: %d %o', error.status, error.response);
      this.emitTo('pb-end-update');
    }
  }

  _validate() {
    // Validate the entire form to see if we should enable the `Submit` button.
    const valid = this.shadowRoot.getElementById('ironform').validate();
    this.shadowRoot.getElementById('createBtn').disabled = !valid;
    this.shadowRoot.getElementById('createByEx').disabled = !valid;
  }

  render() {
    if (!this.odds) {
      return null;
    }

    const regenUrl = this.lessThanApiVersion('1.0.0') ? 'modules/lib/regenerate.xql' : "api/odd";
    return html$1`
            <pb-restricted login="login">
                <pb-ajax id="regenerateAll" url="${regenUrl}" method="post" title="${translate('odd.manage.regenerate-all')}"
                    emit="${this.emit ? this.emit : ''}" .emitConfig="${this.emitConfig}">
                    <h3 slot="title">${translate('odd.manage.regenerate-all')}</h3>
                    <a href="#">${translate('odd.manage.regenerate-all')}</a>
                </pb-ajax>
            </pb-restricted>
            ${this.odds.map(odd => html$1`
                <div class="odd">
                    <a href="odd-editor.html?odd=${odd.name}.odd" target="_blank">${odd.label}</a>
                    <!-- TODO this toolbar should only appear once per ODD files papercard -->
                    <app-toolbar>
                        ${odd.canWrite ? html$1`
                                    <pb-restricted login="login">
                                        <pb-ajax url="${regenUrl}?odd=${odd.name}.odd" method="post" 
                                            emit="${this.emit ? this.emit : ''}" .emitConfig="${this.emitConfig}">
                                            <h2 slot="title">${translate('menu.admin.recompile')}</h2>
                                            <paper-icon-button title="Regenerate ODD" icon="update"></paper-icon-button>
                                        </pb-ajax>
                                        <paper-icon-button title="Delete ODD" icon="delete" @click="${() => this._delete(`${odd.name}.odd`)}"></paper-icon-button>
                                    </pb-restricted>
                                ` : null}
                        <pb-edit-xml path="${odd.path}">
                            <paper-icon-button title="Edit ODD" icon="code"></paper-icon-button>
                        </pb-edit-xml>
                    </app-toolbar>
                </div>
                <div class="odd-description">${odd.description}</div>
            `)}
            <pb-restricted login="login">
                <form action="" method="GET">
                    <paper-input name="new_odd" label="${translate('odd.manage.filename')}" required auto-validate pattern="[a-zA-Z0-9-_]+"
                        error-message="${translate('odd.manage.filename-error')}"></paper-input>
                    <paper-input name="title" label="${translate('odd.manage.title')}" auto-validate required minlength="1"
                        error-message="${translate('odd.manage.title-error')}"></paper-input>
                    <paper-button id="createBtn" @click="${this._createODD}">
                        <iron-icon icon="create"></iron-icon>${translate('odd.manage.create')}
                    </paper-button>
                    <!--paper-button id="createByEx" @click="${this._createByExample}">
                        <iron-icon icon="build"></iron-icon>
                        ${translate('odd.manage.create-from-example')}
                    </paper-button-->
                </form>
            </pb-restricted>
            <pb-ajax id="regenerate" url="${regenUrl}" method="post"></pb-ajax>
            <iron-ajax
                id="load"
                verbose
                handle-as="json"
                method="get"
                with-credentials
                @response="${this._update}">
            </iron-ajax>
            <iron-ajax id="delete" method="delete" with-credentials @error="${this._deleted}"></iron-ajax>
            <iron-ajax id="create" method="post" with-credentials @response="${this._created}" @error="${this._created}"></iron-ajax>
            <paper-dialog id="deleteDialog">
                <h2>${translate('browse.delete')}</h2>
                <paper-dialog-scrollable>
                    <p>${translate('odd.manage.delete', {
      file: this.file
    })}</p>
                </paper-dialog-scrollable>
                <div class="buttons">
                    <paper-button dialog-confirm="dialog-confirm" autofocus @click="${this._confirmDelete}">
                        ${translate('dialogs.yes')}
                    </paper-button>
                    <paper-button dialog-confirm="dialog-cancel">
                        ${translate('dialogs.no')}
                    </paper-button>
                </div>
            </paper-dialog>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            .odd {
                display: flex;
                flex-direction: row;
                align-items: center;
            }

            .odd paper-checkbox {
                display: block;
                flex: 0 0;
                margin-right: 1em;
            }

            .odd a {
                display: block;
                flex: 2 0;
            }

            .odd app-toolbar {
                flex: 1 0;
                justify-content: flex-end;  
                padding: 0;  
            }

            pb-restricted {
                display: flex;
            }

            .odd-description {
                color: #888888;
                font-size: 0.8em;
                margin-top: -1em;
            }

            #regenerateAll {
                display: block;
                width: 100%;
                margin-top: 10px;
                text-align: right;
            }
        `;
  }

}
customElements.define('pb-manage-odds', PbManageOdds);

const $_documentContainer$1 = document.createElement('template');
$_documentContainer$1.innerHTML = `<dom-module id="lumo-field-button">
  <template>
    <style>
      [part\$="button"] {
        flex: none;
        width: 1em;
        height: 1em;
        line-height: 1;
        font-size: var(--lumo-icon-size-m);
        text-align: center;
        color: var(--lumo-contrast-60pct);
        transition: 0.2s color;
        cursor: var(--lumo-clickable-cursor);
      }

      :host(:not([readonly])) [part\$="button"]:hover {
        color: var(--lumo-contrast-90pct);
      }

      :host([disabled]) [part\$="button"],
      :host([readonly]) [part\$="button"] {
        color: var(--lumo-contrast-20pct);
      }

      [part\$="button"]::before {
        font-family: "lumo-icons";
        display: block;
      }
    </style>
  </template>
</dom-module>`;
document.head.appendChild($_documentContainer$1.content);

const $_documentContainer$2 = html`<dom-module id="lumo-button" theme-for="vaadin-button">
  <template>
    <style>
      :host {
        /* Sizing */
        --lumo-button-size: var(--lumo-size-m);
        min-width: calc(var(--lumo-button-size) * 2);
        height: var(--lumo-button-size);
        padding: 0 calc(var(--lumo-button-size) / 3 + var(--lumo-border-radius) / 2);
        margin: var(--lumo-space-xs) 0;
        box-sizing: border-box;
        /* Style */
        font-family: var(--lumo-font-family);
        font-size: var(--lumo-font-size-m);
        font-weight: 500;
        color: var(--_lumo-button-color, var(--lumo-primary-text-color));
        background-color: var(--_lumo-button-background-color, var(--lumo-contrast-5pct));
        border-radius: var(--lumo-border-radius);
        cursor: default;
        -webkit-tap-highlight-color: transparent;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* Set only for the internal parts so we dont affect the host vertical alignment */
      [part="label"],
      [part="prefix"],
      [part="suffix"] {
        line-height: var(--lumo-line-height-xs);
      }

      [part="label"] {
        padding: calc(var(--lumo-button-size) / 6) 0;
      }

      :host([theme~="small"]) {
        font-size: var(--lumo-font-size-s);
        --lumo-button-size: var(--lumo-size-s);
      }

      :host([theme~="large"]) {
        font-size: var(--lumo-font-size-l);
        --lumo-button-size: var(--lumo-size-l);
      }

      /* This needs to be the last selector for it to take priority */
      :host([disabled][disabled]) {
        pointer-events: none;
        color: var(--lumo-disabled-text-color);
        background-color: var(--lumo-contrast-5pct);
      }

      /* For interaction states */
      :host::before,
      :host::after {
        content: "";
        /* We rely on the host always being relative */
        position: absolute;
        z-index: 1;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: currentColor;
        border-radius: inherit;
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
      }

      /* Hover */

      :host(:hover)::before {
        opacity: 0.05;
      }

      /* Disable hover for touch devices */
      @media (pointer: coarse) {
        :host(:not([active]):hover)::before {
          opacity: 0;
        }
      }

      /* Active */

      :host::after {
        transition: opacity 1.4s, transform 0.1s;
        filter: blur(8px);
      }

      :host([active])::before {
        opacity: 0.1;
        transition-duration: 0s;
      }

      :host([active])::after {
        opacity: 0.1;
        transition-duration: 0s, 0s;
        transform: scale(0);
      }

      /* Keyboard focus */

      :host([focus-ring]) {
        box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
      }

      /* Types (primary, tertiary, tertiary-inline */

      :host([theme~="tertiary"]),
      :host([theme~="tertiary-inline"]) {
        background-color: transparent !important;
        transition: opacity 0.2s;
        min-width: 0;
      }

      :host([theme~="tertiary"])::before,
      :host([theme~="tertiary-inline"])::before {
        display: none;
      }

      :host([theme~="tertiary"]) {
        padding: 0 calc(var(--lumo-button-size) / 6);
      }

      @media (hover: hover) {
        :host([theme*="tertiary"]:not([active]):hover) {
          opacity: 0.8;
        }
      }

      :host([theme~="tertiary"][active]),
      :host([theme~="tertiary-inline"][active]) {
        opacity: 0.5;
        transition-duration: 0s;
      }

      :host([theme~="tertiary-inline"]) {
        margin: 0;
        height: auto;
        padding: 0;
        line-height: inherit;
        font-size: inherit;
      }

      :host([theme~="tertiary-inline"]) [part="label"] {
        padding: 0;
        overflow: visible;
        line-height: inherit;
      }

      :host([theme~="primary"]) {
        background-color: var(--_lumo-button-primary-background-color, var(--lumo-primary-color));
        color: var(--_lumo-button-primary-color, var(--lumo-primary-contrast-color));
        font-weight: 600;
        min-width: calc(var(--lumo-button-size) * 2.5);
      }

      :host([theme~="primary"][disabled]) {
        background-color: var(--lumo-primary-color-50pct);
        color: var(--lumo-primary-contrast-color);
      }

      :host([theme~="primary"]:hover)::before {
        opacity: 0.1;
      }

      :host([theme~="primary"][active])::before {
        background-color: var(--lumo-shade-20pct);
      }

      @media (pointer: coarse) {
        :host([theme~="primary"][active])::before {
          background-color: var(--lumo-shade-60pct);
        }

        :host([theme~="primary"]:not([active]):hover)::before {
          opacity: 0;
        }
      }

      :host([theme~="primary"][active])::after {
        opacity: 0.2;
      }

      /* Colors (success, error, contrast) */

      :host([theme~="success"]) {
        color: var(--lumo-success-text-color);
      }

      :host([theme~="success"][theme~="primary"]) {
        background-color: var(--lumo-success-color);
        color: var(--lumo-success-contrast-color);
      }

      :host([theme~="success"][theme~="primary"][disabled]) {
        background-color: var(--lumo-success-color-50pct);
      }

      :host([theme~="error"]) {
        color: var(--lumo-error-text-color);
      }

      :host([theme~="error"][theme~="primary"]) {
        background-color: var(--lumo-error-color);
        color: var(--lumo-error-contrast-color);
      }

      :host([theme~="error"][theme~="primary"][disabled]) {
        background-color: var(--lumo-error-color-50pct);
      }

      :host([theme~="contrast"]) {
        color: var(--lumo-contrast);
      }

      :host([theme~="contrast"][theme~="primary"]) {
        background-color: var(--lumo-contrast);
        color: var(--lumo-base-color);
      }

      :host([theme~="contrast"][theme~="primary"][disabled]) {
        background-color: var(--lumo-contrast-50pct);
      }

      /* Icons */

      [part] ::slotted(iron-icon) {
        display: inline-block;
        width: var(--lumo-icon-size-m);
        height: var(--lumo-icon-size-m);
      }

      /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
      [part] ::slotted(iron-icon[icon^="vaadin:"]) {
        padding: 0.25em;
        box-sizing: border-box !important;
      }

      [part="prefix"] {
        margin-left: -0.25em;
        margin-right: 0.25em;
      }

      [part="suffix"] {
        margin-left: 0.25em;
        margin-right: -0.25em;
      }

      /* Icon-only */

      :host([theme~="icon"]:not([theme~="tertiary-inline"])) {
        min-width: var(--lumo-button-size);
        padding-left: calc(var(--lumo-button-size) / 4);
        padding-right: calc(var(--lumo-button-size) / 4);
      }

      :host([theme~="icon"]) [part="prefix"],
      :host([theme~="icon"]) [part="suffix"] {
        margin-left: 0;
        margin-right: 0;
      }

      /* RTL specific styles */

      :host([dir="rtl"]) [part="prefix"] {
        margin-left: 0.25em;
        margin-right: -0.25em;
      }

      :host([dir="rtl"]) [part="suffix"] {
        margin-left: -0.25em;
        margin-right: 0.25em;
      }

      :host([dir="rtl"][theme~="icon"]) [part="prefix"],
      :host([dir="rtl"][theme~="icon"]) [part="suffix"] {
        margin-left: 0;
        margin-right: 0;
      }
    </style>
  </template>
</dom-module>`;
document.head.appendChild($_documentContainer$2.content);

/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
// We consider the keyboard to be active if the window has received a keydown
// event since the last mousedown event.
let keyboardActive = false; // Listen for top-level keydown and mousedown events.
// Use capture phase so we detect events even if they're handled.

window.addEventListener('keydown', () => {
  keyboardActive = true;
}, {
  capture: true
});
window.addEventListener('mousedown', () => {
  keyboardActive = false;
}, {
  capture: true
});
/**
 * A private mixin to avoid problems with dynamic properties and Polymer Analyzer.
 * No need to expose these properties in the API docs.
 * @polymerMixin
 * @private
 */

const TabIndexMixin = superClass => class VaadinTabIndexMixin extends superClass {
  static get properties() {
    var properties = {
      /**
       * Internal property needed to listen to `tabindex` attribute changes.
       *
       * For changing the tabindex of this component use the native `tabIndex` property.
       * @private
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true,
        observer: '_tabindexChanged'
      }
    };

    if (window.ShadyDOM) {
      // ShadyDOM browsers need the `tabIndex` in order to notify when the user changes it programmatically.
      properties['tabIndex'] = properties.tabindex;
    }

    return properties;
  }

};
/**
 * Polymer.IronControlState is not a proper 2.0 class, also, its tabindex
 * implementation fails in the shadow dom, so we have this for vaadin elements.
 * @polymerMixin
 */


const ControlStateMixin = superClass => class VaadinControlStateMixin extends TabIndexMixin(superClass) {
  static get properties() {
    return {
      /**
       * Specify that this control should have input focus when the page loads.
       */
      autofocus: {
        type: Boolean
      },

      /**
       * Stores the previous value of tabindex attribute of the disabled element
       * @private
       */
      _previousTabIndex: {
        type: Number
      },

      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      /**
       * @private
       */
      _isShiftTabbing: {
        type: Boolean
      }
    };
  }
  /**
   * @protected
   */


  ready() {
    this.addEventListener('focusin', e => {
      if (e.composedPath()[0] === this) {
        // Only focus if the focus is received from somewhere outside
        if (!this.contains(e.relatedTarget)) {
          this._focus();
        }
      } else if (e.composedPath().indexOf(this.focusElement) !== -1 && !this.disabled) {
        this._setFocused(true);
      }
    });
    this.addEventListener('focusout', e => this._setFocused(false)); // In super.ready() other 'focusin' and 'focusout' listeners might be
    // added, so we call it after our own ones to ensure they execute first.
    // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the
    // input field on iOS after Done is pressed.

    super.ready(); // This fixes the bug in Firefox 61 (https://bugzilla.mozilla.org/show_bug.cgi?id=1472887)
    // where focusout event does not go out of shady DOM because composed property in the event is not true

    const ensureEventComposed = e => {
      if (!e.composed) {
        e.target.dispatchEvent(new CustomEvent(e.type, {
          bubbles: true,
          composed: true,
          cancelable: false
        }));
      }
    };

    this.shadowRoot.addEventListener('focusin', ensureEventComposed);
    this.shadowRoot.addEventListener('focusout', ensureEventComposed);
    this.addEventListener('keydown', e => {
      if (!e.defaultPrevented && e.keyCode === 9) {
        if (e.shiftKey) {
          // Flag is checked in _focus event handler.
          this._isShiftTabbing = true;
          HTMLElement.prototype.focus.apply(this);

          this._setFocused(false); // Event handling in IE is asynchronous and the flag is removed asynchronously as well


          setTimeout(() => this._isShiftTabbing = false, 0);
        } else {
          // Workaround for FF63-65 bug that causes the focus to get lost when
          // blurring a slotted component with focusable shadow root content
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1528686
          // TODO: Remove when safe
          const firefox = window.navigator.userAgent.match(/Firefox\/(\d\d\.\d)/);

          if (firefox && parseFloat(firefox[1]) >= 63 && parseFloat(firefox[1]) < 66 && this.parentNode && this.nextSibling) {
            const fakeTarget = document.createElement('input');
            fakeTarget.style.position = 'absolute';
            fakeTarget.style.opacity = '0';
            fakeTarget.tabIndex = this.tabIndex;
            this.parentNode.insertBefore(fakeTarget, this.nextSibling);
            fakeTarget.focus();
            fakeTarget.addEventListener('focusout', () => this.parentNode.removeChild(fakeTarget));
          }
        }
      }
    });

    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => {
        this._focus();

        this._setFocused(true);

        this.setAttribute('focus-ring', '');
      });
    }
  }
  /**
   * @protected
   */


  disconnectedCallback() {
    super.disconnectedCallback(); // in non-Chrome browsers, blur does not fire on the element when it is disconnected.
    // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

    if (this.hasAttribute('focused')) {
      this._setFocused(false);
    }
  }
  /**
   * @param {boolean} focused
   * @protected
   */


  _setFocused(focused) {
    if (focused) {
      this.setAttribute('focused', '');
    } else {
      this.removeAttribute('focused');
    } // focus-ring is true when the element was focused from the keyboard.
    // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI


    if (focused && keyboardActive) {
      this.setAttribute('focus-ring', '');
    } else {
      this.removeAttribute('focus-ring');
    }
  }
  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the actual focusable element in the component.
   * @return {Element | null | undefined}
   */


  get focusElement() {
    window.console.warn(`Please implement the 'focusElement' property in <${this.localName}>`);
    return this;
  }
  /**
   * @protected
   */


  _focus() {
    if (!this.focusElement || this._isShiftTabbing) {
      return;
    }

    this.focusElement.focus();

    this._setFocused(true);
  }
  /**
   * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.
   * @private
   */


  focus() {
    if (!this.focusElement || this.disabled) {
      return;
    }

    this.focusElement.focus();

    this._setFocused(true);
  }
  /**
   * Native bluring in the host element does nothing because it does not have the focus.
   * In chrome it works, but not in FF.
   * @private
   */


  blur() {
    if (!this.focusElement) {
      return;
    }

    this.focusElement.blur();

    this._setFocused(false);
  }
  /**
   * @param {boolean} disabled
   * @private
   */


  _disabledChanged(disabled) {
    this.focusElement.disabled = disabled;

    if (disabled) {
      this.blur();
      this._previousTabIndex = this.tabindex;
      this.tabindex = -1;
      this.setAttribute('aria-disabled', 'true');
    } else {
      if (typeof this._previousTabIndex !== 'undefined') {
        this.tabindex = this._previousTabIndex;
      }

      this.removeAttribute('aria-disabled');
    }
  }
  /**
   * @param {number | null | undefined} tabindex
   * @private
   */


  _tabindexChanged(tabindex) {
    if (tabindex !== undefined) {
      this.focusElement.tabIndex = tabindex;
    }

    if (this.disabled && this.tabindex) {
      // If tabindex attribute was changed while checkbox was disabled
      if (this.tabindex !== -1) {
        this._previousTabIndex = this.tabindex;
      }

      this.tabindex = tabindex = undefined;
    }

    if (window.ShadyDOM) {
      this.setProperties({
        tabIndex: tabindex,
        tabindex: tabindex
      });
    }
  }
  /**
   * @protected
   */


  click() {
    if (!this.disabled) {
      super.click();
    }
  }

};

/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
/**
 * `<vaadin-button>` is a Web Component providing an accessible and customizable button.
 *
 * ```html
 * <vaadin-button>
 * </vaadin-button>
 * ```
 *
 * ```js
 * document.querySelector('vaadin-button').addEventListener('click', () => alert('Hello World!'));
 * ```
 *
 * ### Styling
 *
 * The following shadow DOM parts are exposed for styling:
 *
 * Part name | Description
 * ----------------|----------------
 * `label` | The label (text) inside the button
 * `prefix` | A slot for e.g. an icon before the label
 * `suffix` | A slot for e.g. an icon after the label
 *
 *
 * The following attributes are exposed for styling:
 *
 * Attribute | Description
 * --------- | -----------
 * `active` | Set when the button is pressed down, either with mouse, touch or the keyboard.
 * `disabled` | Set when the button is disabled.
 * `focus-ring` | Set when the button is focused using the keyboard.
 * `focused` | Set when the button is focused.
 *
 * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
 *
 * @extends PolymerElement
 * @mixes ElementMixin
 * @mixes ControlStateMixin
 * @mixes ThemableMixin
 * @mixes GestureEventListeners
 * @demo demo/index.html
 */

class ButtonElement extends ElementMixin(ControlStateMixin(ThemableMixin(GestureEventListeners(PolymerElement)))) {
  static get template() {
    return html`
    <style>
      :host {
        display: inline-block;
        position: relative;
        outline: none;
        white-space: nowrap;
      }

      :host([hidden]) {
        display: none !important;
      }

      /* Ensure the button is always aligned on the baseline */
      .vaadin-button-container::before {
        content: "\\2003";
        display: inline-block;
        width: 0;
      }

      .vaadin-button-container {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        width: 100%;
        height: 100%;
        min-height: inherit;
        text-shadow: inherit;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
      }

      [part="prefix"],
      [part="suffix"] {
        flex: none;
      }

      [part="label"] {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #button {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: inherit;
      }
    </style>
    <div class="vaadin-button-container">
      <div part="prefix">
        <slot name="prefix"></slot>
      </div>
      <div part="label">
        <slot></slot>
      </div>
      <div part="suffix">
        <slot name="suffix"></slot>
      </div>
    </div>
    <button id="button" type="button"></button>
`;
  }

  static get is() {
    return 'vaadin-button';
  }

  static get version() {
    return '2.4.0';
  }

  ready() {
    super.ready(); // Leaving default role in the native button, makes navigation announcement
    // being different when using focus navigation (tab) versus using normal
    // navigation (arrows). The first way announces the label on a button
    // since the focus is moved programmatically, and the second on a group.

    this.setAttribute('role', 'button');
    this.$.button.setAttribute('role', 'presentation');

    this._addActiveListeners(); // Fix for https://github.com/vaadin/vaadin-button-flow/issues/120


    window.ShadyDOM && window.ShadyDOM.flush();
  }
  /**
   * @protected
   */


  disconnectedCallback() {
    super.disconnectedCallback(); // `active` state is preserved when the element is disconnected between keydown and keyup events.
    // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

    if (this.hasAttribute('active')) {
      this.removeAttribute('active');
    }
  }
  /** @private */


  _addActiveListeners() {
    addListener(this, 'down', () => !this.disabled && this.setAttribute('active', ''));
    addListener(this, 'up', () => this.removeAttribute('active'));
    this.addEventListener('keydown', e => !this.disabled && [13, 32].indexOf(e.keyCode) >= 0 && this.setAttribute('active', ''));
    this.addEventListener('keyup', () => this.removeAttribute('active'));
    this.addEventListener('blur', () => this.removeAttribute('active'));
  }
  /**
   * @protected
   * @return {Element}
   */


  get focusElement() {
    return this.$.button;
  }

}

customElements.define(ButtonElement.is, ButtonElement);

const $_documentContainer$3 = html`<dom-module id="lumo-progress-bar" theme-for="vaadin-progress-bar">
  <template>
    <style>
      :host {
        height: calc(var(--lumo-size-l) / 10);
        margin: var(--lumo-space-s) 0;
      }

      [part="bar"] {
        border-radius: var(--lumo-border-radius);
        background-color: var(--lumo-contrast-10pct);
      }

      [part="value"] {
        border-radius: var(--lumo-border-radius);
        background-color: var(--lumo-primary-color);
        /* Use width instead of transform to preserve border radius */
        transform: none;
        width: calc(var(--vaadin-progress-value) * 100%);
        will-change: width;
        transition: 0.1s width linear;
      }

      /* Indeterminate mode */

      :host([indeterminate]) [part="value"] {
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to right, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to left, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));
        width: 100%;
        background-color: transparent !important;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
        opacity: 0.75;
        will-change: transform;
        animation: vaadin-progress-indeterminate 1.6s infinite cubic-bezier(.645, .045, .355, 1);
      }

      @keyframes vaadin-progress-indeterminate {
        0% {
          transform: scaleX(0.015);
          transform-origin: 0% 0%;
        }

        25% {
          transform: scaleX(0.4);
        }

        50% {
          transform: scaleX(0.015);
          transform-origin: 100% 0%;
          background-image: var(--lumo-progress-indeterminate-progress-bar-background);
        }

        50.1% {
          transform: scaleX(0.015);
          transform-origin: 100% 0%;
          background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
        }

        75% {
          transform: scaleX(0.4);
        }

        100% {
          transform: scaleX(0.015);
          transform-origin: 0% 0%;
          background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
        }
      }

      :host(:not([aria-valuenow])) [part="value"]::before,
      :host([indeterminate]) [part="value"]::before {
        content: "";
        display: block;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        background-color: var(--lumo-primary-color);
        will-change: opacity;
        animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(.645, .045, .355, 1);
      }

      @keyframes vaadin-progress-pulse3 {
        0% { opacity: 1; }
        10% { opacity: 0; }
        40% { opacity: 0; }
        50% { opacity: 1; }
        50.1% { opacity: 1; }
        60% { opacity: 0; }
        90% { opacity: 0; }
        100% { opacity: 1; }
      }

      /* Contrast color */

      :host([theme~="contrast"]) [part="value"],
      :host([theme~="contrast"]) [part="value"]::before {
        background-color: var(--lumo-contrast-80pct);
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to right, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-80pct));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to left, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-60pct));
      }

      /* Error color */

      :host([theme~="error"]) [part="value"],
      :host([theme~="error"]) [part="value"]::before {
        background-color: var(--lumo-error-color);
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to right, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to left, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));
      }

      /* Primary color */

      :host([theme~="success"]) [part="value"],
      :host([theme~="success"]) [part="value"]::before {
        background-color: var(--lumo-success-color);
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to right, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to left, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));
      }

      /* RTL specific styles */

      :host([indeterminate][dir="rtl"]) [part="value"] {
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to left, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to right, var(--lumo-primary-color-10pct) 10%, var(--lumo-primary-color));
        animation: vaadin-progress-indeterminate-rtl 1.6s infinite cubic-bezier(.355, .045, .645, 1);
      }

      :host(:not([aria-valuenow])[dir="rtl"]) [part="value"]::before,
      :host([indeterminate][dir="rtl"]) [part="value"]::before {
        animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(.355, .045, .645, 1);
      }

      @keyframes vaadin-progress-indeterminate-rtl {
        0% {
          transform: scaleX(0.015);
          transform-origin: 100% 0%;
        }

        25% {
          transform: scaleX(0.4);
        }

        50% {
          transform: scaleX(0.015);
          transform-origin: 0% 0%;
          background-image: var(--lumo-progress-indeterminate-progress-bar-background);
        }

        50.1% {
          transform: scaleX(0.015);
          transform-origin: 0% 0%;
          background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
        }

        75% {
          transform: scaleX(0.4);
        }

        100% {
          transform: scaleX(0.015);
          transform-origin: 100% 0%;
          background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
        }
      }

      /* Contrast color */

      :host([theme~="contrast"][dir="rtl"]) [part="value"],
      :host([theme~="contrast"][dir="rtl"]) [part="value"]::before {
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to left, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-80pct));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to right, var(--lumo-contrast-5pct) 10%, var(--lumo-contrast-60pct));
      }

      /* Error color */

      :host([theme~="error"][dir="rtl"]) [part="value"],
      :host([theme~="error"][dir="rtl"]) [part="value"]::before {
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to left, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to right, var(--lumo-error-color-10pct) 10%, var(--lumo-error-color));
      }

      /* Primary color */

      :host([theme~="success"][dir="rtl"]) [part="value"],
      :host([theme~="success"][dir="rtl"]) [part="value"]::before {
        --lumo-progress-indeterminate-progress-bar-background: linear-gradient(to left, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));
        --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(to right, var(--lumo-success-color-10pct) 10%, var(--lumo-success-color));
      }
    </style>
  </template>
</dom-module><custom-style>
  <style>
    @keyframes vaadin-progress-pulse3 {
      0% { opacity: 1; }
      10% { opacity: 0; }
      40% { opacity: 0; }
      50% { opacity: 1; }
      50.1% { opacity: 1; }
      60% { opacity: 0; }
      90% { opacity: 0; }
      100% { opacity: 1; }
    }
  </style>
</custom-style>`;
document.head.appendChild($_documentContainer$3.content);
/* Safari fails to declare animations for pseudo elements inside a shadow DOM */

/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/

/**
 * @polymerMixin
 */
const ProgressMixin = superClass => class VaadinProgressMixin extends superClass {
  static get properties() {
    return {
      /**
       * Current progress value.
       */
      value: {
        type: Number,
        observer: '_valueChanged'
      },

      /**
       * Minimum bound of the progress bar.
       * @type {number}
       */
      min: {
        type: Number,
        value: 0,
        observer: '_minChanged'
      },

      /**
       * Maximum bound of the progress bar.
       * @type {number}
       */
      max: {
        type: Number,
        value: 1,
        observer: '_maxChanged'
      },

      /**
       * Indeterminate state of the progress bar.
       * This property takes precedence over other state properties (min, max, value).
       * @type {boolean}
       */
      indeterminate: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }

  static get observers() {
    return ['_normalizedValueChanged(value, min, max)'];
  }
  /** @protected */


  ready() {
    super.ready();
    this.setAttribute('role', 'progressbar');
  }
  /** @private */


  _normalizedValueChanged(value, min, max) {
    const newNormalizedValue = this._normalizeValue(value, min, max);

    this.style.setProperty('--vaadin-progress-value', newNormalizedValue);
    this.updateStyles({
      '--vaadin-progress-value': String(newNormalizedValue)
    });
  }
  /** @private */


  _valueChanged(newV, oldV) {
    this.setAttribute('aria-valuenow', newV);
  }
  /** @private */


  _minChanged(newV, oldV) {
    this.setAttribute('aria-valuemin', newV);
  }
  /** @private */


  _maxChanged(newV, oldV) {
    this.setAttribute('aria-valuemax', newV);
  }
  /**
   * Percent of current progress relative to whole progress bar (max - min)
   * @private
   */


  _normalizeValue(value, min, max) {
    let nV;

    if (!value && value != 0) {
      nV = 0;
    } else if (min >= max) {
      nV = 1;
    } else {
      nV = (value - min) / (max - min);
      nV = Math.min(Math.max(nV, 0), 1);
    }

    return nV;
  }

};

/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
/**
 * `<vaadin-progress-bar>` is a Web Component for progress bars.
 *
 * ```html
 * <vaadin-progress-bar min="0" max="1" value="0.5">
 * </vaadin-progress-bar>
 * ```
 *
 * ### Styling
 *
 * The following shadow DOM parts are available for styling:
 *
 * Part name | Description
 * ----------------|----------------
 * `bar` | Progress-bar's background
 * `value` | Progress-bar's foreground
 *
 * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
 *
 * The following custom properties are available:
 *
 * Custom property | Description | Default
 * ----------------|-------------|-------------
 * `--vaadin-progress-value` | current progress value (between 0 and 1) | 0
 *
 * The following state attributes are available for styling:
 *
 * Attribute       | Description | Part name
 * ----------------|-------------|------------
 * `indeterminate` | Set to an indeterminate progress bar | :host
 *
 * @extends PolymerElement
 * @mixes ProgressMixin
 * @mixes ThemableMixin
 * @mixes ElementMixin
 * @demo demo/index.html
 */

class ProgressBarElement extends ElementMixin(ThemableMixin(ProgressMixin(PolymerElement))) {
  static get template() {
    return html`
    <style>
      :host {
        display: block;
        width: 100%; /* prevent collapsing inside non-stretching column flex */
        height: 8px;
      }

      :host([hidden]) {
        display: none !important;
      }

      [part="bar"] {
        height: 100%;
      }

      [part="value"] {
        height: 100%;
        transform-origin: 0 50%;
        transform: scaleX(var(--vaadin-progress-value));
      }

      /* RTL specific styles */

      :host([dir="rtl"]) [part="value"] {
        transform-origin: 100% 50%;
      }
    </style>

    <div part="bar">
      <div part="value"></div>
    </div>
`;
  }

  static get is() {
    return 'vaadin-progress-bar';
  }

  static get version() {
    return '1.3.0';
  }

}

customElements.define(ProgressBarElement.is, ProgressBarElement);

const $_documentContainer$4 = html`<dom-module id="lumo-upload" theme-for="vaadin-upload">
  <template>
    <style>
      :host {
        line-height: var(--lumo-line-height-m);
      }

      :host(:not([nodrop])) {
        overflow: hidden;
        border: 1px dashed var(--lumo-contrast-20pct);
        border-radius: var(--lumo-border-radius);
        padding: var(--lumo-space-m);
        transition: background-color 0.6s, border-color 0.6s;
      }

      [part="primary-buttons"] > * {
        display: inline-block;
        white-space: nowrap;
      }

      [part="drop-label"] {
        display: inline-block;
        white-space: normal;
        padding: 0 var(--lumo-space-s);
        color: var(--lumo-secondary-text-color);
        font-family: var(--lumo-font-family);
      }

      :host([dragover-valid]) {
        border-color: var(--lumo-primary-color-50pct);
        background: var(--lumo-primary-color-10pct);
        transition: background-color 0.1s, border-color 0.1s;
      }

      :host([dragover-valid]) [part="drop-label"] {
        color: var(--lumo-primary-text-color);
      }

      [part="drop-label-icon"] {
        display: inline-block;
      }

      [part="drop-label-icon"]::before {
        content: var(--lumo-icons-upload);
        font-family: lumo-icons;
        font-size: var(--lumo-icon-size-m);
        line-height: 1;
        vertical-align: -.25em;
      }
    </style>
  </template>
</dom-module><dom-module id="lumo-upload-file" theme-for="vaadin-upload-file">
  <template>
    <style include="lumo-field-button">
      :host {
        padding: var(--lumo-space-s) 0;
      }

      :host(:not(:first-child)) {
        border-top: 1px solid var(--lumo-contrast-10pct);
      }

      [part="row"] {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
      }

      [part="status"],
      [part="error"] {
        color: var(--lumo-secondary-text-color);
        font-size: var(--lumo-font-size-s);
      }

      [part="info"] {
        display: flex;
        align-items: baseline;
        flex: auto;
      }

      [part="meta"] {
        width: 0.001px;
        flex: 1 1 auto;
      }

      [part="name"] {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      [part="commands"] {
        display: flex;
        align-items: baseline;
        flex: none;
      }

      [part="done-icon"],
      [part="warning-icon"] {
        margin-right: var(--lumo-space-xs);
      }

      /* When both icons are hidden, let us keep space for one */
      [part="done-icon"][hidden] + [part="warning-icon"][hidden] {
        display: block !important;
        visibility: hidden;
      }

      [part="done-icon"],
      [part="warning-icon"] {
        font-size: var(--lumo-icon-size-m);
        font-family: 'lumo-icons';
        line-height: 1;
      }

      [part="start-button"],
      [part="retry-button"],
      [part="clear-button"] {
        flex: none;
        margin-left: var(--lumo-space-xs);
      }

      [part="done-icon"]::before,
      [part="warning-icon"]::before,
      [part="start-button"]::before,
      [part="retry-button"]::before,
      [part="clear-button"]::before {
        vertical-align: -.25em;
      }

      [part="done-icon"]::before {
        content: var(--lumo-icons-checkmark);
        color: var(--lumo-primary-text-color);
      }

      [part="warning-icon"]::before {
        content: var(--lumo-icons-error);
        color: var(--lumo-error-text-color);
      }

      [part="start-button"]::before {
        content: var(--lumo-icons-play);
      }

      [part="retry-button"]::before {
        content: var(--lumo-icons-reload);
      }

      [part="clear-button"]::before {
        content: var(--lumo-icons-cross);
      }

      [part="error"] {
        color: var(--lumo-error-text-color);
      }

      [part="progress"] {
        width: auto;
        margin-left: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
        margin-right: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
      }

      [part="progress"][complete],
      [part="progress"][error] {
        display: none;
      }

    </style>
  </template>
</dom-module>`;
document.head.appendChild($_documentContainer$4.content);

const $_documentContainer$5 = document.createElement('template');
$_documentContainer$5.innerHTML = `<custom-style>
  <style>
    @font-face {
      font-family: 'vaadin-upload-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAasAAsAAAAABmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF5mNtYXAAAAFoAAAAVAAAAFQXVtKMZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfQAAAH0bBJxYWhlYWQAAAO4AAAANgAAADYPD267aGhlYQAAA/AAAAAkAAAAJAfCA8tobXR4AAAEFAAAACgAAAAoHgAAx2xvY2EAAAQ8AAAAFgAAABYCSgHsbWF4cAAABFQAAAAgAAAAIAAOADVuYW1lAAAEdAAAAhYAAAIWmmcHf3Bvc3QAAAaMAAAAIAAAACAAAwAAAAMDtwGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QUDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkF//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAgAA/8AEAAPAABkAMgAAEz4DMzIeAhczLgMjIg4CBycRIScFIRcOAyMiLgInIx4DMzI+AjcXphZGWmo6SH9kQwyADFiGrmJIhXJbIEYBAFoDWv76YBZGXGw8Rn5lRQyADFmIrWBIhHReIkYCWjJVPSIyVnVDXqN5RiVEYTxG/wBa2loyVT0iMlZ1Q16jeUYnRWE5RgAAAAABAIAAAAOAA4AAAgAAExEBgAMAA4D8gAHAAAAAAwAAAAAEAAOAAAIADgASAAAJASElIiY1NDYzMhYVFAYnETMRAgD+AAQA/gAdIyMdHSMjXYADgPyAgCMdHSMjHR0jwAEA/wAAAQANADMD5gNaAAUAACUBNwUBFwHT/jptATMBppMzAU2a4AIgdAAAAAEAOv/6A8YDhgALAAABJwkBBwkBFwkBNwEDxoz+xv7GjAFA/sCMAToBOoz+wAL6jP7AAUCM/sb+xowBQP7AjAE6AAAAAwAA/8AEAAPAAAcACwASAAABFSE1IREhEQEjNTMJAjMRIRECwP6A/sAEAP0AgIACQP7A/sDAAQABQICA/oABgP8AgAHAAUD+wP6AAYAAAAABAAAAAQAAdhiEdV8PPPUACwQAAAAAANX4FR8AAAAA1fgVHwAA/8AEAAPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAAAAAAAAgAAAAQAAAAEAACABAAAAAQAAA0EAAA6BAAAAAAAAAAACgAUAB4AagB4AJwAsADSAPoAAAABAAAACgAzAAMAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEAEwAAAAEAAAAAAAIABwDMAAEAAAAAAAMAEwBaAAEAAAAAAAQAEwDhAAEAAAAAAAUACwA5AAEAAAAAAAYAEwCTAAEAAAAAAAoAGgEaAAMAAQQJAAEAJgATAAMAAQQJAAIADgDTAAMAAQQJAAMAJgBtAAMAAQQJAAQAJgD0AAMAAQQJAAUAFgBEAAMAAQQJAAYAJgCmAAMAAQQJAAoANAE0dmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzUmVndWxhcgBSAGUAZwB1AGwAYQBydmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
</custom-style>`;
document.head.appendChild($_documentContainer$5.content);

/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
/**
 * `<vaadin-upload-file>` element represents a file in the file list of `<vaadin-upload>`.
 *
 * ### Styling
 *
 * The following shadow DOM parts are available for styling:
 *
 * Part name | Description
 * ---|---
 * `row` | File container
 * `info` | Container for file status icon, file name, status and error messages
 * `done-icon` | File done status icon
 * `warning-icon` | File warning status icon
 * `meta` | Container for file name, status and error messages
 * `name` | File name
 * `error` | Error message, shown when error happens
 * `status` | Status message
 * `commands` | Container for file command icons
 * `start-button` | Start file upload button
 * `retry-button` | Retry file upload button
 * `clear-button` | Clear file button
 * `progress`| Progress bar
 *
 * The following state attributes are available for styling:
 *
 * Attribute | Description | Part name
 * ---|---|---
 * `error` | An error has happened during uploading | `:host`
 * `indeterminate` | Uploading is in progress, but the progress value is unknown | `:host`
 * `uploading` | Uploading is in progress | `:host`
 * `complete` | Uploading has finished successfully | `:host`
 *
 * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
 *
 * @extends PolymerElement
 * @mixes ThemableMixin
 * @demo demo/index.html
 */

class UploadFileElement extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
    <style>
      :host {
        display: block;
      }

      [hidden] {
        display: none;
      }
    </style>

    <div part="row">
      <div part="info">
        <div part="done-icon" hidden\$="[[!file.complete]]"></div>
        <div part="warning-icon" hidden\$="[[!file.error]]"></div>

        <div part="meta">
          <div part="name" id="name">[[file.name]]</div>
          <div part="status" hidden\$="[[!file.status]]" id="status">[[file.status]]</div>
          <div part="error" id="error" hidden\$="[[!file.error]]">[[file.error]]</div>
        </div>
      </div>
      <div part="commands">
        <div part="start-button" file-event="file-start" on-click="_fireFileEvent" hidden\$="[[!file.held]]"></div>
        <div part="retry-button" file-event="file-retry" on-click="_fireFileEvent" hidden\$="[[!file.error]]"></div>
        <div part="clear-button" file-event="file-abort" on-click="_fireFileEvent"></div>
      </div>
    </div>

    <vaadin-progress-bar part="progress" id="progress" value\$="[[_formatProgressValue(file.progress)]]" error\$="[[file.error]]" indeterminate\$="[[file.indeterminate]]" uploading\$="[[file.uploading]]" complete\$="[[file.complete]]">
    </vaadin-progress-bar>
`;
  }

  static get is() {
    return 'vaadin-upload-file';
  }

  static get properties() {
    return {
      file: Object
    };
  }

  static get observers() {
    return ['_fileAborted(file.abort)', '_toggleHostAttribute(file.error, "error")', '_toggleHostAttribute(file.indeterminate, "indeterminate")', '_toggleHostAttribute(file.uploading, "uploading")', '_toggleHostAttribute(file.complete, "complete")'];
  }

  _fileAborted(abort) {
    if (abort) {
      this._remove();
    }
  }

  _remove() {
    this.dispatchEvent(new CustomEvent('file-remove', {
      detail: {
        file: this.file
      },
      bubbles: true,
      composed: true
    }));
  }

  _formatProgressValue(progress) {
    return progress / 100;
  }

  _fireFileEvent(e) {
    e.preventDefault();
    return this.dispatchEvent(new CustomEvent(e.target.getAttribute('file-event'), {
      detail: {
        file: this.file
      },
      bubbles: true,
      composed: true
    }));
  }

  _toggleHostAttribute(value, attributeName) {
    const shouldHave = Boolean(value);
    const has = this.hasAttribute(attributeName);

    if (has !== shouldHave) {
      if (shouldHave) {
        this.setAttribute(attributeName, '');
      } else {
        this.removeAttribute(attributeName);
      }
    }
  }
  /**
  * Fired when the retry button is pressed. It is listened by `vaadin-upload`
  * which will start a new upload process of this file.
  *
  * @event file-retry
  * @param {Object} detail
  * @param {Object} detail.file file to retry upload of
  */

  /**
  * Fired when the start button is pressed. It is listened by `vaadin-upload`
  * which will start a new upload process of this file.
  *
  * @event file-start
  * @param {Object} detail
  * @param {Object} detail.file file to start upload of
  */

  /**
   * Fired when abort button is pressed. It is listened by `vaadin-upload` which
   * will abort the upload in progress, but will not remove the file from the list
   * to allow the animation to hide the element to be run.
   *
   * @event file-abort
   * @param {Object} detail
   * @param {Object} detail.file file to abort upload of
   */

  /**
   * Fired after the animation to hide the element has finished. It is listened
   * by `vaadin-upload` which will actually remove the file from the upload
   * file list.
   *
   * @event file-remove
   * @param {Object} detail
   * @param {Object} detail.file file to remove from the  upload of
   */


}

customElements.define(UploadFileElement.is, UploadFileElement);

/**
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
/**
 * `<vaadin-upload>` is a Web Component for uploading multiple files with drag and drop support.
 *
 * Example:
 *
 * ```
 * <vaadin-upload></vaadin-upload>
 * ```
 *
 * ### Styling
 *
 * The following shadow DOM parts are available for styling:
 *
 * Part name | Description
 * ---|---
 * `primary-buttons` | Upload container
 * `upload-button` | Upload button
 * `drop-label` | Label for drop indicator
 * `drop-label-icon` | Icon for drop indicator
 * `file-list` | File list container
 *
 * The following state attributes are available for styling:
 *
 * Attribute | Description | Part name
 * ---|---|---
 * `nodrop` | Set when drag and drop is disabled (e. g., on touch devices) | `:host`
 * `dragover` | A file is being dragged over the element | `:host`
 * `dragover-valid` | A dragged file is valid with `maxFiles` and `accept` criteria | `:host`
 *
 * See [ThemableMixin  how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
 *
 * @extends PolymerElement
 * @mixes ThemableMixin
 * @mixes ElementMixin
 * @demo demo/index.html
 */

class UploadElement extends ElementMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host([hidden]) {
        display: none !important;
      }

      [hidden] {
        display: none !important;
      }
    </style>

    <div part="primary-buttons">
      <div id="addFiles" on-touchend="_onAddFilesTouchEnd" on-click="_onAddFilesClick">
        <slot name="add-button">
          <vaadin-button part="upload-button" id="addButton" disabled="[[maxFilesReached]]">
            [[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]
          </vaadin-button>
        </slot>
      </div>
      <div part="drop-label" hidden\$="[[nodrop]]" id="dropLabelContainer">
        <slot name="drop-label-icon">
          <div part="drop-label-icon"></div>
        </slot>
        <slot name="drop-label" id="dropLabel">
          [[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]
        </slot>
      </div>
    </div>
    <slot name="file-list">
      <div id="fileList" part="file-list">
        <template is="dom-repeat" items="[[files]]" as="file">
          <vaadin-upload-file file="[[file]]"></vaadin-upload-file>
        </template>
      </div>
    </slot>
    <slot></slot>
    <input type="file" id="fileInput" on-change="_onFileInputChange" hidden="" accept\$="{{accept}}" multiple\$="[[_isMultiple(maxFiles)]]" capture\$="[[capture]]">
`;
  }

  static get is() {
    return 'vaadin-upload';
  }

  static get version() {
    return '4.4.2';
  }

  static get properties() {
    return {
      /**
       * Define whether the element supports dropping files on it for uploading.
       * By default it's enabled in desktop and disabled in touch devices
       * because mobile devices do not support drag events in general. Setting
       * it false means that drop is enabled even in touch-devices, and true
       * disables drop in all devices.
       *
       * @type {boolean}
       * @default true in touch-devices, false otherwise.
       */
      nodrop: {
        type: Boolean,
        reflectToAttribute: true,
        value: function () {
          try {
            return !!document.createEvent('TouchEvent');
          } catch (e) {
            return false;
          }
        }
      },

      /**
       * The server URL. The default value is an empty string, which means that
       * _window.location_ will be used.
       * @type {string}
       */
      target: {
        type: String,
        value: ''
      },

      /**
       * HTTP Method used to send the files. Only POST and PUT are allowed.
       * @type {!UploadMethod}
       */
      method: {
        type: String,
        value: 'POST'
      },

      /**
       * Key-Value map to send to the server. If you set this property as an
       * attribute, use a valid JSON string, for example:
       * ```
       * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
       * ```
       * @type {object | string}
       */
      headers: {
        type: Object,
        value: {}
      },

      /**
       * Max time in milliseconds for the entire upload process, if exceeded the
       * request will be aborted. Zero means that there is no timeout.
       * @type {number}
       */
      timeout: {
        type: Number,
        value: 0
      },

      /** @private */
      _dragover: {
        type: Boolean,
        value: false,
        observer: '_dragoverChanged'
      },

      /**
       * The array of files being processed, or already uploaded.
       *
       * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
       * object with a number of extra properties  to track the upload process:
       * - `uploadTarget`: The target URL used to upload this file.
       * - `elapsed`: Elapsed time since the upload started.
       * - `elapsedStr`: Human-readable elapsed time.
       * - `remaining`: Number of seconds remaining for the upload to finish.
       * - `remainingStr`: Human-readable remaining time for the upload to finish.
       * - `progress`: Percentage of the file already uploaded.
       * - `speed`: Upload speed in kB/s.
       * - `size`: File size in bytes.
       * - `totalStr`: Human-readable total size of the file.
       * - `loaded`: Bytes transferred so far.
       * - `loadedStr`: Human-readable uploaded size at the moment.
       * - `status`: Status of the upload process.
       * - `error`: Error message in case the upload failed.
       * - `abort`: True if the file was canceled by the user.
       * - `complete`: True when the file was transferred to the server.
       * - `uploading`: True while transferring data to the server.
       * @type {!Array<!UploadFile>}
       */
      files: {
        type: Array,
        notify: true,
        value: function () {
          return [];
        }
      },

      /**
       * Limit of files to upload, by default it is unlimited. If the value is
       * set to one, native file browser will prevent selecting multiple files.
       * @attr {number} max-files
       * @type {number}
       */
      maxFiles: {
        type: Number,
        value: Infinity
      },

      /**
       * Specifies if the maximum number of files have been uploaded
       * @attr {boolean} max-files-reached
       * @type {boolean}
       */
      maxFilesReached: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_maxFilesAdded(maxFiles, files.length)'
      },

      /**
       * Specifies the types of files that the server accepts.
       * Syntax: a comma-separated list of MIME type patterns (wildcards are
       * allowed) or file extensions.
       * Notice that MIME types are widely supported, while file extensions
       * are only implemented in certain browsers, so avoid using it.
       * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
       * @type {string}
       */
      accept: {
        type: String,
        value: ''
      },

      /**
       * Specifies the maximum file size in bytes allowed to upload.
       * Notice that it is a client-side constraint, which will be checked before
       * sending the request. Obviously you need to do the same validation in
       * the server-side and be sure that they are aligned.
       * @attr {number} max-file-size
       * @type {number}
       */
      maxFileSize: {
        type: Number,
        value: Infinity
      },

      /**
       * Specifies if the dragover is validated with maxFiles and
       * accept properties.
       * @private
       */
      _dragoverValid: {
        type: Boolean,
        value: false,
        observer: '_dragoverValidChanged'
      },

      /**
       * Specifies the 'name' property at Content-Disposition
       * @attr {string} form-data-name
       * @type {string}
       */
      formDataName: {
        type: String,
        value: 'file'
      },

      /**
       * Prevents upload(s) from immediately uploading upon adding file(s).
       * When set, you must manually trigger uploads using the `uploadFiles` method
       * @attr {boolean} no-auto
       * @type {boolean}
       */
      noAuto: {
        type: Boolean,
        value: false
      },

      /**
       * Set the withCredentials flag on the request.
       * @attr {boolean} with-credentials
       * @type {boolean}
       */
      withCredentials: {
        type: Boolean,
        value: false
      },

      /**
       * Pass-through to input's capture attribute. Allows user to trigger device inputs
       * such as camera or microphone immediately.
       */
      capture: String,

      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       {
        dropFiles: {
        one: 'Drop file here
        many: 'Drop files here
        },
        addFiles: {
        one: 'Select File...',
        many: 'Upload Files...'
        },
        cancel: 'Cancel',
        error: {
        tooManyFiles: 'Too Many Files.',
        fileIsTooBig: 'File is Too Big.',
        incorrectFileType: 'Incorrect File Type.'
        },
        uploading: {
        status: {
          connecting: 'Connecting...',
          stalled: 'Stalled',
          processing: 'Processing File...',
          held: 'Queued'
        },
        remainingTime: {
          prefix: 'remaining time: ',
          unknown: 'unknown remaining time'
        },
        error: {
          serverUnavailable: 'Server Unavailable',
          unexpectedServerError: 'Unexpected Server Error',
          forbidden: 'Forbidden'
        }
        },
        units: {
        size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
        sizeBase: 1000
        },
        formatSize: function(bytes) {
        // returns the size followed by the best suitable unit
        },
        formatTime: function(seconds, [secs, mins, hours]) {
        // returns a 'HH:MM:SS' string
        }
      }
       * @type {!UploadI18n}
      * @default {English}
      */
      i18n: {
        type: Object,
        value: function () {
          return {
            dropFiles: {
              one: 'Drop file here',
              many: 'Drop files here'
            },
            addFiles: {
              one: 'Upload File...',
              many: 'Upload Files...'
            },
            cancel: 'Cancel',
            error: {
              tooManyFiles: 'Too Many Files.',
              fileIsTooBig: 'File is Too Big.',
              incorrectFileType: 'Incorrect File Type.'
            },
            uploading: {
              status: {
                connecting: 'Connecting...',
                stalled: 'Stalled.',
                processing: 'Processing File...',
                held: 'Queued'
              },
              remainingTime: {
                prefix: 'remaining time: ',
                unknown: 'unknown remaining time'
              },
              error: {
                serverUnavailable: 'Server Unavailable',
                unexpectedServerError: 'Unexpected Server Error',
                forbidden: 'Forbidden'
              }
            },
            units: {
              size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            }
          };
        }
      }
    };
  }
  /** @protected */


  ready() {
    super.ready();
    this.addEventListener('dragover', this._onDragover.bind(this));
    this.addEventListener('dragleave', this._onDragleave.bind(this));
    this.addEventListener('drop', this._onDrop.bind(this));
    this.addEventListener('file-retry', this._onFileRetry.bind(this));
    this.addEventListener('file-abort', this._onFileAbort.bind(this));
    this.addEventListener('file-remove', this._onFileRemove.bind(this));
    this.addEventListener('file-start', this._onFileStart.bind(this));
  }
  /** @private */


  _formatSize(bytes) {
    if (typeof this.i18n.formatSize === 'function') {
      return this.i18n.formatSize(bytes);
    } // https://wiki.ubuntu.com/UnitsPolicy


    const base = this.i18n.units.sizeBase || 1000;
    const unit = ~~(Math.log(bytes) / Math.log(base));
    const dec = Math.max(0, Math.min(3, unit - 1));
    const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
    return size + ' ' + this.i18n.units.size[unit];
  }
  /** @private */


  _splitTimeByUnits(time) {
    const unitSizes = [60, 60, 24, Infinity];
    const timeValues = [0];

    for (var i = 0; i < unitSizes.length && time > 0; i++) {
      timeValues[i] = time % unitSizes[i];
      time = Math.floor(time / unitSizes[i]);
    }

    return timeValues;
  }
  /** @private */


  _formatTime(seconds, split) {
    if (typeof this.i18n.formatTime === 'function') {
      return this.i18n.formatTime(seconds, split);
    } // Fill HH:MM:SS with leading zeros


    while (split.length < 3) {
      split.push(0);
    }

    return split.reverse().map(number => {
      return (number < 10 ? '0' : '') + number;
    }).join(':');
  }
  /** @private */


  _formatFileProgress(file) {
    return file.totalStr + ': ' + file.progress + '% (' + (file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown) + ')';
  }
  /** @private */


  _maxFilesAdded(maxFiles, numFiles) {
    return maxFiles >= 0 && numFiles >= maxFiles;
  }
  /** @private */


  _onDragover(event) {
    event.preventDefault();

    if (!this.nodrop && !this._dragover) {
      this._dragoverValid = !this.maxFilesReached;
      this._dragover = true;
    }

    event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? 'none' : 'copy';
  }
  /** @private */


  _onDragleave(event) {
    event.preventDefault();

    if (this._dragover && !this.nodrop) {
      this._dragover = this._dragoverValid = false;
    }
  }
  /** @private */


  _onDrop(event) {
    if (!this.nodrop) {
      event.preventDefault();
      this._dragover = this._dragoverValid = false;

      this._addFiles(event.dataTransfer.files);
    }
  }
  /** @private */


  _createXhr() {
    return new XMLHttpRequest();
  }
  /** @private */


  _configureXhr(xhr) {
    if (typeof this.headers == 'string') {
      try {
        this.headers = JSON.parse(this.headers);
      } catch (e) {
        this.headers = undefined;
      }
    }

    for (var key in this.headers) {
      xhr.setRequestHeader(key, this.headers[key]);
    }

    if (this.timeout) {
      xhr.timeout = this.timeout;
    }

    xhr.withCredentials = this.withCredentials;
  }
  /** @private */


  _setStatus(file, total, loaded, elapsed) {
    file.elapsed = elapsed;
    file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
    file.remaining = Math.ceil(elapsed * (total / loaded - 1));
    file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
    file.speed = ~~(total / elapsed / 1024);
    file.totalStr = this._formatSize(total);
    file.loadedStr = this._formatSize(loaded);
    file.status = this._formatFileProgress(file);
  }
  /**
   * Triggers the upload of any files that are not completed
   *
   * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files
   */


  uploadFiles(files) {
    if (files && !Array.isArray(files)) {
      files = [files];
    }

    files = files || this.files;
    files = files.filter(file => !file.complete);
    Array.prototype.forEach.call(files, this._uploadFile.bind(this));
  }
  /** @private */


  _uploadFile(file) {
    if (file.uploading) {
      return;
    }

    const ini = Date.now();

    const xhr = file.xhr = this._createXhr();

    let stalledId, last; // onprogress is called always after onreadystatechange

    xhr.upload.onprogress = e => {
      clearTimeout(stalledId);
      last = Date.now();
      const elapsed = (last - ini) / 1000;
      const loaded = e.loaded,
            total = e.total,
            progress = ~~(loaded / total * 100);
      file.loaded = loaded;
      file.progress = progress;
      file.indeterminate = loaded <= 0 || loaded >= total;

      if (file.error) {
        file.indeterminate = file.status = undefined;
      } else if (!file.abort) {
        if (progress < 100) {
          this._setStatus(file, total, loaded, elapsed);

          stalledId = setTimeout(() => {
            file.status = this.i18n.uploading.status.stalled;

            this._notifyFileChanges(file);
          }, 2000);
        } else {
          file.loadedStr = file.totalStr;
          file.status = this.i18n.uploading.status.processing;
        }
      }

      this._notifyFileChanges(file);

      this.dispatchEvent(new CustomEvent('upload-progress', {
        detail: {
          file,
          xhr
        }
      }));
    }; // More reliable than xhr.onload


    xhr.onreadystatechange = () => {
      if (xhr.readyState == 4) {
        clearTimeout(stalledId);
        file.indeterminate = file.uploading = false;

        if (file.abort) {
          this._notifyFileChanges(file);

          return;
        }

        file.status = ''; // Custom listener can modify the default behavior either
        // preventing default, changing the xhr, or setting the file error

        const evt = this.dispatchEvent(new CustomEvent('upload-response', {
          detail: {
            file,
            xhr
          },
          cancelable: true
        }));

        if (!evt) {
          return;
        }

        if (xhr.status === 0) {
          file.error = this.i18n.uploading.error.serverUnavailable;
        } else if (xhr.status >= 500) {
          file.error = this.i18n.uploading.error.unexpectedServerError;
        } else if (xhr.status >= 400) {
          file.error = this.i18n.uploading.error.forbidden;
        }

        file.complete = !file.error;
        this.dispatchEvent(new CustomEvent(`upload-${file.error ? 'error' : 'success'}`, {
          detail: {
            file,
            xhr
          }
        }));

        this._notifyFileChanges(file);
      }
    };

    const formData = new FormData();
    file.uploadTarget = file.uploadTarget || this.target || '';
    file.formDataName = this.formDataName;
    const evt = this.dispatchEvent(new CustomEvent('upload-before', {
      detail: {
        file,
        xhr
      },
      cancelable: true
    }));

    if (!evt) {
      return;
    }

    formData.append(file.formDataName, file, file.name);
    xhr.open(this.method, file.uploadTarget, true);

    this._configureXhr(xhr);

    file.status = this.i18n.uploading.status.connecting;
    file.uploading = file.indeterminate = true;
    file.complete = file.abort = file.error = file.held = false;

    xhr.upload.onloadstart = () => {
      this.dispatchEvent(new CustomEvent('upload-start', {
        detail: {
          file,
          xhr
        }
      }));

      this._notifyFileChanges(file);
    }; // Custom listener could modify the xhr just before sending it
    // preventing default


    const uploadEvt = this.dispatchEvent(new CustomEvent('upload-request', {
      detail: {
        file,
        xhr,
        formData
      },
      cancelable: true
    }));

    if (uploadEvt) {
      xhr.send(formData);
    }
  }
  /** @private */


  _retryFileUpload(file) {
    const evt = this.dispatchEvent(new CustomEvent('upload-retry', {
      detail: {
        file,
        xhr: file.xhr
      },
      cancelable: true
    }));

    if (evt) {
      this._uploadFile(file);
    }
  }
  /** @private */


  _abortFileUpload(file) {
    const evt = this.dispatchEvent(new CustomEvent('upload-abort', {
      detail: {
        file,
        xhr: file.xhr
      },
      cancelable: true
    }));

    if (evt) {
      file.abort = true;

      if (file.xhr) {
        file.xhr.abort();
      }

      this._notifyFileChanges(file);
    }
  }
  /** @private */


  _notifyFileChanges(file) {
    var p = 'files.' + this.files.indexOf(file) + '.';

    for (var i in file) {
      if (file.hasOwnProperty(i)) {
        this.notifyPath(p + i, file[i]);
      }
    }
  }
  /** @private */


  _addFiles(files) {
    Array.prototype.forEach.call(files, this._addFile.bind(this));
  }
  /**
   * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
   *
   * @param {!UploadFile} file File being added
   * @protected
   */


  _addFile(file) {
    if (this.maxFilesReached) {
      this.dispatchEvent(new CustomEvent('file-reject', {
        detail: {
          file,
          error: this.i18n.error.tooManyFiles
        }
      }));
      return;
    }

    if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
      this.dispatchEvent(new CustomEvent('file-reject', {
        detail: {
          file,
          error: this.i18n.error.fileIsTooBig
        }
      }));
      return;
    }

    const fileExt = file.name.match(/\.[^\.]*$|$/)[0];
    const re = new RegExp('^(' + this.accept.replace(/[, ]+/g, '|').replace(/\/\*/g, '/.*') + ')$', 'i');

    if (this.accept && !(re.test(file.type) || re.test(fileExt))) {
      this.dispatchEvent(new CustomEvent('file-reject', {
        detail: {
          file,
          error: this.i18n.error.incorrectFileType
        }
      }));
      return;
    }

    file.loaded = 0;
    file.held = true;
    file.status = this.i18n.uploading.status.held;
    this.unshift('files', file);

    if (!this.noAuto) {
      this._uploadFile(file);
    }
  }
  /**
   * Remove file from upload list. Called internally if file upload was canceled.
   * @param {!UploadFile} file File to remove
   * @protected
   */


  _removeFile(file) {
    if (this.files.indexOf(file) > -1) {
      this.splice('files', this.files.indexOf(file), 1);
    }
  }
  /** @private */


  _onAddFilesTouchEnd(e) {
    // Cancel the event to avoid the following click event
    e.preventDefault(); // FIXME(platosha): workaround for Polymer Gestures mouseCanceller
    // cancelling the following synthetic click. See also:
    // https://github.com/Polymer/polymer/issues/5289

    this.__resetMouseCanceller();

    this._onAddFilesClick();
  }
  /** @private */


  __resetMouseCanceller() {
    resetMouseCanceller();
  }
  /** @private */


  _onAddFilesClick() {
    if (this.maxFilesReached) {
      return;
    }

    this.$.fileInput.value = '';
    this.$.fileInput.click();
  }
  /** @private */


  _onFileInputChange(event) {
    this._addFiles(event.target.files);
  }
  /** @private */


  _onFileStart(event) {
    this._uploadFile(event.detail.file);
  }
  /** @private */


  _onFileRetry(event) {
    this._retryFileUpload(event.detail.file);
  }
  /** @private */


  _onFileAbort(event) {
    this._abortFileUpload(event.detail.file);
  }
  /** @private */


  _onFileRemove(event) {
    this._removeFile(event.detail.file);
  }
  /** @private */


  _dragoverChanged(dragover) {
    dragover ? this.setAttribute('dragover', dragover) : this.removeAttribute('dragover');
  }
  /** @private */


  _dragoverValidChanged(dragoverValid) {
    dragoverValid ? this.setAttribute('dragover-valid', dragoverValid) : this.removeAttribute('dragover-valid');
  }
  /** @private */


  _i18nPlural(value, plural) {
    return value == 1 ? plural.one : plural.many;
  }
  /** @private */


  _isMultiple(maxFiles) {
    return maxFiles != 1;
  }
  /**
  * Fired when a file cannot be added to the queue due to a constrain:
  *  file-size, file-type or maxFiles
  *
  * @event file-reject
  * @param {Object} detail
  * @param {Object} detail.file the file added
  * @param {string} detail.error the cause
  */

  /**
  * Fired before the XHR is opened. Could be used for changing the request
  * URL. If the default is prevented, then XHR would not be opened.
  *
  * @event upload-before
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded
  * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
  */

  /**
  * Fired when the XHR has been opened but not sent yet. Useful for appending
  * data keys to the FormData object, for changing some parameters like
  * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
  * send the request allowing the user to do something on his own.
  *
  * @event upload-request
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded
  * @param {Object} detail.formData the FormData object
  */

  /**
  * Fired when the XHR is sent.
  *
  * @event upload-start
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded
  */

  /**
  * Fired as many times as the progress is updated.
  *
  * @event upload-progress
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded with loaded info
  */

  /**
  * Fired when we have the actual server response, and before the component
  * analyses it. It's useful for developers to make the upload fail depending
  * on the server response. If the event is defaultPrevented the vaadin-upload
  * will return allowing the user to do something on his own like retry the
  * upload, etc. since he has full access to the `xhr` and `file` objects.
  * Otherwise, if the event is not prevented default `vaadin-upload` continues
  * with the normal workflow checking the `xhr.status` and `file.error`
  * which also might be modified by the user to force a customized response.
  *
  * @event upload-response
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded
  */

  /**
  * Fired in case the upload process succeed.
  *
  * @event upload-success
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded with loaded info
  */

  /**
  * Fired in case the upload process failed.
  *
  * @event upload-error
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded
  */

  /**
  * Fired when retry upload is requested. If the default is prevented, then
  * retry would not be performed.
  *
  * @event upload-retry
  * @param {Object} detail
  * @param {Object} detail.xhr the previous upload xhr
  * @param {Object} detail.file the file being uploaded
  */

  /**
  * Fired when retry abort is requested. If the default is prevented, then the
  * file upload would not be aborted.
  *
  * @event upload-abort
  * @param {Object} detail
  * @param {Object} detail.xhr the xhr
  * @param {Object} detail.file the file being uploaded
  */


}

customElements.define(UploadElement.is, UploadElement);

/**
 * Component for uploading resources to TEI Publisher or a generated app.
 *
 * @fires pb-start-update - Fired before the element updates its content
 * @fires pb-end-update - Fired after the element has finished updating its content
 * @fires pb-load - Fired after the upload has completed
 * @fires pb-collection - when received, sets the upload collection to the one passed from the event
 * @fires pb-refresh-odds - Fired if an ODD file was uploaded
 * 
 * @cssprop [--pb-upload-button-icon=icons:file-upload] - icon to show in the upload button
 * @cssprop [--pb-upload-drop-icon] - icon to show next to the drop label text (none by default)
 */

class PbUpload extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * the server-side script to handle the upload
       */
      target: {
        type: String
      },

      /**
       * a comma-separated list of file suffixes to accept for upload
       * (by default: .xml,.tei,.odd,.docx)
       */
      accept: {
        type: String
      },
      _files: {
        type: Object
      }
    });
  }

  constructor() {
    super();
    this._files = new Map();
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }

    this.subscribeTo('pb-collection', ev => {
      this.target = ev.detail.collection;
    });
  }

  firstUpdated() {
    super.firstUpdated();
    const uploader = this.shadowRoot.getElementById('uploader');
    uploader.addEventListener('upload-before', event => {
      this.emitTo('pb-start-update');
      const {
        file
      } = event.detail; // clear list of uploaded files

      this._files.set(file.name, file);

      this.requestUpdate();

      if (this.minApiVersion('1.0.0') && this.target) {
        file.uploadTarget = `${uploader.target}${encodeURIComponent(this.target)}`;
      }
    });
    uploader.addEventListener('upload-request', event => {
      if (this.target && this.lessThanApiVersion('1.0.0')) {
        event.detail.formData.append('root', this.target);
      }
    });
    uploader.addEventListener('upload-error', event => {
      this.emitTo('pb-end-update'); // eslint-disable-next-line no-param-reassign

      event.detail.file.error = event.detail.xhr.responseText;
      this.requestUpdate();
    });
    uploader.addEventListener('upload-success', () => {
      let done = true;
      const oddsUploaded = [];
      uploader.files.forEach(file => {
        if (!(file.complete || file.error || file.aborted)) {
          done = false;
        } else if (/^.*\.odd$/.test(file.name)) {
          oddsUploaded.push(file.name);
        }

        this.requestUpdate();
      });

      if (done) {
        this.emitTo('pb-end-update');
        this.emitTo('pb-load');

        if (oddsUploaded.length > 0) {
          this.emitTo('pb-refresh-odds', {
            'odds': oddsUploaded
          });
        }
      }
    });
    PbUpload.waitOnce('pb-page-ready', () => {
      if (this.minApiVersion('1.0.0')) {
        uploader.target = `${this.getEndpoint()}/api/upload/`;
      } else {
        uploader.target = `${this.getEndpoint()}/modules/lib/upload.xql`;
      }
    });
  }

  render() {
    const uploadIcon = this._getCSSProperty('--pb-upload-button-icon', 'icons:file-upload');

    const dropLabelIcon = this._getCSSProperty('--pb-upload-drop-icon', null);

    return html$1`
            <vaadin-upload id="uploader" accept="${this.accept}" method="post" tabindex="-1" form-data-name="files[]"
                with-credentials>
                ${dropLabelIcon ? html$1`<iron-icon slot="drop-label-icon" icon="${dropLabelIcon}"></iron-icon>` : html$1`<span slot="drop-label-icon"></span>`}
                <span slot="drop-label">${translate('upload.drop', {
      accept: this.accept
    })}</span>
                <paper-button id="uploadBtn" slot="add-button">
                    ${uploadIcon ? html$1`<iron-icon icon="${uploadIcon}"></iron-icon>` : null}
                    ${translate('upload.upload')}
                </paper-button>
                <div slot="file-list">
                    <ul>
                    ${this._files.size > 0 ? html$1`
                            <li class="close">
                                <paper-icon-button icon="icons:clear" @click="${this.clearList}"></paper-icon-button>
                            </li>` : ''}
                    ${this.renderFiles()}
                    </ul>
                </div>
            </vaadin-upload>
        `;
  }

  renderFiles() {
    const rows = [];

    for (const file of this._files.values()) {
      let icon = 'icons:hourglass-empty';

      if (file.complete) {
        icon = 'icons:check';
      } else if (file.error || file.aborted) {
        icon = 'icons:error-outline';
      }

      const fileName = /.docx/.test(file.name) ? `${file.name}.xml` : file.name;
      let link;

      if (this.target) {
        link = `${this.target}/${fileName}`;
      } else {
        link = fileName;
      }

      rows.push(html$1`
                <li>
                    <iron-icon icon="${icon}"></iron-icon>
                    ${file.error ? file.name : html$1`<a href="${link}">${file.name}</a>`}
                </li>
            `);

      if (file.error) {
        rows.push(html$1`
                    <li class="error" part="error">${JSON.parse(file.error).description}</li>
                `);
      }
    }

    return rows;
  }

  clearList() {
    this._files.clear();

    this.requestUpdate();
  }

  _getCSSProperty(name, defaultValue) {
    const property = getComputedStyle(this).getPropertyValue(name);

    if (property) {
      try {
        return JSON.parse(property);
      } catch (e) {
        return defaultValue;
      }
    }

    return defaultValue;
  }

  static get styles() {
    return css`
            ul {
                list-style: none;
                margin: 0;
                padding: 0;
            }
            li {
                margin-top: 8px;
            }
            .close {
                text-align: right;
            }
            .error {
                color: red;
            }
            #uploadBtn iron-icon {
                padding-right: 8px;
            }
        `;
  }

}
customElements.define('pb-upload', PbUpload);

// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.
!function () {
  var a = {},
      b = {};
  !function (a, b) {
    function c(a) {
      if ("number" == typeof a) return a;
      var b = {};

      for (var c in a) b[c] = a[c];

      return b;
    }

    function d() {
      this._delay = 0, this._endDelay = 0, this._fill = "none", this._iterationStart = 0, this._iterations = 1, this._duration = 0, this._playbackRate = 1, this._direction = "normal", this._easing = "linear", this._easingFunction = x;
    }

    function e() {
      return a.isDeprecated("Invalid timing inputs", "2016-03-02", "TypeError exceptions will be thrown instead.", !0);
    }

    function f(b, c, e) {
      var f = new d();
      return c && (f.fill = "both", f.duration = "auto"), "number" != typeof b || isNaN(b) ? void 0 !== b && Object.getOwnPropertyNames(b).forEach(function (c) {
        if ("auto" != b[c]) {
          if (("number" == typeof f[c] || "duration" == c) && ("number" != typeof b[c] || isNaN(b[c]))) return;
          if ("fill" == c && -1 == v.indexOf(b[c])) return;
          if ("direction" == c && -1 == w.indexOf(b[c])) return;
          if ("playbackRate" == c && 1 !== b[c] && a.isDeprecated("AnimationEffectTiming.playbackRate", "2014-11-28", "Use Animation.playbackRate instead.")) return;
          f[c] = b[c];
        }
      }) : f.duration = b, f;
    }

    function g(a) {
      return "number" == typeof a && (a = isNaN(a) ? {
        duration: 0
      } : {
        duration: a
      }), a;
    }

    function h(b, c) {
      return b = a.numericTimingToObject(b), f(b, c);
    }

    function i(a, b, c, d) {
      return a < 0 || a > 1 || c < 0 || c > 1 ? x : function (e) {
        function f(a, b, c) {
          return 3 * a * (1 - c) * (1 - c) * c + 3 * b * (1 - c) * c * c + c * c * c;
        }

        if (e <= 0) {
          var g = 0;
          return a > 0 ? g = b / a : !b && c > 0 && (g = d / c), g * e;
        }

        if (e >= 1) {
          var h = 0;
          return c < 1 ? h = (d - 1) / (c - 1) : 1 == c && a < 1 && (h = (b - 1) / (a - 1)), 1 + h * (e - 1);
        }

        for (var i = 0, j = 1; i < j;) {
          var k = (i + j) / 2,
              l = f(a, c, k);
          if (Math.abs(e - l) < 1e-5) return f(b, d, k);
          l < e ? i = k : j = k;
        }

        return f(b, d, k);
      };
    }

    function j(a, b) {
      return function (c) {
        if (c >= 1) return 1;
        var d = 1 / a;
        return (c += b * d) - c % d;
      };
    }

    function k(a) {
      C || (C = document.createElement("div").style), C.animationTimingFunction = "", C.animationTimingFunction = a;
      var b = C.animationTimingFunction;
      if ("" == b && e()) throw new TypeError(a + " is not a valid value for easing");
      return b;
    }

    function l(a) {
      if ("linear" == a) return x;
      var b = E.exec(a);
      if (b) return i.apply(this, b.slice(1).map(Number));
      var c = F.exec(a);
      if (c) return j(Number(c[1]), A);
      var d = G.exec(a);
      return d ? j(Number(d[1]), {
        start: y,
        middle: z,
        end: A
      }[d[2]]) : B[a] || x;
    }

    function m(a) {
      return Math.abs(n(a) / a.playbackRate);
    }

    function n(a) {
      return 0 === a.duration || 0 === a.iterations ? 0 : a.duration * a.iterations;
    }

    function o(a, b, c) {
      if (null == b) return H;
      var d = c.delay + a + c.endDelay;
      return b < Math.min(c.delay, d) ? I : b >= Math.min(c.delay + a, d) ? J : K;
    }

    function p(a, b, c, d, e) {
      switch (d) {
        case I:
          return "backwards" == b || "both" == b ? 0 : null;

        case K:
          return c - e;

        case J:
          return "forwards" == b || "both" == b ? a : null;

        case H:
          return null;
      }
    }

    function q(a, b, c, d, e) {
      var f = e;
      return 0 === a ? b !== I && (f += c) : f += d / a, f;
    }

    function r(a, b, c, d, e, f) {
      var g = a === 1 / 0 ? b % 1 : a % 1;
      return 0 !== g || c !== J || 0 === d || 0 === e && 0 !== f || (g = 1), g;
    }

    function s(a, b, c, d) {
      return a === J && b === 1 / 0 ? 1 / 0 : 1 === c ? Math.floor(d) - 1 : Math.floor(d);
    }

    function t(a, b, c) {
      var d = a;

      if ("normal" !== a && "reverse" !== a) {
        var e = b;
        "alternate-reverse" === a && (e += 1), d = "normal", e !== 1 / 0 && e % 2 != 0 && (d = "reverse");
      }

      return "normal" === d ? c : 1 - c;
    }

    function u(a, b, c) {
      var d = o(a, b, c),
          e = p(a, c.fill, b, d, c.delay);
      if (null === e) return null;
      var f = q(c.duration, d, c.iterations, e, c.iterationStart),
          g = r(f, c.iterationStart, d, c.iterations, e, c.duration),
          h = s(d, c.iterations, g, f),
          i = t(c.direction, h, g);
      return c._easingFunction(i);
    }

    var v = "backwards|forwards|both|none".split("|"),
        w = "reverse|alternate|alternate-reverse".split("|"),
        x = function (a) {
      return a;
    };

    d.prototype = {
      _setMember: function (b, c) {
        this["_" + b] = c, this._effect && (this._effect._timingInput[b] = c, this._effect._timing = a.normalizeTimingInput(this._effect._timingInput), this._effect.activeDuration = a.calculateActiveDuration(this._effect._timing), this._effect._animation && this._effect._animation._rebuildUnderlyingAnimation());
      },

      get playbackRate() {
        return this._playbackRate;
      },

      set delay(a) {
        this._setMember("delay", a);
      },

      get delay() {
        return this._delay;
      },

      set endDelay(a) {
        this._setMember("endDelay", a);
      },

      get endDelay() {
        return this._endDelay;
      },

      set fill(a) {
        this._setMember("fill", a);
      },

      get fill() {
        return this._fill;
      },

      set iterationStart(a) {
        if ((isNaN(a) || a < 0) && e()) throw new TypeError("iterationStart must be a non-negative number, received: " + a);

        this._setMember("iterationStart", a);
      },

      get iterationStart() {
        return this._iterationStart;
      },

      set duration(a) {
        if ("auto" != a && (isNaN(a) || a < 0) && e()) throw new TypeError("duration must be non-negative or auto, received: " + a);

        this._setMember("duration", a);
      },

      get duration() {
        return this._duration;
      },

      set direction(a) {
        this._setMember("direction", a);
      },

      get direction() {
        return this._direction;
      },

      set easing(a) {
        this._easingFunction = l(k(a)), this._setMember("easing", a);
      },

      get easing() {
        return this._easing;
      },

      set iterations(a) {
        if ((isNaN(a) || a < 0) && e()) throw new TypeError("iterations must be non-negative, received: " + a);

        this._setMember("iterations", a);
      },

      get iterations() {
        return this._iterations;
      }

    };
    var y = 1,
        z = .5,
        A = 0,
        B = {
      ease: i(.25, .1, .25, 1),
      "ease-in": i(.42, 0, 1, 1),
      "ease-out": i(0, 0, .58, 1),
      "ease-in-out": i(.42, 0, .58, 1),
      "step-start": j(1, y),
      "step-middle": j(1, z),
      "step-end": j(1, A)
    },
        C = null,
        D = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",
        E = new RegExp("cubic-bezier\\(" + D + "," + D + "," + D + "," + D + "\\)"),
        F = /steps\(\s*(\d+)\s*\)/,
        G = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,
        H = 0,
        I = 1,
        J = 2,
        K = 3;
    a.cloneTimingInput = c, a.makeTiming = f, a.numericTimingToObject = g, a.normalizeTimingInput = h, a.calculateActiveDuration = m, a.calculateIterationProgress = u, a.calculatePhase = o, a.normalizeEasing = k, a.parseEasingFunction = l;
  }(a), function (a, b) {
    function c(a, b) {
      return a in k ? k[a][b] || b : b;
    }

    function d(a) {
      return "display" === a || 0 === a.lastIndexOf("animation", 0) || 0 === a.lastIndexOf("transition", 0);
    }

    function e(a, b, e) {
      if (!d(a)) {
        var f = h[a];

        if (f) {
          i.style[a] = b;

          for (var g in f) {
            var j = f[g],
                k = i.style[j];
            e[j] = c(j, k);
          }
        } else e[a] = c(a, b);
      }
    }

    function f(a) {
      var b = [];

      for (var c in a) if (!(c in ["easing", "offset", "composite"])) {
        var d = a[c];
        Array.isArray(d) || (d = [d]);

        for (var e, f = d.length, g = 0; g < f; g++) e = {}, e.offset = "offset" in a ? a.offset : 1 == f ? 1 : g / (f - 1), "easing" in a && (e.easing = a.easing), "composite" in a && (e.composite = a.composite), e[c] = d[g], b.push(e);
      }

      return b.sort(function (a, b) {
        return a.offset - b.offset;
      }), b;
    }

    function g(b) {
      function c() {
        var a = d.length;
        null == d[a - 1].offset && (d[a - 1].offset = 1), a > 1 && null == d[0].offset && (d[0].offset = 0);

        for (var b = 0, c = d[0].offset, e = 1; e < a; e++) {
          var f = d[e].offset;

          if (null != f) {
            for (var g = 1; g < e - b; g++) d[b + g].offset = c + (f - c) * g / (e - b);

            b = e, c = f;
          }
        }
      }

      if (null == b) return [];
      window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)), Array.isArray(b) || (b = f(b));

      for (var d = b.map(function (b) {
        var c = {};

        for (var d in b) {
          var f = b[d];

          if ("offset" == d) {
            if (null != f) {
              if (f = Number(f), !isFinite(f)) throw new TypeError("Keyframe offsets must be numbers.");
              if (f < 0 || f > 1) throw new TypeError("Keyframe offsets must be between 0 and 1.");
            }
          } else if ("composite" == d) {
            if ("add" == f || "accumulate" == f) throw {
              type: DOMException.NOT_SUPPORTED_ERR,
              name: "NotSupportedError",
              message: "add compositing is not supported"
            };
            if ("replace" != f) throw new TypeError("Invalid composite mode " + f + ".");
          } else f = "easing" == d ? a.normalizeEasing(f) : "" + f;

          e(d, f, c);
        }

        return void 0 == c.offset && (c.offset = null), void 0 == c.easing && (c.easing = "linear"), c;
      }), g = !0, h = -1 / 0, i = 0; i < d.length; i++) {
        var j = d[i].offset;

        if (null != j) {
          if (j < h) throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
          h = j;
        } else g = !1;
      }

      return d = d.filter(function (a) {
        return a.offset >= 0 && a.offset <= 1;
      }), g || c(), d;
    }

    var h = {
      background: ["backgroundImage", "backgroundPosition", "backgroundSize", "backgroundRepeat", "backgroundAttachment", "backgroundOrigin", "backgroundClip", "backgroundColor"],
      border: ["borderTopColor", "borderTopStyle", "borderTopWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderBottom: ["borderBottomWidth", "borderBottomStyle", "borderBottomColor"],
      borderColor: ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"],
      borderLeft: ["borderLeftWidth", "borderLeftStyle", "borderLeftColor"],
      borderRadius: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
      borderRight: ["borderRightWidth", "borderRightStyle", "borderRightColor"],
      borderTop: ["borderTopWidth", "borderTopStyle", "borderTopColor"],
      borderWidth: ["borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth"],
      flex: ["flexGrow", "flexShrink", "flexBasis"],
      font: ["fontFamily", "fontSize", "fontStyle", "fontVariant", "fontWeight", "lineHeight"],
      margin: ["marginTop", "marginRight", "marginBottom", "marginLeft"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      padding: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]
    },
        i = document.createElementNS("http://www.w3.org/1999/xhtml", "div"),
        j = {
      thin: "1px",
      medium: "3px",
      thick: "5px"
    },
        k = {
      borderBottomWidth: j,
      borderLeftWidth: j,
      borderRightWidth: j,
      borderTopWidth: j,
      fontSize: {
        "xx-small": "60%",
        "x-small": "75%",
        small: "89%",
        medium: "100%",
        large: "120%",
        "x-large": "150%",
        "xx-large": "200%"
      },
      fontWeight: {
        normal: "400",
        bold: "700"
      },
      outlineWidth: j,
      textShadow: {
        none: "0px 0px 0px transparent"
      },
      boxShadow: {
        none: "0px 0px 0px 0px transparent"
      }
    };
    a.convertToArrayForm = f, a.normalizeKeyframes = g;
  }(a), function (a) {
    var b = {};
    a.isDeprecated = function (a, c, d, e) {
      var f = e ? "are" : "is",
          g = new Date(),
          h = new Date(c);
      return h.setMonth(h.getMonth() + 3), !(g < h && (a in b || console.warn("Web Animations: " + a + " " + f + " deprecated and will stop working on " + h.toDateString() + ". " + d), b[a] = !0, 1));
    }, a.deprecated = function (b, c, d, e) {
      var f = e ? "are" : "is";
      if (a.isDeprecated(b, c, d, e)) throw new Error(b + " " + f + " no longer supported. " + d);
    };
  }(a), function () {
    if (document.documentElement.animate) {
      var c = document.documentElement.animate([], 0),
          d = !0;
      if (c && (d = !1, "play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function (a) {
        void 0 === c[a] && (d = !0);
      })), !d) return;
    }

    !function (a, b, c) {
      function d(a) {
        for (var b = {}, c = 0; c < a.length; c++) for (var d in a[c]) if ("offset" != d && "easing" != d && "composite" != d) {
          var e = {
            offset: a[c].offset,
            easing: a[c].easing,
            value: a[c][d]
          };
          b[d] = b[d] || [], b[d].push(e);
        }

        for (var f in b) {
          var g = b[f];
          if (0 != g[0].offset || 1 != g[g.length - 1].offset) throw {
            type: DOMException.NOT_SUPPORTED_ERR,
            name: "NotSupportedError",
            message: "Partial keyframes are not supported"
          };
        }

        return b;
      }

      function e(c) {
        var d = [];

        for (var e in c) for (var f = c[e], g = 0; g < f.length - 1; g++) {
          var h = g,
              i = g + 1,
              j = f[h].offset,
              k = f[i].offset,
              l = j,
              m = k;
          0 == g && (l = -1 / 0, 0 == k && (i = h)), g == f.length - 2 && (m = 1 / 0, 1 == j && (h = i)), d.push({
            applyFrom: l,
            applyTo: m,
            startOffset: f[h].offset,
            endOffset: f[i].offset,
            easingFunction: a.parseEasingFunction(f[h].easing),
            property: e,
            interpolation: b.propertyInterpolation(e, f[h].value, f[i].value)
          });
        }

        return d.sort(function (a, b) {
          return a.startOffset - b.startOffset;
        }), d;
      }

      b.convertEffectInput = function (c) {
        var f = a.normalizeKeyframes(c),
            g = d(f),
            h = e(g);
        return function (a, c) {
          if (null != c) h.filter(function (a) {
            return c >= a.applyFrom && c < a.applyTo;
          }).forEach(function (d) {
            var e = c - d.startOffset,
                f = d.endOffset - d.startOffset,
                g = 0 == f ? 0 : d.easingFunction(e / f);
            b.apply(a, d.property, d.interpolation(g));
          });else for (var d in g) "offset" != d && "easing" != d && "composite" != d && b.clear(a, d);
        };
      };
    }(a, b), function (a, b, c) {
      function d(a) {
        return a.replace(/-(.)/g, function (a, b) {
          return b.toUpperCase();
        });
      }

      function e(a, b, c) {
        h[c] = h[c] || [], h[c].push([a, b]);
      }

      function f(a, b, c) {
        for (var f = 0; f < c.length; f++) {
          e(a, b, d(c[f]));
        }
      }

      function g(c, e, f) {
        var g = c;
        /-/.test(c) && !a.isDeprecated("Hyphenated property names", "2016-03-22", "Use camelCase instead.", !0) && (g = d(c)), "initial" != e && "initial" != f || ("initial" == e && (e = i[g]), "initial" == f && (f = i[g]));

        for (var j = e == f ? [] : h[g], k = 0; j && k < j.length; k++) {
          var l = j[k][0](e),
              m = j[k][0](f);

          if (void 0 !== l && void 0 !== m) {
            var n = j[k][1](l, m);

            if (n) {
              var o = b.Interpolation.apply(null, n);
              return function (a) {
                return 0 == a ? e : 1 == a ? f : o(a);
              };
            }
          }
        }

        return b.Interpolation(!1, !0, function (a) {
          return a ? f : e;
        });
      }

      var h = {};
      b.addPropertiesHandler = f;
      var i = {
        backgroundColor: "transparent",
        backgroundPosition: "0% 0%",
        borderBottomColor: "currentColor",
        borderBottomLeftRadius: "0px",
        borderBottomRightRadius: "0px",
        borderBottomWidth: "3px",
        borderLeftColor: "currentColor",
        borderLeftWidth: "3px",
        borderRightColor: "currentColor",
        borderRightWidth: "3px",
        borderSpacing: "2px",
        borderTopColor: "currentColor",
        borderTopLeftRadius: "0px",
        borderTopRightRadius: "0px",
        borderTopWidth: "3px",
        bottom: "auto",
        clip: "rect(0px, 0px, 0px, 0px)",
        color: "black",
        fontSize: "100%",
        fontWeight: "400",
        height: "auto",
        left: "auto",
        letterSpacing: "normal",
        lineHeight: "120%",
        marginBottom: "0px",
        marginLeft: "0px",
        marginRight: "0px",
        marginTop: "0px",
        maxHeight: "none",
        maxWidth: "none",
        minHeight: "0px",
        minWidth: "0px",
        opacity: "1.0",
        outlineColor: "invert",
        outlineOffset: "0px",
        outlineWidth: "3px",
        paddingBottom: "0px",
        paddingLeft: "0px",
        paddingRight: "0px",
        paddingTop: "0px",
        right: "auto",
        strokeDasharray: "none",
        strokeDashoffset: "0px",
        textIndent: "0px",
        textShadow: "0px 0px 0px transparent",
        top: "auto",
        transform: "",
        verticalAlign: "0px",
        visibility: "visible",
        width: "auto",
        wordSpacing: "normal",
        zIndex: "auto"
      };
      b.propertyInterpolation = g;
    }(a, b), function (a, b, c) {
      function d(b) {
        var c = a.calculateActiveDuration(b),
            d = function (d) {
          return a.calculateIterationProgress(c, d, b);
        };

        return d._totalDuration = b.delay + c + b.endDelay, d;
      }

      b.KeyframeEffect = function (c, e, f, g) {
        var h,
            i = d(a.normalizeTimingInput(f)),
            j = b.convertEffectInput(e),
            k = function () {
          j(c, h);
        };

        return k._update = function (a) {
          return null !== (h = i(a));
        }, k._clear = function () {
          j(c, null);
        }, k._hasSameTarget = function (a) {
          return c === a;
        }, k._target = c, k._totalDuration = i._totalDuration, k._id = g, k;
      };
    }(a, b), function (a, b) {
      function c(a, b) {
        return !(!b.namespaceURI || -1 == b.namespaceURI.indexOf("/svg")) && (g in a || (a[g] = /Trident|MSIE|IEMobile|Edge|Android 4/i.test(a.navigator.userAgent)), a[g]);
      }

      function d(a, b, c) {
        c.enumerable = !0, c.configurable = !0, Object.defineProperty(a, b, c);
      }

      function e(a) {
        this._element = a, this._surrogateStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "div").style, this._style = a.style, this._length = 0, this._isAnimatedProperty = {}, this._updateSvgTransformAttr = c(window, a), this._savedTransformAttr = null;

        for (var b = 0; b < this._style.length; b++) {
          var d = this._style[b];
          this._surrogateStyle[d] = this._style[d];
        }

        this._updateIndices();
      }

      function f(a) {
        if (!a._webAnimationsPatchedStyle) {
          var b = new e(a);

          try {
            d(a, "style", {
              get: function () {
                return b;
              }
            });
          } catch (b) {
            a.style._set = function (b, c) {
              a.style[b] = c;
            }, a.style._clear = function (b) {
              a.style[b] = "";
            };
          }

          a._webAnimationsPatchedStyle = a.style;
        }
      }

      var g = "_webAnimationsUpdateSvgTransformAttr",
          h = {
        cssText: 1,
        length: 1,
        parentRule: 1
      },
          i = {
        getPropertyCSSValue: 1,
        getPropertyPriority: 1,
        getPropertyValue: 1,
        item: 1,
        removeProperty: 1,
        setProperty: 1
      },
          j = {
        removeProperty: 1,
        setProperty: 1
      };
      e.prototype = {
        get cssText() {
          return this._surrogateStyle.cssText;
        },

        set cssText(a) {
          for (var b = {}, c = 0; c < this._surrogateStyle.length; c++) b[this._surrogateStyle[c]] = !0;

          this._surrogateStyle.cssText = a, this._updateIndices();

          for (var c = 0; c < this._surrogateStyle.length; c++) b[this._surrogateStyle[c]] = !0;

          for (var d in b) this._isAnimatedProperty[d] || this._style.setProperty(d, this._surrogateStyle.getPropertyValue(d));
        },

        get length() {
          return this._surrogateStyle.length;
        },

        get parentRule() {
          return this._style.parentRule;
        },

        _updateIndices: function () {
          for (; this._length < this._surrogateStyle.length;) Object.defineProperty(this, this._length, {
            configurable: !0,
            enumerable: !1,
            get: function (a) {
              return function () {
                return this._surrogateStyle[a];
              };
            }(this._length)
          }), this._length++;

          for (; this._length > this._surrogateStyle.length;) this._length--, Object.defineProperty(this, this._length, {
            configurable: !0,
            enumerable: !1,
            value: void 0
          });
        },
        _set: function (b, c) {
          this._style[b] = c, this._isAnimatedProperty[b] = !0, this._updateSvgTransformAttr && "transform" == a.unprefixedPropertyName(b) && (null == this._savedTransformAttr && (this._savedTransformAttr = this._element.getAttribute("transform")), this._element.setAttribute("transform", a.transformToSvgMatrix(c)));
        },
        _clear: function (b) {
          this._style[b] = this._surrogateStyle[b], this._updateSvgTransformAttr && "transform" == a.unprefixedPropertyName(b) && (this._savedTransformAttr ? this._element.setAttribute("transform", this._savedTransformAttr) : this._element.removeAttribute("transform"), this._savedTransformAttr = null), delete this._isAnimatedProperty[b];
        }
      };

      for (var k in i) e.prototype[k] = function (a, b) {
        return function () {
          var c = this._surrogateStyle[a].apply(this._surrogateStyle, arguments);

          return b && (this._isAnimatedProperty[arguments[0]] || this._style[a].apply(this._style, arguments), this._updateIndices()), c;
        };
      }(k, k in j);

      for (var l in document.documentElement.style) l in h || l in i || function (a) {
        d(e.prototype, a, {
          get: function () {
            return this._surrogateStyle[a];
          },
          set: function (b) {
            this._surrogateStyle[a] = b, this._updateIndices(), this._isAnimatedProperty[a] || (this._style[a] = b);
          }
        });
      }(l);

      a.apply = function (b, c, d) {
        f(b), b.style._set(a.propertyName(c), d);
      }, a.clear = function (b, c) {
        b._webAnimationsPatchedStyle && b.style._clear(a.propertyName(c));
      };
    }(b), function (a) {
      window.Element.prototype.animate = function (b, c) {
        var d = "";
        return c && c.id && (d = c.id), a.timeline._play(a.KeyframeEffect(this, b, c, d));
      };
    }(b), function (a, b) {
      function c(a, b, d) {
        if ("number" == typeof a && "number" == typeof b) return a * (1 - d) + b * d;
        if ("boolean" == typeof a && "boolean" == typeof b) return d < .5 ? a : b;

        if (a.length == b.length) {
          for (var e = [], f = 0; f < a.length; f++) e.push(c(a[f], b[f], d));

          return e;
        }

        throw "Mismatched interpolation arguments " + a + ":" + b;
      }

      a.Interpolation = function (a, b, d) {
        return function (e) {
          return d(c(a, b, e));
        };
      };
    }(b), function (a, b) {
      function c(a, b, c) {
        return Math.max(Math.min(a, c), b);
      }

      function d(b, d, e) {
        var f = a.dot(b, d);
        f = c(f, -1, 1);
        var g = [];
        if (1 === f) g = b;else for (var h = Math.acos(f), i = 1 * Math.sin(e * h) / Math.sqrt(1 - f * f), j = 0; j < 4; j++) g.push(b[j] * (Math.cos(e * h) - f * i) + d[j] * i);
        return g;
      }

      var e = function () {
        function a(a, b) {
          for (var c = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], d = 0; d < 4; d++) for (var e = 0; e < 4; e++) for (var f = 0; f < 4; f++) c[d][e] += b[d][f] * a[f][e];

          return c;
        }

        function b(a) {
          return 0 == a[0][2] && 0 == a[0][3] && 0 == a[1][2] && 0 == a[1][3] && 0 == a[2][0] && 0 == a[2][1] && 1 == a[2][2] && 0 == a[2][3] && 0 == a[3][2] && 1 == a[3][3];
        }

        function c(c, d, e, f, g) {
          for (var h = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], i = 0; i < 4; i++) h[i][3] = g[i];

          for (var i = 0; i < 3; i++) for (var j = 0; j < 3; j++) h[3][i] += c[j] * h[j][i];

          var k = f[0],
              l = f[1],
              m = f[2],
              n = f[3],
              o = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
          o[0][0] = 1 - 2 * (l * l + m * m), o[0][1] = 2 * (k * l - m * n), o[0][2] = 2 * (k * m + l * n), o[1][0] = 2 * (k * l + m * n), o[1][1] = 1 - 2 * (k * k + m * m), o[1][2] = 2 * (l * m - k * n), o[2][0] = 2 * (k * m - l * n), o[2][1] = 2 * (l * m + k * n), o[2][2] = 1 - 2 * (k * k + l * l), h = a(h, o);
          var p = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
          e[2] && (p[2][1] = e[2], h = a(h, p)), e[1] && (p[2][1] = 0, p[2][0] = e[0], h = a(h, p)), e[0] && (p[2][0] = 0, p[1][0] = e[0], h = a(h, p));

          for (var i = 0; i < 3; i++) for (var j = 0; j < 3; j++) h[i][j] *= d[i];

          return b(h) ? [h[0][0], h[0][1], h[1][0], h[1][1], h[3][0], h[3][1]] : h[0].concat(h[1], h[2], h[3]);
        }

        return c;
      }();

      a.composeMatrix = e, a.quat = d;
    }(b), function (a, b, c) {
      a.sequenceNumber = 0;

      var d = function (a, b, c) {
        this.target = a, this.currentTime = b, this.timelineTime = c, this.type = "finish", this.bubbles = !1, this.cancelable = !1, this.currentTarget = a, this.defaultPrevented = !1, this.eventPhase = Event.AT_TARGET, this.timeStamp = Date.now();
      };

      b.Animation = function (b) {
        this.id = "", b && b._id && (this.id = b._id), this._sequenceNumber = a.sequenceNumber++, this._currentTime = 0, this._startTime = null, this._paused = !1, this._playbackRate = 1, this._inTimeline = !0, this._finishedFlag = !0, this.onfinish = null, this._finishHandlers = [], this._effect = b, this._inEffect = this._effect._update(0), this._idle = !0, this._currentTimePending = !1;
      }, b.Animation.prototype = {
        _ensureAlive: function () {
          this.playbackRate < 0 && 0 === this.currentTime ? this._inEffect = this._effect._update(-1) : this._inEffect = this._effect._update(this.currentTime), this._inTimeline || !this._inEffect && this._finishedFlag || (this._inTimeline = !0, b.timeline._animations.push(this));
        },
        _tickCurrentTime: function (a, b) {
          a != this._currentTime && (this._currentTime = a, this._isFinished && !b && (this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0), this._ensureAlive());
        },

        get currentTime() {
          return this._idle || this._currentTimePending ? null : this._currentTime;
        },

        set currentTime(a) {
          a = +a, isNaN(a) || (b.restart(), this._paused || null == this._startTime || (this._startTime = this._timeline.currentTime - a / this._playbackRate), this._currentTimePending = !1, this._currentTime != a && (this._idle && (this._idle = !1, this._paused = !0), this._tickCurrentTime(a, !0), b.applyDirtiedAnimation(this)));
        },

        get startTime() {
          return this._startTime;
        },

        set startTime(a) {
          a = +a, isNaN(a) || this._paused || this._idle || (this._startTime = a, this._tickCurrentTime((this._timeline.currentTime - this._startTime) * this.playbackRate), b.applyDirtiedAnimation(this));
        },

        get playbackRate() {
          return this._playbackRate;
        },

        set playbackRate(a) {
          if (a != this._playbackRate) {
            var c = this.currentTime;
            this._playbackRate = a, this._startTime = null, "paused" != this.playState && "idle" != this.playState && (this._finishedFlag = !1, this._idle = !1, this._ensureAlive(), b.applyDirtiedAnimation(this)), null != c && (this.currentTime = c);
          }
        },

        get _isFinished() {
          return !this._idle && (this._playbackRate > 0 && this._currentTime >= this._totalDuration || this._playbackRate < 0 && this._currentTime <= 0);
        },

        get _totalDuration() {
          return this._effect._totalDuration;
        },

        get playState() {
          return this._idle ? "idle" : null == this._startTime && !this._paused && 0 != this.playbackRate || this._currentTimePending ? "pending" : this._paused ? "paused" : this._isFinished ? "finished" : "running";
        },

        _rewind: function () {
          if (this._playbackRate >= 0) this._currentTime = 0;else {
            if (!(this._totalDuration < 1 / 0)) throw new DOMException("Unable to rewind negative playback rate animation with infinite duration", "InvalidStateError");
            this._currentTime = this._totalDuration;
          }
        },
        play: function () {
          this._paused = !1, (this._isFinished || this._idle) && (this._rewind(), this._startTime = null), this._finishedFlag = !1, this._idle = !1, this._ensureAlive(), b.applyDirtiedAnimation(this);
        },
        pause: function () {
          this._isFinished || this._paused || this._idle ? this._idle && (this._rewind(), this._idle = !1) : this._currentTimePending = !0, this._startTime = null, this._paused = !0;
        },
        finish: function () {
          this._idle || (this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0, this._startTime = this._totalDuration - this.currentTime, this._currentTimePending = !1, b.applyDirtiedAnimation(this));
        },
        cancel: function () {
          this._inEffect && (this._inEffect = !1, this._idle = !0, this._paused = !1, this._finishedFlag = !0, this._currentTime = 0, this._startTime = null, this._effect._update(null), b.applyDirtiedAnimation(this));
        },
        reverse: function () {
          this.playbackRate *= -1, this.play();
        },
        addEventListener: function (a, b) {
          "function" == typeof b && "finish" == a && this._finishHandlers.push(b);
        },
        removeEventListener: function (a, b) {
          if ("finish" == a) {
            var c = this._finishHandlers.indexOf(b);

            c >= 0 && this._finishHandlers.splice(c, 1);
          }
        },
        _fireEvents: function (a) {
          if (this._isFinished) {
            if (!this._finishedFlag) {
              var b = new d(this, this._currentTime, a),
                  c = this._finishHandlers.concat(this.onfinish ? [this.onfinish] : []);

              setTimeout(function () {
                c.forEach(function (a) {
                  a.call(b.target, b);
                });
              }, 0), this._finishedFlag = !0;
            }
          } else this._finishedFlag = !1;
        },
        _tick: function (a, b) {
          this._idle || this._paused || (null == this._startTime ? b && (this.startTime = a - this._currentTime / this.playbackRate) : this._isFinished || this._tickCurrentTime((a - this._startTime) * this.playbackRate)), b && (this._currentTimePending = !1, this._fireEvents(a));
        },

        get _needsTick() {
          return this.playState in {
            pending: 1,
            running: 1
          } || !this._finishedFlag;
        },

        _targetAnimations: function () {
          var a = this._effect._target;
          return a._activeAnimations || (a._activeAnimations = []), a._activeAnimations;
        },
        _markTarget: function () {
          var a = this._targetAnimations();

          -1 === a.indexOf(this) && a.push(this);
        },
        _unmarkTarget: function () {
          var a = this._targetAnimations(),
              b = a.indexOf(this);

          -1 !== b && a.splice(b, 1);
        }
      };
    }(a, b), function (a, b, c) {
      function d(a) {
        var b = j;
        j = [], a < q.currentTime && (a = q.currentTime), q._animations.sort(e), q._animations = h(a, !0, q._animations)[0], b.forEach(function (b) {
          b[1](a);
        }), g(), l = void 0;
      }

      function e(a, b) {
        return a._sequenceNumber - b._sequenceNumber;
      }

      function f() {
        this._animations = [], this.currentTime = window.performance && performance.now ? performance.now() : 0;
      }

      function g() {
        o.forEach(function (a) {
          a();
        }), o.length = 0;
      }

      function h(a, c, d) {
        p = !0, n = !1, b.timeline.currentTime = a, m = !1;
        var e = [],
            f = [],
            g = [],
            h = [];
        return d.forEach(function (b) {
          b._tick(a, c), b._inEffect ? (f.push(b._effect), b._markTarget()) : (e.push(b._effect), b._unmarkTarget()), b._needsTick && (m = !0);
          var d = b._inEffect || b._needsTick;
          b._inTimeline = d, d ? g.push(b) : h.push(b);
        }), o.push.apply(o, e), o.push.apply(o, f), m && requestAnimationFrame(function () {}), p = !1, [g, h];
      }

      var i = window.requestAnimationFrame,
          j = [],
          k = 0;
      window.requestAnimationFrame = function (a) {
        var b = k++;
        return 0 == j.length && i(d), j.push([b, a]), b;
      }, window.cancelAnimationFrame = function (a) {
        j.forEach(function (b) {
          b[0] == a && (b[1] = function () {});
        });
      }, f.prototype = {
        _play: function (c) {
          c._timing = a.normalizeTimingInput(c.timing);
          var d = new b.Animation(c);
          return d._idle = !1, d._timeline = this, this._animations.push(d), b.restart(), b.applyDirtiedAnimation(d), d;
        }
      };
      var l = void 0,
          m = !1,
          n = !1;
      b.restart = function () {
        return m || (m = !0, requestAnimationFrame(function () {}), n = !0), n;
      }, b.applyDirtiedAnimation = function (a) {
        if (!p) {
          a._markTarget();

          var c = a._targetAnimations();

          c.sort(e), h(b.timeline.currentTime, !1, c.slice())[1].forEach(function (a) {
            var b = q._animations.indexOf(a);

            -1 !== b && q._animations.splice(b, 1);
          }), g();
        }
      };
      var o = [],
          p = !1,
          q = new f();
      b.timeline = q;
    }(a, b), function (a, b) {
      function c(a, b) {
        for (var c = 0, d = 0; d < a.length; d++) c += a[d] * b[d];

        return c;
      }

      function d(a, b) {
        return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
      }

      function e(a) {
        var b = a.rad || 0;
        return ((a.deg || 0) / 360 + (a.grad || 0) / 400 + (a.turn || 0)) * (2 * Math.PI) + b;
      }

      function f(a) {
        switch (a.t) {
          case "rotatex":
            var b = e(a.d[0]);
            return [1, 0, 0, 0, 0, Math.cos(b), Math.sin(b), 0, 0, -Math.sin(b), Math.cos(b), 0, 0, 0, 0, 1];

          case "rotatey":
            var b = e(a.d[0]);
            return [Math.cos(b), 0, -Math.sin(b), 0, 0, 1, 0, 0, Math.sin(b), 0, Math.cos(b), 0, 0, 0, 0, 1];

          case "rotate":
          case "rotatez":
            var b = e(a.d[0]);
            return [Math.cos(b), Math.sin(b), 0, 0, -Math.sin(b), Math.cos(b), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "rotate3d":
            var c = a.d[0],
                d = a.d[1],
                f = a.d[2],
                b = e(a.d[3]),
                g = c * c + d * d + f * f;
            if (0 === g) c = 1, d = 0, f = 0;else if (1 !== g) {
              var h = Math.sqrt(g);
              c /= h, d /= h, f /= h;
            }
            var i = Math.sin(b / 2),
                j = i * Math.cos(b / 2),
                k = i * i;
            return [1 - 2 * (d * d + f * f) * k, 2 * (c * d * k + f * j), 2 * (c * f * k - d * j), 0, 2 * (c * d * k - f * j), 1 - 2 * (c * c + f * f) * k, 2 * (d * f * k + c * j), 0, 2 * (c * f * k + d * j), 2 * (d * f * k - c * j), 1 - 2 * (c * c + d * d) * k, 0, 0, 0, 0, 1];

          case "scale":
            return [a.d[0], 0, 0, 0, 0, a.d[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "scalex":
            return [a.d[0], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "scaley":
            return [1, 0, 0, 0, 0, a.d[0], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "scalez":
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, a.d[0], 0, 0, 0, 0, 1];

          case "scale3d":
            return [a.d[0], 0, 0, 0, 0, a.d[1], 0, 0, 0, 0, a.d[2], 0, 0, 0, 0, 1];

          case "skew":
            var l = e(a.d[0]),
                m = e(a.d[1]);
            return [1, Math.tan(m), 0, 0, Math.tan(l), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "skewx":
            var b = e(a.d[0]);
            return [1, 0, 0, 0, Math.tan(b), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "skewy":
            var b = e(a.d[0]);
            return [1, Math.tan(b), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

          case "translate":
            var c = a.d[0].px || 0,
                d = a.d[1].px || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, c, d, 0, 1];

          case "translatex":
            var c = a.d[0].px || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, c, 0, 0, 1];

          case "translatey":
            var d = a.d[0].px || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, d, 0, 1];

          case "translatez":
            var f = a.d[0].px || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, f, 1];

          case "translate3d":
            var c = a.d[0].px || 0,
                d = a.d[1].px || 0,
                f = a.d[2].px || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, c, d, f, 1];

          case "perspective":
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, a.d[0].px ? -1 / a.d[0].px : 0, 0, 0, 0, 1];

          case "matrix":
            return [a.d[0], a.d[1], 0, 0, a.d[2], a.d[3], 0, 0, 0, 0, 1, 0, a.d[4], a.d[5], 0, 1];

          case "matrix3d":
            return a.d;
        }
      }

      function g(a) {
        return 0 === a.length ? [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] : a.map(f).reduce(d);
      }

      function h(a) {
        return [i(g(a))];
      }

      var i = function () {
        function a(a) {
          return a[0][0] * a[1][1] * a[2][2] + a[1][0] * a[2][1] * a[0][2] + a[2][0] * a[0][1] * a[1][2] - a[0][2] * a[1][1] * a[2][0] - a[1][2] * a[2][1] * a[0][0] - a[2][2] * a[0][1] * a[1][0];
        }

        function b(b) {
          for (var c = 1 / a(b), d = b[0][0], e = b[0][1], f = b[0][2], g = b[1][0], h = b[1][1], i = b[1][2], j = b[2][0], k = b[2][1], l = b[2][2], m = [[(h * l - i * k) * c, (f * k - e * l) * c, (e * i - f * h) * c, 0], [(i * j - g * l) * c, (d * l - f * j) * c, (f * g - d * i) * c, 0], [(g * k - h * j) * c, (j * e - d * k) * c, (d * h - e * g) * c, 0]], n = [], o = 0; o < 3; o++) {
            for (var p = 0, q = 0; q < 3; q++) p += b[3][q] * m[q][o];

            n.push(p);
          }

          return n.push(1), m.push(n), m;
        }

        function d(a) {
          return [[a[0][0], a[1][0], a[2][0], a[3][0]], [a[0][1], a[1][1], a[2][1], a[3][1]], [a[0][2], a[1][2], a[2][2], a[3][2]], [a[0][3], a[1][3], a[2][3], a[3][3]]];
        }

        function e(a, b) {
          for (var c = [], d = 0; d < 4; d++) {
            for (var e = 0, f = 0; f < 4; f++) e += a[f] * b[f][d];

            c.push(e);
          }

          return c;
        }

        function f(a) {
          var b = g(a);
          return [a[0] / b, a[1] / b, a[2] / b];
        }

        function g(a) {
          return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
        }

        function h(a, b, c, d) {
          return [c * a[0] + d * b[0], c * a[1] + d * b[1], c * a[2] + d * b[2]];
        }

        function i(a, b) {
          return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        }

        function j(j) {
          var k = [j.slice(0, 4), j.slice(4, 8), j.slice(8, 12), j.slice(12, 16)];
          if (1 !== k[3][3]) return null;

          for (var l = [], m = 0; m < 4; m++) l.push(k[m].slice());

          for (var m = 0; m < 3; m++) l[m][3] = 0;

          if (0 === a(l)) return null;
          var n,
              o = [];
          k[0][3] || k[1][3] || k[2][3] ? (o.push(k[0][3]), o.push(k[1][3]), o.push(k[2][3]), o.push(k[3][3]), n = e(o, d(b(l)))) : n = [0, 0, 0, 1];
          var p = k[3].slice(0, 3),
              q = [];
          q.push(k[0].slice(0, 3));
          var r = [];
          r.push(g(q[0])), q[0] = f(q[0]);
          var s = [];
          q.push(k[1].slice(0, 3)), s.push(c(q[0], q[1])), q[1] = h(q[1], q[0], 1, -s[0]), r.push(g(q[1])), q[1] = f(q[1]), s[0] /= r[1], q.push(k[2].slice(0, 3)), s.push(c(q[0], q[2])), q[2] = h(q[2], q[0], 1, -s[1]), s.push(c(q[1], q[2])), q[2] = h(q[2], q[1], 1, -s[2]), r.push(g(q[2])), q[2] = f(q[2]), s[1] /= r[2], s[2] /= r[2];
          var t = i(q[1], q[2]);
          if (c(q[0], t) < 0) for (var m = 0; m < 3; m++) r[m] *= -1, q[m][0] *= -1, q[m][1] *= -1, q[m][2] *= -1;
          var u,
              v,
              w = q[0][0] + q[1][1] + q[2][2] + 1;
          return w > 1e-4 ? (u = .5 / Math.sqrt(w), v = [(q[2][1] - q[1][2]) * u, (q[0][2] - q[2][0]) * u, (q[1][0] - q[0][1]) * u, .25 / u]) : q[0][0] > q[1][1] && q[0][0] > q[2][2] ? (u = 2 * Math.sqrt(1 + q[0][0] - q[1][1] - q[2][2]), v = [.25 * u, (q[0][1] + q[1][0]) / u, (q[0][2] + q[2][0]) / u, (q[2][1] - q[1][2]) / u]) : q[1][1] > q[2][2] ? (u = 2 * Math.sqrt(1 + q[1][1] - q[0][0] - q[2][2]), v = [(q[0][1] + q[1][0]) / u, .25 * u, (q[1][2] + q[2][1]) / u, (q[0][2] - q[2][0]) / u]) : (u = 2 * Math.sqrt(1 + q[2][2] - q[0][0] - q[1][1]), v = [(q[0][2] + q[2][0]) / u, (q[1][2] + q[2][1]) / u, .25 * u, (q[1][0] - q[0][1]) / u]), [p, r, s, v, n];
        }

        return j;
      }();

      a.dot = c, a.makeMatrixDecomposition = h, a.transformListToMatrix = g;
    }(b), function (a) {
      function b(a, b) {
        var c = a.exec(b);
        if (c) return c = a.ignoreCase ? c[0].toLowerCase() : c[0], [c, b.substr(c.length)];
      }

      function c(a, b) {
        b = b.replace(/^\s*/, "");
        var c = a(b);
        if (c) return [c[0], c[1].replace(/^\s*/, "")];
      }

      function d(a, d, e) {
        a = c.bind(null, a);

        for (var f = [];;) {
          var g = a(e);
          if (!g) return [f, e];
          if (f.push(g[0]), e = g[1], !(g = b(d, e)) || "" == g[1]) return [f, e];
          e = g[1];
        }
      }

      function e(a, b) {
        for (var c = 0, d = 0; d < b.length && (!/\s|,/.test(b[d]) || 0 != c); d++) if ("(" == b[d]) c++;else if (")" == b[d] && (c--, 0 == c && d++, c <= 0)) break;

        var e = a(b.substr(0, d));
        return void 0 == e ? void 0 : [e, b.substr(d)];
      }

      function f(a, b) {
        for (var c = a, d = b; c && d;) c > d ? c %= d : d %= c;

        return c = a * b / (c + d);
      }

      function g(a) {
        return function (b) {
          var c = a(b);
          return c && (c[0] = void 0), c;
        };
      }

      function h(a, b) {
        return function (c) {
          return a(c) || [b, c];
        };
      }

      function i(b, c) {
        for (var d = [], e = 0; e < b.length; e++) {
          var f = a.consumeTrimmed(b[e], c);
          if (!f || "" == f[0]) return;
          void 0 !== f[0] && d.push(f[0]), c = f[1];
        }

        if ("" == c) return d;
      }

      function j(a, b, c, d, e) {
        for (var g = [], h = [], i = [], j = f(d.length, e.length), k = 0; k < j; k++) {
          var l = b(d[k % d.length], e[k % e.length]);
          if (!l) return;
          g.push(l[0]), h.push(l[1]), i.push(l[2]);
        }

        return [g, h, function (b) {
          var d = b.map(function (a, b) {
            return i[b](a);
          }).join(c);
          return a ? a(d) : d;
        }];
      }

      function k(a, b, c) {
        for (var d = [], e = [], f = [], g = 0, h = 0; h < c.length; h++) if ("function" == typeof c[h]) {
          var i = c[h](a[g], b[g++]);
          d.push(i[0]), e.push(i[1]), f.push(i[2]);
        } else !function (a) {
          d.push(!1), e.push(!1), f.push(function () {
            return c[a];
          });
        }(h);

        return [d, e, function (a) {
          for (var b = "", c = 0; c < a.length; c++) b += f[c](a[c]);

          return b;
        }];
      }

      a.consumeToken = b, a.consumeTrimmed = c, a.consumeRepeated = d, a.consumeParenthesised = e, a.ignore = g, a.optional = h, a.consumeList = i, a.mergeNestedRepeated = j.bind(null, null), a.mergeWrappedNestedRepeated = j, a.mergeList = k;
    }(b), function (a) {
      function b(b) {
        function c(b) {
          var c = a.consumeToken(/^inset/i, b);
          return c ? (d.inset = !0, c) : (c = a.consumeLengthOrPercent(b)) ? (d.lengths.push(c[0]), c) : (c = a.consumeColor(b), c ? (d.color = c[0], c) : void 0);
        }

        var d = {
          inset: !1,
          lengths: [],
          color: null
        },
            e = a.consumeRepeated(c, /^/, b);
        if (e && e[0].length) return [d, e[1]];
      }

      function c(c) {
        var d = a.consumeRepeated(b, /^,/, c);
        if (d && "" == d[1]) return d[0];
      }

      function d(b, c) {
        for (; b.lengths.length < Math.max(b.lengths.length, c.lengths.length);) b.lengths.push({
          px: 0
        });

        for (; c.lengths.length < Math.max(b.lengths.length, c.lengths.length);) c.lengths.push({
          px: 0
        });

        if (b.inset == c.inset && !!b.color == !!c.color) {
          for (var d, e = [], f = [[], 0], g = [[], 0], h = 0; h < b.lengths.length; h++) {
            var i = a.mergeDimensions(b.lengths[h], c.lengths[h], 2 == h);
            f[0].push(i[0]), g[0].push(i[1]), e.push(i[2]);
          }

          if (b.color && c.color) {
            var j = a.mergeColors(b.color, c.color);
            f[1] = j[0], g[1] = j[1], d = j[2];
          }

          return [f, g, function (a) {
            for (var c = b.inset ? "inset " : " ", f = 0; f < e.length; f++) c += e[f](a[0][f]) + " ";

            return d && (c += d(a[1])), c;
          }];
        }
      }

      function e(b, c, d, e) {
        function f(a) {
          return {
            inset: a,
            color: [0, 0, 0, 0],
            lengths: [{
              px: 0
            }, {
              px: 0
            }, {
              px: 0
            }, {
              px: 0
            }]
          };
        }

        for (var g = [], h = [], i = 0; i < d.length || i < e.length; i++) {
          var j = d[i] || f(e[i].inset),
              k = e[i] || f(d[i].inset);
          g.push(j), h.push(k);
        }

        return a.mergeNestedRepeated(b, c, g, h);
      }

      var f = e.bind(null, d, ", ");
      a.addPropertiesHandler(c, f, ["box-shadow", "text-shadow"]);
    }(b), function (a, b) {
      function c(a) {
        return a.toFixed(3).replace(/0+$/, "").replace(/\.$/, "");
      }

      function d(a, b, c) {
        return Math.min(b, Math.max(a, c));
      }

      function e(a) {
        if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a)) return Number(a);
      }

      function f(a, b) {
        return [a, b, c];
      }

      function g(a, b) {
        if (0 != a) return i(0, 1 / 0)(a, b);
      }

      function h(a, b) {
        return [a, b, function (a) {
          return Math.round(d(1, 1 / 0, a));
        }];
      }

      function i(a, b) {
        return function (e, f) {
          return [e, f, function (e) {
            return c(d(a, b, e));
          }];
        };
      }

      function j(a) {
        var b = a.trim().split(/\s*[\s,]\s*/);

        if (0 !== b.length) {
          for (var c = [], d = 0; d < b.length; d++) {
            var f = e(b[d]);
            if (void 0 === f) return;
            c.push(f);
          }

          return c;
        }
      }

      function k(a, b) {
        if (a.length == b.length) return [a, b, function (a) {
          return a.map(c).join(" ");
        }];
      }

      function l(a, b) {
        return [a, b, Math.round];
      }

      a.clamp = d, a.addPropertiesHandler(j, k, ["stroke-dasharray"]), a.addPropertiesHandler(e, i(0, 1 / 0), ["border-image-width", "line-height"]), a.addPropertiesHandler(e, i(0, 1), ["opacity", "shape-image-threshold"]), a.addPropertiesHandler(e, g, ["flex-grow", "flex-shrink"]), a.addPropertiesHandler(e, h, ["orphans", "widows"]), a.addPropertiesHandler(e, l, ["z-index"]), a.parseNumber = e, a.parseNumberList = j, a.mergeNumbers = f, a.numberToString = c;
    }(b), function (a, b) {
      function c(a, b) {
        if ("visible" == a || "visible" == b) return [0, 1, function (c) {
          return c <= 0 ? a : c >= 1 ? b : "visible";
        }];
      }

      a.addPropertiesHandler(String, c, ["visibility"]);
    }(b), function (a, b) {
      function c(a) {
        a = a.trim(), f.fillStyle = "#000", f.fillStyle = a;
        var b = f.fillStyle;

        if (f.fillStyle = "#fff", f.fillStyle = a, b == f.fillStyle) {
          f.fillRect(0, 0, 1, 1);
          var c = f.getImageData(0, 0, 1, 1).data;
          f.clearRect(0, 0, 1, 1);
          var d = c[3] / 255;
          return [c[0] * d, c[1] * d, c[2] * d, d];
        }
      }

      function d(b, c) {
        return [b, c, function (b) {
          function c(a) {
            return Math.max(0, Math.min(255, a));
          }

          if (b[3]) for (var d = 0; d < 3; d++) b[d] = Math.round(c(b[d] / b[3]));
          return b[3] = a.numberToString(a.clamp(0, 1, b[3])), "rgba(" + b.join(",") + ")";
        }];
      }

      var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      e.width = e.height = 1;
      var f = e.getContext("2d");
      a.addPropertiesHandler(c, d, ["background-color", "border-bottom-color", "border-left-color", "border-right-color", "border-top-color", "color", "fill", "flood-color", "lighting-color", "outline-color", "stop-color", "stroke", "text-decoration-color"]), a.consumeColor = a.consumeParenthesised.bind(null, c), a.mergeColors = d;
    }(b), function (a, b) {
      function c(a) {
        function b() {
          var b = h.exec(a);
          g = b ? b[0] : void 0;
        }

        function c() {
          var a = Number(g);
          return b(), a;
        }

        function d() {
          if ("(" !== g) return c();
          b();
          var a = f();
          return ")" !== g ? NaN : (b(), a);
        }

        function e() {
          for (var a = d(); "*" === g || "/" === g;) {
            var c = g;
            b();
            var e = d();
            "*" === c ? a *= e : a /= e;
          }

          return a;
        }

        function f() {
          for (var a = e(); "+" === g || "-" === g;) {
            var c = g;
            b();
            var d = e();
            "+" === c ? a += d : a -= d;
          }

          return a;
        }

        var g,
            h = /([\+\-\w\.]+|[\(\)\*\/])/g;
        return b(), f();
      }

      function d(a, b) {
        if ("0" == (b = b.trim().toLowerCase()) && "px".search(a) >= 0) return {
          px: 0
        };

        if (/^[^(]*$|^calc/.test(b)) {
          b = b.replace(/calc\(/g, "(");
          var d = {};
          b = b.replace(a, function (a) {
            return d[a] = null, "U" + a;
          });

          for (var e = "U(" + a.source + ")", f = b.replace(/[-+]?(\d*\.)?\d+([Ee][-+]?\d+)?/g, "N").replace(new RegExp("N" + e, "g"), "D").replace(/\s[+-]\s/g, "O").replace(/\s/g, ""), g = [/N\*(D)/g, /(N|D)[*\/]N/g, /(N|D)O\1/g, /\((N|D)\)/g], h = 0; h < g.length;) g[h].test(f) ? (f = f.replace(g[h], "$1"), h = 0) : h++;

          if ("D" == f) {
            for (var i in d) {
              var j = c(b.replace(new RegExp("U" + i, "g"), "").replace(new RegExp(e, "g"), "*0"));
              if (!isFinite(j)) return;
              d[i] = j;
            }

            return d;
          }
        }
      }

      function e(a, b) {
        return f(a, b, !0);
      }

      function f(b, c, d) {
        var e,
            f = [];

        for (e in b) f.push(e);

        for (e in c) f.indexOf(e) < 0 && f.push(e);

        return b = f.map(function (a) {
          return b[a] || 0;
        }), c = f.map(function (a) {
          return c[a] || 0;
        }), [b, c, function (b) {
          var c = b.map(function (c, e) {
            return 1 == b.length && d && (c = Math.max(c, 0)), a.numberToString(c) + f[e];
          }).join(" + ");
          return b.length > 1 ? "calc(" + c + ")" : c;
        }];
      }

      var g = "px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",
          h = d.bind(null, new RegExp(g, "g")),
          i = d.bind(null, new RegExp(g + "|%", "g")),
          j = d.bind(null, /deg|rad|grad|turn/g);
      a.parseLength = h, a.parseLengthOrPercent = i, a.consumeLengthOrPercent = a.consumeParenthesised.bind(null, i), a.parseAngle = j, a.mergeDimensions = f;
      var k = a.consumeParenthesised.bind(null, h),
          l = a.consumeRepeated.bind(void 0, k, /^/),
          m = a.consumeRepeated.bind(void 0, l, /^,/);
      a.consumeSizePairList = m;

      var n = function (a) {
        var b = m(a);
        if (b && "" == b[1]) return b[0];
      },
          o = a.mergeNestedRepeated.bind(void 0, e, " "),
          p = a.mergeNestedRepeated.bind(void 0, o, ",");

      a.mergeNonNegativeSizePair = o, a.addPropertiesHandler(n, p, ["background-size"]), a.addPropertiesHandler(i, e, ["border-bottom-width", "border-image-width", "border-left-width", "border-right-width", "border-top-width", "flex-basis", "font-size", "height", "line-height", "max-height", "max-width", "outline-width", "width"]), a.addPropertiesHandler(i, f, ["border-bottom-left-radius", "border-bottom-right-radius", "border-top-left-radius", "border-top-right-radius", "bottom", "left", "letter-spacing", "margin-bottom", "margin-left", "margin-right", "margin-top", "min-height", "min-width", "outline-offset", "padding-bottom", "padding-left", "padding-right", "padding-top", "perspective", "right", "shape-margin", "stroke-dashoffset", "text-indent", "top", "vertical-align", "word-spacing"]);
    }(b), function (a, b) {
      function c(b) {
        return a.consumeLengthOrPercent(b) || a.consumeToken(/^auto/, b);
      }

      function d(b) {
        var d = a.consumeList([a.ignore(a.consumeToken.bind(null, /^rect/)), a.ignore(a.consumeToken.bind(null, /^\(/)), a.consumeRepeated.bind(null, c, /^,/), a.ignore(a.consumeToken.bind(null, /^\)/))], b);
        if (d && 4 == d[0].length) return d[0];
      }

      function e(b, c) {
        return "auto" == b || "auto" == c ? [!0, !1, function (d) {
          var e = d ? b : c;
          if ("auto" == e) return "auto";
          var f = a.mergeDimensions(e, e);
          return f[2](f[0]);
        }] : a.mergeDimensions(b, c);
      }

      function f(a) {
        return "rect(" + a + ")";
      }

      var g = a.mergeWrappedNestedRepeated.bind(null, f, e, ", ");
      a.parseBox = d, a.mergeBoxes = g, a.addPropertiesHandler(d, g, ["clip"]);
    }(b), function (a, b) {
      function c(a) {
        return function (b) {
          var c = 0;
          return a.map(function (a) {
            return a === k ? b[c++] : a;
          });
        };
      }

      function d(a) {
        return a;
      }

      function e(b) {
        if ("none" == (b = b.toLowerCase().trim())) return [];

        for (var c, d = /\s*(\w+)\(([^)]*)\)/g, e = [], f = 0; c = d.exec(b);) {
          if (c.index != f) return;
          f = c.index + c[0].length;
          var g = c[1],
              h = n[g];
          if (!h) return;
          var i = c[2].split(","),
              j = h[0];
          if (j.length < i.length) return;

          for (var k = [], o = 0; o < j.length; o++) {
            var p,
                q = i[o],
                r = j[o];
            if (void 0 === (p = q ? {
              A: function (b) {
                return "0" == b.trim() ? m : a.parseAngle(b);
              },
              N: a.parseNumber,
              T: a.parseLengthOrPercent,
              L: a.parseLength
            }[r.toUpperCase()](q) : {
              a: m,
              n: k[0],
              t: l
            }[r])) return;
            k.push(p);
          }

          if (e.push({
            t: g,
            d: k
          }), d.lastIndex == b.length) return e;
        }
      }

      function f(a) {
        return a.toFixed(6).replace(".000000", "");
      }

      function g(b, c) {
        if (b.decompositionPair !== c) {
          b.decompositionPair = c;
          var d = a.makeMatrixDecomposition(b);
        }

        if (c.decompositionPair !== b) {
          c.decompositionPair = b;
          var e = a.makeMatrixDecomposition(c);
        }

        return null == d[0] || null == e[0] ? [[!1], [!0], function (a) {
          return a ? c[0].d : b[0].d;
        }] : (d[0].push(0), e[0].push(1), [d, e, function (b) {
          var c = a.quat(d[0][3], e[0][3], b[5]);
          return a.composeMatrix(b[0], b[1], b[2], c, b[4]).map(f).join(",");
        }]);
      }

      function h(a) {
        return a.replace(/[xy]/, "");
      }

      function i(a) {
        return a.replace(/(x|y|z|3d)?$/, "3d");
      }

      function j(b, c) {
        var d = a.makeMatrixDecomposition && !0,
            e = !1;

        if (!b.length || !c.length) {
          b.length || (e = !0, b = c, c = []);

          for (var f = 0; f < b.length; f++) {
            var j = b[f].t,
                k = b[f].d,
                l = "scale" == j.substr(0, 5) ? 1 : 0;
            c.push({
              t: j,
              d: k.map(function (a) {
                if ("number" == typeof a) return l;
                var b = {};

                for (var c in a) b[c] = l;

                return b;
              })
            });
          }
        }

        var m = function (a, b) {
          return "perspective" == a && "perspective" == b || ("matrix" == a || "matrix3d" == a) && ("matrix" == b || "matrix3d" == b);
        },
            o = [],
            p = [],
            q = [];

        if (b.length != c.length) {
          if (!d) return;
          var r = g(b, c);
          o = [r[0]], p = [r[1]], q = [["matrix", [r[2]]]];
        } else for (var f = 0; f < b.length; f++) {
          var j,
              s = b[f].t,
              t = c[f].t,
              u = b[f].d,
              v = c[f].d,
              w = n[s],
              x = n[t];

          if (m(s, t)) {
            if (!d) return;
            var r = g([b[f]], [c[f]]);
            o.push(r[0]), p.push(r[1]), q.push(["matrix", [r[2]]]);
          } else {
            if (s == t) j = s;else if (w[2] && x[2] && h(s) == h(t)) j = h(s), u = w[2](u), v = x[2](v);else {
              if (!w[1] || !x[1] || i(s) != i(t)) {
                if (!d) return;
                var r = g(b, c);
                o = [r[0]], p = [r[1]], q = [["matrix", [r[2]]]];
                break;
              }

              j = i(s), u = w[1](u), v = x[1](v);
            }

            for (var y = [], z = [], A = [], B = 0; B < u.length; B++) {
              var C = "number" == typeof u[B] ? a.mergeNumbers : a.mergeDimensions,
                  r = C(u[B], v[B]);
              y[B] = r[0], z[B] = r[1], A.push(r[2]);
            }

            o.push(y), p.push(z), q.push([j, A]);
          }
        }

        if (e) {
          var D = o;
          o = p, p = D;
        }

        return [o, p, function (a) {
          return a.map(function (a, b) {
            var c = a.map(function (a, c) {
              return q[b][1][c](a);
            }).join(",");
            return "matrix" == q[b][0] && 16 == c.split(",").length && (q[b][0] = "matrix3d"), q[b][0] + "(" + c + ")";
          }).join(" ");
        }];
      }

      var k = null,
          l = {
        px: 0
      },
          m = {
        deg: 0
      },
          n = {
        matrix: ["NNNNNN", [k, k, 0, 0, k, k, 0, 0, 0, 0, 1, 0, k, k, 0, 1], d],
        matrix3d: ["NNNNNNNNNNNNNNNN", d],
        rotate: ["A"],
        rotatex: ["A"],
        rotatey: ["A"],
        rotatez: ["A"],
        rotate3d: ["NNNA"],
        perspective: ["L"],
        scale: ["Nn", c([k, k, 1]), d],
        scalex: ["N", c([k, 1, 1]), c([k, 1])],
        scaley: ["N", c([1, k, 1]), c([1, k])],
        scalez: ["N", c([1, 1, k])],
        scale3d: ["NNN", d],
        skew: ["Aa", null, d],
        skewx: ["A", null, c([k, m])],
        skewy: ["A", null, c([m, k])],
        translate: ["Tt", c([k, k, l]), d],
        translatex: ["T", c([k, l, l]), c([k, l])],
        translatey: ["T", c([l, k, l]), c([l, k])],
        translatez: ["L", c([l, l, k])],
        translate3d: ["TTL", d]
      };
      a.addPropertiesHandler(e, j, ["transform"]), a.transformToSvgMatrix = function (b) {
        var c = a.transformListToMatrix(e(b));
        return "matrix(" + f(c[0]) + " " + f(c[1]) + " " + f(c[4]) + " " + f(c[5]) + " " + f(c[12]) + " " + f(c[13]) + ")";
      };
    }(b), function (a) {
      function b(a) {
        var b = Number(a);
        if (!(isNaN(b) || b < 100 || b > 900 || b % 100 != 0)) return b;
      }

      function c(b) {
        return b = 100 * Math.round(b / 100), b = a.clamp(100, 900, b), 400 === b ? "normal" : 700 === b ? "bold" : String(b);
      }

      function d(a, b) {
        return [a, b, c];
      }

      a.addPropertiesHandler(b, d, ["font-weight"]);
    }(b), function (a) {
      function b(a) {
        var b = {};

        for (var c in a) b[c] = -a[c];

        return b;
      }

      function c(b) {
        return a.consumeToken(/^(left|center|right|top|bottom)\b/i, b) || a.consumeLengthOrPercent(b);
      }

      function d(b, d) {
        var e = a.consumeRepeated(c, /^/, d);

        if (e && "" == e[1]) {
          var f = e[0];

          if (f[0] = f[0] || "center", f[1] = f[1] || "center", 3 == b && (f[2] = f[2] || {
            px: 0
          }), f.length == b) {
            if (/top|bottom/.test(f[0]) || /left|right/.test(f[1])) {
              var h = f[0];
              f[0] = f[1], f[1] = h;
            }

            if (/left|right|center|Object/.test(f[0]) && /top|bottom|center|Object/.test(f[1])) return f.map(function (a) {
              return "object" == typeof a ? a : g[a];
            });
          }
        }
      }

      function e(d) {
        var e = a.consumeRepeated(c, /^/, d);

        if (e) {
          for (var f = e[0], h = [{
            "%": 50
          }, {
            "%": 50
          }], i = 0, j = !1, k = 0; k < f.length; k++) {
            var l = f[k];
            "string" == typeof l ? (j = /bottom|right/.test(l), i = {
              left: 0,
              right: 0,
              center: i,
              top: 1,
              bottom: 1
            }[l], h[i] = g[l], "center" == l && i++) : (j && (l = b(l), l["%"] = (l["%"] || 0) + 100), h[i] = l, i++, j = !1);
          }

          return [h, e[1]];
        }
      }

      function f(b) {
        var c = a.consumeRepeated(e, /^,/, b);
        if (c && "" == c[1]) return c[0];
      }

      var g = {
        left: {
          "%": 0
        },
        center: {
          "%": 50
        },
        right: {
          "%": 100
        },
        top: {
          "%": 0
        },
        bottom: {
          "%": 100
        }
      },
          h = a.mergeNestedRepeated.bind(null, a.mergeDimensions, " ");
      a.addPropertiesHandler(d.bind(null, 3), h, ["transform-origin"]), a.addPropertiesHandler(d.bind(null, 2), h, ["perspective-origin"]), a.consumePosition = e, a.mergeOffsetList = h;
      var i = a.mergeNestedRepeated.bind(null, h, ", ");
      a.addPropertiesHandler(f, i, ["background-position", "object-position"]);
    }(b), function (a) {
      function b(b) {
        var c = a.consumeToken(/^circle/, b);
        if (c && c[0]) return ["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0, /^\(/)), d, a.ignore(a.consumeToken.bind(void 0, /^at/)), a.consumePosition, a.ignore(a.consumeToken.bind(void 0, /^\)/))], c[1]));
        var f = a.consumeToken(/^ellipse/, b);
        if (f && f[0]) return ["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0, /^\(/)), e, a.ignore(a.consumeToken.bind(void 0, /^at/)), a.consumePosition, a.ignore(a.consumeToken.bind(void 0, /^\)/))], f[1]));
        var g = a.consumeToken(/^polygon/, b);
        return g && g[0] ? ["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0, /^\(/)), a.optional(a.consumeToken.bind(void 0, /^nonzero\s*,|^evenodd\s*,/), "nonzero,"), a.consumeSizePairList, a.ignore(a.consumeToken.bind(void 0, /^\)/))], g[1])) : void 0;
      }

      function c(b, c) {
        if (b[0] === c[0]) return "circle" == b[0] ? a.mergeList(b.slice(1), c.slice(1), ["circle(", a.mergeDimensions, " at ", a.mergeOffsetList, ")"]) : "ellipse" == b[0] ? a.mergeList(b.slice(1), c.slice(1), ["ellipse(", a.mergeNonNegativeSizePair, " at ", a.mergeOffsetList, ")"]) : "polygon" == b[0] && b[1] == c[1] ? a.mergeList(b.slice(2), c.slice(2), ["polygon(", b[1], g, ")"]) : void 0;
      }

      var d = a.consumeParenthesised.bind(null, a.parseLengthOrPercent),
          e = a.consumeRepeated.bind(void 0, d, /^/),
          f = a.mergeNestedRepeated.bind(void 0, a.mergeDimensions, " "),
          g = a.mergeNestedRepeated.bind(void 0, f, ",");
      a.addPropertiesHandler(b, c, ["shape-outside"]);
    }(b), function (a, b) {
      function c(a, b) {
        b.concat([a]).forEach(function (b) {
          b in document.documentElement.style && (d[a] = b), e[b] = a;
        });
      }

      var d = {},
          e = {};
      c("transform", ["webkitTransform", "msTransform"]), c("transformOrigin", ["webkitTransformOrigin"]), c("perspective", ["webkitPerspective"]), c("perspectiveOrigin", ["webkitPerspectiveOrigin"]), a.propertyName = function (a) {
        return d[a] || a;
      }, a.unprefixedPropertyName = function (a) {
        return e[a] || a;
      };
    }(b);
  }(), function () {
    if (void 0 === document.createElement("div").animate([]).oncancel) {
      var a;
      if (window.performance && performance.now) var a = function () {
        return performance.now();
      };else var a = function () {
        return Date.now();
      };

      var b = function (a, b, c) {
        this.target = a, this.currentTime = b, this.timelineTime = c, this.type = "cancel", this.bubbles = !1, this.cancelable = !1, this.currentTarget = a, this.defaultPrevented = !1, this.eventPhase = Event.AT_TARGET, this.timeStamp = Date.now();
      },
          c = window.Element.prototype.animate;

      window.Element.prototype.animate = function (d, e) {
        var f = c.call(this, d, e);
        f._cancelHandlers = [], f.oncancel = null;
        var g = f.cancel;

        f.cancel = function () {
          g.call(this);

          var c = new b(this, null, a()),
              d = this._cancelHandlers.concat(this.oncancel ? [this.oncancel] : []);

          setTimeout(function () {
            d.forEach(function (a) {
              a.call(c.target, c);
            });
          }, 0);
        };

        var h = f.addEventListener;

        f.addEventListener = function (a, b) {
          "function" == typeof b && "cancel" == a ? this._cancelHandlers.push(b) : h.call(this, a, b);
        };

        var i = f.removeEventListener;
        return f.removeEventListener = function (a, b) {
          if ("cancel" == a) {
            var c = this._cancelHandlers.indexOf(b);

            c >= 0 && this._cancelHandlers.splice(c, 1);
          } else i.call(this, a, b);
        }, f;
      };
    }
  }(), function (a) {
    var b = document.documentElement,
        c = null,
        d = !1;

    try {
      var e = getComputedStyle(b).getPropertyValue("opacity"),
          f = "0" == e ? "1" : "0";
      c = b.animate({
        opacity: [f, f]
      }, {
        duration: 1
      }), c.currentTime = 0, d = getComputedStyle(b).getPropertyValue("opacity") == f;
    } catch (a) {} finally {
      c && c.cancel();
    }

    if (!d) {
      var g = window.Element.prototype.animate;

      window.Element.prototype.animate = function (b, c) {
        return window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)), Array.isArray(b) || null === b || (b = a.convertToArrayForm(b)), g.call(this, b, c);
      };
    }
  }(a);
}();

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
Material design: [Meaningful
transitions](https://www.google.com/design/spec/animation/meaningful-transitions.html)

`neon-animated-pages` manages a set of pages and runs an animation when
switching between them. Its children pages should implement
`NeonAnimatableBehavior` and define `entry` and `exit` animations to be
run when switching to or switching out of the page.

@group Neon Elements
@element neon-animated-pages
*/

Polymer({
  _template: html`
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host > ::slotted(*) {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
      }

      :host > ::slotted(:not(.iron-selected):not(.neon-animating))
       {
        display: none !important;
      }

      :host > ::slotted(.neon-animating) {
        pointer-events: none;
      }
    </style>

    <slot id="content"></slot>
  `,
  is: 'neon-animated-pages',
  behaviors: [IronResizableBehavior, IronSelectableBehavior, NeonAnimationRunnerBehavior],
  properties: {
    activateEvent: {
      type: String,
      value: ''
    },
    // if true, the initial page selection will also be animated according to
    // its animation config.
    animateInitialSelection: {
      type: Boolean,
      value: false
    }
  },
  listeners: {
    'iron-select': '_onIronSelect',
    'neon-animation-finish': '_onNeonAnimationFinish'
  },
  _onIronSelect: function (event) {
    var selectedPage = event.detail.item; // Only consider child elements.

    if (this.items.indexOf(selectedPage) < 0) {
      return;
    }

    var oldPage = this._valueToItem(this._prevSelected) || false;
    this._prevSelected = this.selected; // on initial load and if animateInitialSelection is negated, simply display
    // selectedPage.

    if (!oldPage && !this.animateInitialSelection) {
      this._completeSelectedChanged();

      return;
    }

    this.animationConfig = []; // configure selectedPage animations.

    if (this.entryAnimation) {
      this.animationConfig.push({
        name: this.entryAnimation,
        node: selectedPage
      });
    } else {
      if (selectedPage.getAnimationConfig) {
        this.animationConfig.push({
          animatable: selectedPage,
          type: 'entry'
        });
      }
    } // configure oldPage animations iff exists.


    if (oldPage) {
      // cancel the currently running animation if one is ongoing.
      if (oldPage.classList.contains('neon-animating')) {
        this._squelchNextFinishEvent = true;
        this.cancelAnimation();

        this._completeSelectedChanged();

        this._squelchNextFinishEvent = false;
      } // configure the animation.


      if (this.exitAnimation) {
        this.animationConfig.push({
          name: this.exitAnimation,
          node: oldPage
        });
      } else {
        if (oldPage.getAnimationConfig) {
          this.animationConfig.push({
            animatable: oldPage,
            type: 'exit'
          });
        }
      } // display the oldPage during the transition.


      oldPage.classList.add('neon-animating');
    } // display the selectedPage during the transition.


    selectedPage.classList.add('neon-animating'); // actually run the animations.

    if (this.animationConfig.length >= 1) {
      // on first load, ensure we run animations only after element is attached.
      if (!this.isAttached) {
        this.async(function () {
          this.playAnimation(undefined, {
            fromPage: null,
            toPage: selectedPage
          });
        });
      } else {
        this.playAnimation(undefined, {
          fromPage: oldPage,
          toPage: selectedPage
        });
      }
    } else {
      this._completeSelectedChanged(oldPage, selectedPage);
    }
  },

  /**
   * @param {Object=} oldPage
   * @param {Object=} selectedPage
   */
  _completeSelectedChanged: function (oldPage, selectedPage) {
    if (selectedPage) {
      selectedPage.classList.remove('neon-animating');
    }

    if (oldPage) {
      oldPage.classList.remove('neon-animating');
    }

    if (!selectedPage || !oldPage) {
      var nodes = dom(this.$.content).getDistributedNodes();

      for (var node, index = 0; node = nodes[index]; index++) {
        node.classList && node.classList.remove('neon-animating');
      }
    }

    this.async(this._notifyPageResize);
  },
  _onNeonAnimationFinish: function (event) {
    if (this._squelchNextFinishEvent) {
      this._squelchNextFinishEvent = false;
      return;
    }

    this._completeSelectedChanged(event.detail.fromPage, event.detail.toPage);
  },
  _notifyPageResize: function () {
    var selectedPage = this.selectedItem || this._valueToItem(this.selected);

    this.resizerShouldNotify = function (element) {
      return element == selectedPage;
    };

    this.notifyResize();
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
`<neon-animatable>` is a simple container element implementing
`NeonAnimatableBehavior`. This is a convenience element for use with
`<neon-animated-pages>`.

```
<neon-animated-pages selected="0"
                     entry-animation="slide-from-right-animation"
                     exit-animation="slide-left-animation">
  <neon-animatable>1</neon-animatable>
  <neon-animatable>2</neon-animatable>
</neon-animated-pages>
```
*/

Polymer({
  _template: html`
    <style>
      :host {
        display: block;
      }
    </style>

    <slot></slot>
  `,
  is: 'neon-animatable',
  behaviors: [NeonAnimatableBehavior, IronResizableBehavior]
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<cascaded-animation>` applies an animation on an array of elements with a delay
between each. the delay defaults to 50ms.

Configuration:
```
{
  name: 'cascaded-animation',
  animation: <animation-name>,
  nodes: <array-of-nodes>,
  nodeDelay: <node-delay-in-ms>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'cascaded-animation',
  behaviors: [NeonAnimationBehavior],

  /**
   * @param {{
   *   animation: string,
   *   nodes: !Array<!Element>,
   *   nodeDelay: (number|undefined),
   *   timing: (Object|undefined)
   *  }} config
   */
  configure: function (config) {
    this._animations = [];
    var nodes = config.nodes;
    var effects = [];
    var nodeDelay = config.nodeDelay || 50;
    config.timing = config.timing || {};
    config.timing.delay = config.timing.delay || 0;
    var oldDelay = config.timing.delay;
    var abortedConfigure;

    for (var node, index = 0; node = nodes[index]; index++) {
      config.timing.delay += nodeDelay;
      config.node = node;
      var animation = document.createElement(config.animation);

      if (animation.isNeonAnimation) {
        var effect = animation.configure(config);

        this._animations.push(animation);

        effects.push(effect);
      } else {
        console.warn(this.is + ':', config.animation, 'not found!');
        abortedConfigure = true;
        break;
      }
    }

    config.timing.delay = oldDelay;
    config.node = null; // if a bad animation was configured, abort config.

    if (abortedConfigure) {
      return;
    }

    this._effect = new GroupEffect(effects);
    return this._effect;
  },
  complete: function () {
    for (var animation, index = 0; animation = this._animations[index]; index++) {
      animation.complete(animation.config);
    }
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Use `NeonSharedElementAnimationBehavior` to implement shared element
 * animations.
 * @polymerBehavior NeonSharedElementAnimationBehavior
 */

const NeonSharedElementAnimationBehaviorImpl = {
  properties: {
    /**
     * Cached copy of shared elements.
     */
    sharedElements: {
      type: Object
    }
  },

  /**
   * Finds shared elements based on `config`.
   */
  findSharedElements: function (config) {
    var fromPage = config.fromPage;
    var toPage = config.toPage;

    if (!fromPage || !toPage) {
      console.warn(this.is + ':', !fromPage ? 'fromPage' : 'toPage', 'is undefined!');
      return null;
    }

    if (!fromPage.sharedElements || !toPage.sharedElements) {
      console.warn(this.is + ':', 'sharedElements are undefined for', !fromPage.sharedElements ? fromPage : toPage);
      return null;
    }
    var from = fromPage.sharedElements[config.id];
    var to = toPage.sharedElements[config.id];

    if (!from || !to) {
      console.warn(this.is + ':', 'sharedElement with id', config.id, 'not found in', !from ? fromPage : toPage);
      return null;
    }

    this.sharedElements = {
      from: from,
      to: to
    };
    return this.sharedElements;
  }
};
/** @polymerBehavior */

const NeonSharedElementAnimationBehavior = [NeonAnimationBehavior, NeonSharedElementAnimationBehaviorImpl];

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<hero-animation>` is a shared element animation that scales and transform an
element such that it appears to be shared between two pages. Use this in
`<neon-animated-pages>`. The source page should use this animation in an 'exit'
animation and set the `fromPage` configuration property to itself, and the
destination page should use this animation in an `entry` animation and set the
`toPage` configuration property to itself. They should also define the hero
elements in the `sharedElements` property (not a configuration property, see
`NeonSharedElementAnimatableBehavior`).

Configuration:
```
{
  name: 'hero-animation',
  id: <shared-element-id>,
  timing: <animation-timing>,
  toPage: <node>, /* define for the destination page *\/
  fromPage: <node>, /* define for the source page *\/
}
```
*/

Polymer({
  is: 'hero-animation',
  behaviors: [NeonSharedElementAnimationBehavior],
  configure: function (config) {
    var shared = this.findSharedElements(config);

    if (!shared) {
      return;
    }

    var fromRect = shared.from.getBoundingClientRect();
    var toRect = shared.to.getBoundingClientRect();
    var deltaLeft = fromRect.left - toRect.left;
    var deltaTop = fromRect.top - toRect.top;
    var deltaWidth = fromRect.width / toRect.width;
    var deltaHeight = fromRect.height / toRect.height;
    this._effect = new KeyframeEffect(shared.to, [{
      'transform': 'translate(' + deltaLeft + 'px,' + deltaTop + 'px) scale(' + deltaWidth + ',' + deltaHeight + ')'
    }, {
      'transform': 'none'
    }], this.timingFromConfig(config));
    this.setPrefixedProperty(shared.to, 'transformOrigin', '0 0');
    shared.to.style.zIndex = 10000;
    shared.from.style.visibility = 'hidden';
    return this._effect;
  },
  complete: function (config) {
    var shared = this.findSharedElements(config);

    if (!shared) {
      return null;
    }

    shared.to.style.zIndex = '';
    shared.from.style.visibility = '';
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<opaque-animation>` makes an element `opacity:1` for the duration of the
animation. Used to prevent webkit/safari from drawing a frame before an
animation for elements that animate from display:none.
*/

Polymer({
  is: 'opaque-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'opacity': '1'
    }, {
      'opacity': '1'
    }], this.timingFromConfig(config));
    node.style.opacity = '0';
    return this._effect;
  },
  complete: function (config) {
    config.node.style.opacity = '';
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<ripple-animation>` scales and transform an element such that it appears to
ripple from either a shared element, or from a screen position, to full screen.

If using as a shared element animation in `<neon-animated-pages>`, use this
animation in an `exit` animation in the source page and in an `entry` animation
in the destination page. Also, define the hero elements in the `sharedElements`
property (not a configuration property, see
`NeonSharedElementAnimatableBehavior`).

If using a screen position, define the `gesture` property.

Configuration:
```
{
  name: 'ripple-animation`.
  id: <shared-element-id>, /* set this or gesture *\/
  gesture: {x: <page-x>, y: <page-y>}, /* set this or id *\/
  timing: <animation-timing>,
  toPage: <node>, /* define for the destination page *\/
  fromPage: <node>, /* define for the source page *\/
}
```
*/

Polymer({
  is: 'ripple-animation',
  behaviors: [NeonSharedElementAnimationBehavior],
  configure: function (config) {
    var shared = this.findSharedElements(config);

    if (!shared) {
      return null;
    }

    var translateX, translateY;
    var toRect = shared.to.getBoundingClientRect();

    if (config.gesture) {
      translateX = config.gesture.x - (toRect.left + toRect.width / 2);
      translateY = config.gesture.y - (toRect.top + toRect.height / 2);
    } else {
      var fromRect = shared.from.getBoundingClientRect();
      translateX = fromRect.left + fromRect.width / 2 - (toRect.left + toRect.width / 2);
      translateY = fromRect.top + fromRect.height / 2 - (toRect.top + toRect.height / 2);
    }

    var translate = 'translate(' + translateX + 'px,' + translateY + 'px)';
    var size = Math.max(toRect.width + Math.abs(translateX) * 2, toRect.height + Math.abs(translateY) * 2);
    var diameter = Math.sqrt(2 * size * size);
    var scaleX = diameter / toRect.width;
    var scaleY = diameter / toRect.height;
    var scale = 'scale(' + scaleX + ',' + scaleY + ')';
    this._effect = new KeyframeEffect(shared.to, [{
      'transform': translate + ' scale(0)'
    }, {
      'transform': translate + ' ' + scale
    }], this.timingFromConfig(config));
    this.setPrefixedProperty(shared.to, 'transformOrigin', '50% 50%');
    shared.to.style.borderRadius = '50%';
    return this._effect;
  },
  complete: function () {
    if (this.sharedElements) {
      this.setPrefixedProperty(this.sharedElements.to, 'transformOrigin', '');
      this.sharedElements.to.style.borderRadius = '';
    }
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<reverse-ripple-animation>` scales and transform an element such that it
appears to ripple down from this element, to either a shared element, or a
screen position.

If using as a shared element animation in `<neon-animated-pages>`, use this
animation in an `exit` animation in the source page and in an `entry` animation
in the destination page. Also, define the reverse-ripple elements in the
`sharedElements` property (not a configuration property, see
`NeonSharedElementAnimatableBehavior`).
If using a screen position, define the `gesture` property.
Configuration:
```
{
  name: 'reverse-ripple-animation`.
  id: <shared-element-id>, /* set this or gesture *\/
  gesture: {x: <page-x>, y: <page-y>}, /* set this or id *\/
  timing: <animation-timing>,
  toPage: <node>, /* define for the destination page *\/
  fromPage: <node>, /* define for the source page *\/
}
```
*/

Polymer({
  is: 'reverse-ripple-animation',
  behaviors: [NeonSharedElementAnimationBehavior],
  configure: function (config) {
    var shared = this.findSharedElements(config);

    if (!shared) {
      return null;
    }

    var translateX, translateY;
    var fromRect = shared.from.getBoundingClientRect();

    if (config.gesture) {
      translateX = config.gesture.x - (fromRect.left + fromRect.width / 2);
      translateY = config.gesture.y - (fromRect.top + fromRect.height / 2);
    } else {
      var toRect = shared.to.getBoundingClientRect();
      translateX = toRect.left + toRect.width / 2 - (fromRect.left + fromRect.width / 2);
      translateY = toRect.top + toRect.height / 2 - (fromRect.top + fromRect.height / 2);
    }

    var translate = 'translate(' + translateX + 'px,' + translateY + 'px)';
    var size = Math.max(fromRect.width + Math.abs(translateX) * 2, fromRect.height + Math.abs(translateY) * 2);
    var diameter = Math.sqrt(2 * size * size);
    var scaleX = diameter / fromRect.width;
    var scaleY = diameter / fromRect.height;
    var scale = 'scale(' + scaleX + ',' + scaleY + ')';
    this._effect = new KeyframeEffect(shared.from, [{
      'transform': translate + ' ' + scale
    }, {
      'transform': translate + ' scale(0)'
    }], this.timingFromConfig(config));
    this.setPrefixedProperty(shared.from, 'transformOrigin', '50% 50%');
    shared.from.style.borderRadius = '50%';
    return this._effect;
  },
  complete: function () {
    if (this.sharedElements) {
      this.setPrefixedProperty(this.sharedElements.from, 'transformOrigin', '');
      this.sharedElements.from.style.borderRadius = '';
    }
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<scale-down-animation>` animates the scale transform of an element from 1 to 0.
By default it scales in both the x and y axes.

Configuration:
```
{
  name: 'scale-down-animation',
  node: <node>,
  axis: 'x' | 'y' | '',
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'scale-down-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    var scaleProperty = 'scale(0, 0)';

    if (config.axis === 'x') {
      scaleProperty = 'scale(0, 1)';
    } else if (config.axis === 'y') {
      scaleProperty = 'scale(1, 0)';
    }

    this._effect = new KeyframeEffect(node, [{
      'transform': 'scale(1,1)'
    }, {
      'transform': scaleProperty
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<scale-up-animation>` animates the scale transform of an element from 0 to 1.
By default it scales in both the x and y axes.

Configuration:
```
{
  name: 'scale-up-animation',
  node: <node>,
  axis: 'x' | 'y' | '',
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'scale-up-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    var scaleProperty = 'scale(0)';

    if (config.axis === 'x') {
      scaleProperty = 'scale(0, 1)';
    } else if (config.axis === 'y') {
      scaleProperty = 'scale(1, 0)';
    }

    this._effect = new KeyframeEffect(node, [{
      'transform': scaleProperty
    }, {
      'transform': 'scale(1, 1)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-from-left-animation>` animates the transform of an element from
`translateX(-100%)` to `none`.
The `transformOrigin` defaults to `0 50%`.

Configuration:
```
{
  name: 'slide-from-left-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-from-left-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'translateX(-100%)'
    }, {
      'transform': 'none'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-from-right-animation>` animates the transform of an element from
`translateX(100%)` to `none`.
The `transformOrigin` defaults to `0 50%`.

Configuration:
```
{
  name: 'slide-from-right-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-from-right-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'translateX(100%)'
    }, {
      'transform': 'none'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-from-top-animation>` animates the transform of an element from
`translateY(-100%)` to `none`. The `transformOrigin` defaults to `50% 0`.

Configuration:
```
{
  name: 'slide-from-top-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-from-top-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'translateY(-100%)'
    }, {
      'transform': 'translateY(0%)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '50% 0');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-from-bottom-animation>` animates the transform of an element from `none`
to `translateY(100%)`. The `transformOrigin` defaults to `50% 0`.

Configuration:
```
{
  name: 'slide-from-bottom-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-from-bottom-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'translateY(100%)'
    }, {
      'transform': 'translateY(0)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '50% 0');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-left-animation>` animates the transform of an element from `none` to
`translateX(-100%)`. The `transformOrigin` defaults to `0 50%`.

Configuration:
```
{
  name: 'slide-left-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-left-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'none'
    }, {
      'transform': 'translateX(-100%)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-right-animation>` animates the transform of an element from `none` to
`translateX(100%)`. The `transformOrigin` defaults to `0 50%`.

Configuration:
```
{
  name: 'slide-right-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-right-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'none'
    }, {
      'transform': 'translateX(100%)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '0 50%');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-up-animation>` animates the transform of an element from `translateY(0)`
to `translateY(-100%)`. The `transformOrigin` defaults to `50% 0`.

Configuration:
```
{
  name: 'slide-up-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-up-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'translate(0)'
    }, {
      'transform': 'translateY(-100%)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '50% 0');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<slide-down-animation>` animates the transform of an element from `none`
`translateY(100%)`. The `transformOrigin` defaults to `50% 0`.

Configuration:
```
{
  name: 'slide-down-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'slide-down-animation',
  behaviors: [NeonAnimationBehavior],
  configure: function (config) {
    var node = config.node;
    this._effect = new KeyframeEffect(node, [{
      'transform': 'translateY(0%)'
    }, {
      'transform': 'translateY(100%)'
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    } else {
      this.setPrefixedProperty(node, 'transformOrigin', '50% 0');
    }

    return this._effect;
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<transform-animation>` animates a custom transform on an element. Use this to
animate multiple transform properties, or to apply a custom transform value.

Configuration:
```
{
  name: 'transform-animation',
  node: <node>,
  transformOrigin: <transform-origin>,
  transformFrom: <transform-from-string>,
  transformTo: <transform-to-string>,
  timing: <animation-timing>
}
```
*/

Polymer({
  is: 'transform-animation',
  behaviors: [NeonAnimationBehavior],

  /**
   * @param {{
   *   node: !Element,
   *   transformOrigin: (string|undefined),
   *   transformFrom: (string|undefined),
   *   transformTo: (string|undefined),
   *   timing: (Object|undefined)
   * }} config
   */
  configure: function (config) {
    var node = config.node;
    var transformFrom = config.transformFrom || 'none';
    var transformTo = config.transformTo || 'none';
    this._effect = new KeyframeEffect(node, [{
      'transform': transformFrom
    }, {
      'transform': transformTo
    }], this.timingFromConfig(config));

    if (config.transformOrigin) {
      this.setPrefixedProperty(node, 'transformOrigin', config.transformOrigin);
    }

    return this._effect;
  }
});

/**
 * `pb-select-odd`: Switch between available ODDs.
 * It loads the list of ODDs from `components-odd.xql`.
 * Emits a `pb-refresh` event to subscribed views.
 *
 * @fires pb-refresh - Fires a refresh event to subscribed views after a different ODD has been selected for display.
 * @fires pb-update - When received, resets the ODD selected to the one passed in the event
 * 
 */

class PbSelectOdd extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** The label to show on top of the dropdown menu */
      label: {
        type: String
      },

      /** The ODDs to show. */
      odds: {
        type: Array
      },
      name: {
        type: String
      },

      /** Currently selected ODD. If this property is set, the component
       * will immediately load the list of ODDs from the server and select
       * the given ODD.
       */
      odd: {
        type: String,
        notify: true
      }
    });
  }

  constructor() {
    super();
    this.label = 'document.selectODD';
    this.odds = [];
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-update', this._onTargetUpdate.bind(this));
  }

  firstUpdated() {
    super.firstUpdated();
    PbSelectOdd.waitOnce('pb-page-ready', () => {
      this._refresh();
    });
  }

  render() {
    return html$1`
            <paper-dropdown-menu id="menu" label="${translate(this.label)}" name="${this.name}">
                <paper-listbox id="odds" slot="dropdown-content" class="dropdown-content" selected="${this.odd}" 
                    attr-for-selected="value" @selected-item-changed="${this._selected}">
                    ${this.odds.map(item => html$1`<paper-item value="${item.name}">${item.label}</paper-item>`)}
                </paper-listbox>
            </paper-dropdown-menu>

            <iron-ajax
                id="load"
                verbose
                handle-as="json"
                method="get"
                with-credentials
                @response="${this._update}"></iron-ajax>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            paper-dropdown-menu {
                --paper-listbox-background-color: white;
                width: 100%;
            }
        `;
  }

  _selected() {
    const newOdd = this.shadowRoot.getElementById('odds').selected;

    if (newOdd === this.odd) {
      return;
    }

    this.odd = newOdd;
    console.log('<pb-select-odd> Switching to ODD %s', this.odd);
    const doc = this.getDocument();

    if (doc) {
      doc.odd = this.odd;
    }

    this.setParameter('odd', this.odd + '.odd');
    this.pushHistory('changed odd', {
      odd: this.odd
    });
    this.emitTo('pb-refresh', {
      odd: this.odd
    });
  }

  _refresh() {
    const load = this.shadowRoot.getElementById('load');

    if (this.minApiVersion('1.0.0')) {
      load.url = `${this.getEndpoint()}/api/odd`;
    } else {
      load.url = `${this.getEndpoint()}/modules/lib/components-list-odds.xql`;
    }

    load.params = {
      odd: this.odd
    };
    load.generateRequest();
  }

  _update() {
    const load = this.shadowRoot.getElementById('load');
    this.odds = load.lastResponse;
  }

  _onTargetUpdate(ev) {
    let newOdd = ev.detail.data.odd;

    if (newOdd) {
      newOdd = newOdd.replace(/^(.*?)\.[^\.]+$/, '$1');
    }

    if (newOdd !== this.odd) {
      console.log('<pb-select-odd> Set current ODD from %s to %s', this.odd, newOdd);
    }

    this.odd = newOdd;
  }

}
customElements.define('pb-select-odd', PbSelectOdd);

/**
 * `pb-select-template`: Switch between available page templates.
 * It loads the list of templates from `components-list-templates.xql`.
 * Emits a page reload on selection.
 *
 */

class PbSelectTemplate extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /** The label to show on top of the dropdown menu */
      label: {
        type: String
      },

      /** Currently selected ODD. If this property is set, the component
       * will immediately load the list of ODDs from the server and select
       * the given ODD.
       */
      template: {
        type: String
      },
      _templates: {
        type: Array
      }
    });
  }

  constructor() {
    super();
    this.label = 'document.selectTemplate';
    this._templates = [];
  }

  firstUpdated() {
    PbSelectTemplate.waitOnce('pb-page-ready', options => {
      this.template = options.template;
      const loader = this.shadowRoot.getElementById('getTemplates');

      if (this.minApiVersion('1.0.0')) {
        loader.url = `${options.endpoint}/api/templates`;
      } else {
        loader.url = `${options.endpoint}/modules/lib/components-list-templates.xql`;
      }

      loader.generateRequest();
    });
  }

  render() {
    return html$1`
            <paper-dropdown-menu id="menu" label="${translate(this.label)}" name="${this.name}">
                <paper-listbox id="templates" slot="dropdown-content" class="dropdown-content" 
                    selected="${this.template}" attr-for-selected="value"
                    @selected-item-changed="${this._selected}">
                ${this._templates.map(item => html$1`<paper-item value="${item.name}">${item.title}</paper-item>`)}
                </paper-listbox>
            </paper-dropdown-menu>

            <iron-ajax id="getTemplates" with-credentials
                handle-as="json" @response="${this._handleTemplatesResponse}"
                method="GET"></iron-ajax>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
            paper-dropdown-menu {
                --paper-listbox-background-color: white;
                width: 100%;
            }
        `;
  }

  _selected() {
    const newTemplate = this.shadowRoot.getElementById('templates').selected;

    if (newTemplate === this.template) {
      return;
    }

    this.setParameter('template', newTemplate);
    window.location = this.getUrl().toString();
  }

  _handleTemplatesResponse() {
    const loader = this.shadowRoot.getElementById('getTemplates');
    this._templates = loader.lastResponse;
  }

}
customElements.define('pb-select-template', PbSelectTemplate);

/**
 * Represents a geo location. Extends `pb-highlight`, but sends an additional `pb-geolocation` event
 * on mouseover.
 * 
 * For `pb-leaflet-map` to show markers for `pb-geolocation` elements, make sure that map subscribes to the channel
 * into which `pb-geolocation`s emit and that map is loaded before the emitting component, e.g. `pb-view`, by specifying 
 * `wait-for` property
 *
 * @slot - default unnamed slot for content. May also contain an option `<template>` element for content to be shown in a popup
 * @fires pb-geolocation - Sends geocoordinates
 * @cssprop --pb-highlight-color - Background color to highlight an element
 */

class PbGeolocation extends PbHighlight {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      longitude: {
        type: Number
      },
      latitude: {
        type: Number
      },

      /**
       * Optional label for the place, e.g. to display a marker
       */
      label: {
        type: String
      },

      /**
       * Name of the event which triggers a pb-geolocation event, e.g. 'click'.
       * Default is 'mouseover'.
       */
      event: {
        type: String
      },

      /**
       * Zoom level to use for the map if it centers on the location.
       */
      zoom: {
        type: Number
      },

      /**
       * If set, add location to a map automatically upon load by
       * emitting an event. If not set, locations are only added when
       * the configured event is triggered.
       */
      auto: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.event = 'mouseover';
    this.auto = false;
    this.zoom = null;
  }

  connectedCallback() {
    super.connectedCallback();

    if (this.event) {
      this.addEventListener(this.event, () => this.emitTo('pb-geolocation', {
        coordinates: {
          latitude: this.latitude,
          longitude: this.longitude
        },
        label: this.label,
        zoom: this.zoom,
        popup: this.popup,
        element: this
      }));
    }

    if (this.auto) {
      this.waitForChannel(() => {
        this.emitTo('pb-geolocation', {
          coordinates: {
            latitude: this.latitude,
            longitude: this.longitude
          },
          label: this.label,
          popup: this.popup,
          fitBounds: true,
          element: this
        });
      });
    }
  }

  render() {
    return html$1`<span id="content"><slot></slot></span>`;
  }

  get popup() {
    const template = this.querySelector('template');

    if (template) {
      const wrapper = document.createElement('div');
      wrapper.appendChild(template.content.cloneNode(true));
      return wrapper;
    }

    return null;
  }

  static get styles() {
    return css`
            :host {
                display: inline;
                cursor: pointer;
            }

            [name="popup"] {
                display: none;
            }

            @keyframes keyFrameBackgroundColorIn {
                0% {
                    background-color: inherit;
                }
                100% {
                    background-color: var(--pb-highlight-color, #F9E976);
                }
            }

            #content {
                display: inline;
            }

            .highlight-on {
                background-color: var(--pb-highlight-color, #F9E976);
                animation-name: keyFrameBackgroundColorIn;
                animation-duration: 500ms;
                animation-iteration-count: 1;
                animation-timing-function: ease-in;

            }

            .highlight-off {
                background-color: inherit;
            }
        `;
  }
  /**
   * Fired on mouseover
   *
   * @event pb-geolocation
   * @param {Object} coordinates an object with two properties: latitude and longitude
   * @param {String} label an optional label for the place
   */


}
customElements.define('pb-geolocation', PbGeolocation);

/**
 * Simple component to create repeatable form elements. It expects
 * an HTML template containing arbitrary HTML. For every repeated instance,
 * the template will be copied. All elements with a `name` attribute within the
 * copied template will be renamed to have an `[idx]` suffix denoting their position
 * within the instance list.
 * 
 * The element stamps the instances into light DOM, so a form wrapping around it will see
 * the form controls. One can therefore use a normal form submit.
 *
 */

class PbRepeat extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The initial number of (empty) instances to be shown
       * (1 by default).
       */
      initial: {
        type: Number
      },
      _instances: {
        type: Array
      }
    });
  }

  constructor() {
    super();
    this.initial = 1;
    this._instances = [];
  }

  connectedCallback() {
    super.connectedCallback();
    this.template = this.querySelector('template');
    const params = this.getParameters();

    this._computeInitial(params);

    if (this._instances.length === 0) {
      for (let i = 0; i < this.initial; i++) {
        this._add(params);
      }
    }
  }

  _computeInitial(params) {
    const sortedParams = Object.keys(params).filter(key => /\[\d+\]$/.test(key)).sort();

    if (sortedParams.length > 0) {
      const max = sortedParams[sortedParams.length - 1].replace(/^.*\[(\d+)\]$/, '$1');
      this.initial = parseInt(max, 10);
    }
  }

  setData(params) {
    this._instances = [];

    this._computeInitial(params);

    for (let i = 0; i < this.initial; i++) {
      this._add(params);
    }

    this.requestUpdate();
  }

  add() {
    this._add();

    this.requestUpdate();
  }

  _add(params) {
    const idx = this._instances.length + 1;
    const clone = document.importNode(this.template.content, true);
    const wrapper = document.createElement('div');
    wrapper.appendChild(clone);
    wrapper.querySelectorAll('[name]').forEach(input => {
      const name = `${input.name}[${idx}]`;

      if (params && params[name]) {
        if (input.type === 'checkbox' || input.type === 'radio') {
          input.checked = params[name] === input.value;
        } else {
          input.value = params[name];
        }
      }

      input.name = name;
    });

    this._instances.push(wrapper);
  }

  _renumber() {
    this._instances.forEach((instance, idx) => {
      instance.querySelectorAll('[name]').forEach(input => {
        const name = input.name.replace(/^(.*)\[\d+\]$/, '$1');
        input.name = `${name}[${idx + 1}]`;
      });
    });
  }

  delete(idx) {
    this._instances.splice(idx, 1);

    this._renumber();

    this.requestUpdate();
  }

  render() {
    return html$1`
            <div class="instances">${this._instances.map(this.renderInstance.bind(this))}</div>
            <paper-icon-button icon="add" @click="${this.add}"></paper-icon-button>
        `;
  }

  renderInstance(instance, idx) {
    return html$1`
            <div class="instance">
                ${instance}
                <paper-icon-button icon="delete" @click="${() => this.delete(idx)}"></paper-icon-button>
            </div>`;
  }

  createRenderRoot() {
    return this;
  }

}
customElements.define('pb-repeat', PbRepeat);

/**
 * Show an SVG image with zoom and pan functionality. The image URL may
 * either be specified via the `url` property or an `pb-show-annotation` event
 * sent to this component.
 *
 * @fires pb-show-annotation - When received, loads the image from the URL passed from the event
 * @cssprop --pb-svg-height - Height of the SVG element
 * @cssprop --pb-svg-width - Width of the SVG element
 */

class PbSvg extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The URL to load the SVG from.
       */
      url: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this._pan = null;
  }

  connectedCallback() {
    super.connectedCallback();
  }

  firstUpdated() {
    super.firstUpdated();
    window.ESGlobalBridge.requestAvailability();
    window.ESGlobalBridge.instance.load("svg-pan-zoom", `https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js`);
    window.addEventListener("es-bridge-svg-pan-zoom-loaded", this._onSvgPanZoomLoaded.bind(this), {
      once: true
    });
    this.container = this.shadowRoot.getElementById('image');
    this.subscribeTo('pb-show-annotation', ev => {
      console.log('<pb-svg> loading %s', ev.detail.file);
      this.url = ev.detail.file;
      this.load();
    });
  }

  _onSvgPanZoomLoaded() {
    this.load();
  }

  load() {
    if (this._pan) {
      this._pan.destroy();

      this._pan = null;
      this.container.innerHTML = '';
    }

    if (!this.url) {
      return;
    }

    fetch(this.url).then(response => response.text()).then(data => {
      const doc = new DOMParser().parseFromString(data, "image/svg+xml");
      const svg = doc.documentElement;
      this.container.appendChild(svg);
      this._pan = window.svgPanZoom(svg, {
        controlIconsEnabled: true,
        fit: true,
        center: true
      });
    });
  }

  render() {
    return html$1`<div id="image"></div>`;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            #image svg {
                height: var(--pb-svg-height, 100%);
                width: var(--pb-svg-width, 100%);
            }
        `;
  }

}
customElements.define('pb-svg', PbSvg);

/**
 * View zoomable images using a IIIF server.
 *
 * @fires pb-start-update - When received, resets the facsimile viewer
 * @fires pb-update - Checks the contents received for pb-facs-links
 * @fires pb-show-annotation - When received, sets up the viewer to select a particular image and highlight coordinates
 * @fires pb-facsimile-status - Indicates the status of loading an image into the viewer. The status is indicated
 * by the `status` property in event.detail as follows: `loading` - image was requested; `loaded` - image is displayed; 
 * `fail` - image could not be loaded.
 * 
 * @cssprop --pb-facsimile-height=auto - Max. height of the image viewer
 * @cssprop --pb-facsimile-border - Style for the annotation highlight border
 * @csspart image - exposes the inner div hosting the image viewer
 * 
 * @slot before - use for content which should be shown above the facsimile viewer
 * @slot after - use for content which should be shown below the facsimile viewer
 */

class PbFacsimile extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      // Image source
      src: {
        type: String
      },

      /**
       * Set to false to prevent the appearance of the default navigation controls.
       * Note that if set to false, the customs buttons set by the options
       * zoomInButton, zoomOutButton etc, are rendered inactive.
       */
      showNavigationControl: {
        type: Boolean,
        attribute: 'show-navigation-control'
      },
      // Set to true to make the navigator minimap appear.
      showNavigator: {
        type: Boolean,
        attribute: 'show-navigator'
      },

      /** If true then the 'Go home' button is displayed to go back to the original zoom and pan. */
      showHomeControl: {
        type: Boolean,
        attribute: 'show-home-control'
      },

      /** If true then the 'Toggle full page' button is displayed to switch between full page and normal mode. */
      showFullPageControl: {
        type: Boolean,
        attribute: 'show-full-page-control'
      },

      /**
       * Default zoom between: set to 0 to adjust to viewer size.
       */
      defaultZoomLevel: {
        type: Number,
        attribute: 'default-zoom-level'
      },

      /**
       * If true then the rotate left/right controls will be displayed
       * as part of the standard controls. This is also subject to the
       * browser support for rotate (e.g. viewer.drawer.canRotate()).
       */
      showRotationControl: {
        type: Boolean,
        attribute: 'show-rotation-control'
      },
      // Constrain during pan
      constrainDuringPan: {
        type: Boolean,
        attribute: 'contrain-during-pan'
      },

      /**
       *  The percentage ( as a number from 0 to 1 ) of the source image
       * which must be kept within the viewport.
       * If the image is dragged beyond that limit, it will 'bounce'
       * back until the minimum visibility ratio is achieved.
       * Setting this to 0 and wrapHorizontal ( or wrapVertical )
       * to true will provide the effect of an infinitely scrolling viewport.
       */
      visibilityRatio: {
        type: Number,
        attribute: 'visibility-ratio'
      },

      /**
       * If set, thumbnails of all images are shown in a reference strip at the
       * bottom of the viewer.
       */
      referenceStrip: {
        type: Boolean,
        attribute: 'reference-strip'
      },

      /**
       * Size ratio for the reference strip thumbnails. 0.2 by default.
       */
      referenceStripSizeRatio: {
        type: Number,
        attribute: 'reference-strip-size-ratio'
      },

      /**
       * Type of the source of the image to display: either 'iiif' or 'image'
       * (for simple image links not served via IIIF).
       */
      type: {
        type: String
      },
      baseUri: {
        type: String,
        attribute: 'base-uri'
      },

      /**
       * Path pointing to the location of openseadragon user interface images.
       */
      prefixUrl: {
        type: String,
        attribute: 'prefix-url'
      },

      /**
       * Array of facsimiles
       *
       */
      facsimiles: {
        type: Array
      },

      /**
       * Will be true if images were loaded for display, false if there are no images
       * to show.
       */
      loaded: {
        type: Boolean,
        reflect: true
      }
    });
  }

  constructor() {
    super();
    this._facsimiles = [];
    this.baseUri = '';
    this.type = 'iiif';
    this.visibilityRatio = 1;
    this.defaultZoomLevel = 0;
    this.showHomeControl = false;
    this.showNavigator = false;
    this.showNavigationControl = false;
    this.showFullPageControl = false;
    this.showRotationControl = false;
    this.constrainDuringPan = false;
    this.referenceStrip = false;
    this.referenceStripSizeRatio = 0.2;
    this.src = '';
    this.prefixUrl = '../images/openseadragon/';
    this.loaded = false;
  }

  set facsimiles(facs) {
    this._facsimiles = facs || [];
    this.loaded = this._facsimiles.length > 0;
    this.emitTo('pb-facsimile-status', {
      status: 'loading'
    });
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-start-update', this._clearAll.bind(this));
    this.subscribeTo('pb-update', this._fragmentUpdateListener.bind(this));
    this.subscribeTo('pb-show-annotation', this._showAnnotationListener.bind(this));
  }

  firstUpdated() {
    window.ESGlobalBridge.requestAvailability();
    const path = resolveURL('../lib/openseadragon.min.js');
    window.ESGlobalBridge.instance.load("openseadragon", path);
    window.addEventListener("es-bridge-openseadragon-loaded", this._initOpenSeadragon.bind(this), {
      once: true
    });
  }

  render() {
    return html$1`
            <slot name="before"></slot>
            <!-- Openseadragon -->
            <div id="viewer" part="image"></div>
            <slot name="after"></slot>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: flex;
                flex-direction: column;
                position: relative;
                background: transparent;
            }

            #runtime-overlay {
                border: var(--pb-facsimile-border, 4px solid rgba(0, 0, 128, 0.5));
            }

            #viewer {
                flex: 1;
                position: relative;
                max-height: var(--pb-facsimile-height, auto);
                width: 100%;
            }
        `;
  } // Init openseadragon


  _initOpenSeadragon() {
    const prefixUrl = resolveURL(this.prefixUrl + (this.prefixUrl.endsWith("/") ? "" : "/"));
    const options = {
      element: this.shadowRoot.getElementById('viewer'),
      prefixUrl,
      preserveViewport: true,
      sequenceMode: true,
      showZoomControl: true,
      showHomeControl: this.showHomeControl,
      showFullPageControl: this.showFullPageControl,
      showNavigator: this.showNavigator,
      showNavigationControl: this.showNavigationControl,
      showRotationControl: this.showRotationControl,
      autoHideControls: false,
      visibilityRatio: 1,
      minZoomLevel: 1,
      defaultZoomLevel: this.defaultZoomLevel,
      constrainDuringPan: true
    };

    if (this.referenceStrip) {
      options.showReferenceStrip = true;
      options.referenceStripSizeRatio = this.referenceStripSizeRatio;
    }

    this.viewer = OpenSeadragon(options);
    this.viewer.addHandler('open', () => {
      this.resetZoom();
      this.emitTo('pb-facsimile-status', {
        status: 'loaded'
      });
    });
    this.viewer.addHandler('open-failed', ev => {
      console.error('<pb-facsimile> open failed: %s', ev.message);
      this.loaded = false;
      this.emitTo('pb-facsimile-status', {
        status: 'fail'
      });
    });

    this._facsimileObserver();

    this.signalReady();
  }

  _facsimileObserver() {
    if (!this.viewer) {
      return;
    }

    if (this._facsimiles.length === 0) {
      return this.viewer.close();
    }

    const uris = this._facsimiles.map(fac => {
      if (this.type === 'iiif') {
        return `${this.baseUri}${fac}/info.json`;
      } else {
        return {
          tileSource: {
            type: 'image',
            url: `${this.baseUri}${fac}`,
            buildPyramid: false
          }
        };
      }
    });

    this.viewer.open(uris);
    this.viewer.goToPage(0);
  }

  _clearAll() {
    if (!this.viewer) {
      return;
    }

    this.resetZoom();
    this.viewer.clearOverlays();
    this.facsimiles = [];
  }

  _fragmentUpdateListener(event) {
    this.facsimiles = this._getFacsimilesFromData(event.detail.root);

    this._facsimileObserver();
  }

  _getFacsimilesFromData(elem) {
    const facsimiles = [];
    elem.querySelectorAll('pb-facs-link').forEach(cb => {
      if (cb.facs) {
        facsimiles.push(cb.facs);
      }
    });
    console.log('<pb-facsimile> _getFacsimilesFromData', facsimiles);
    return facsimiles;
  }

  _showAnnotationListener(event) {
    if (!this.viewer) {
      return;
    }

    const overlayId = 'runtime-overlay'; // remove old overlay

    this.viewer.removeOverlay(this.overlay); // check event data for completeness

    if (!event.detail.file || event.detail.file === 0) {
      return console.error('file missing', event.detail);
    }

    if (event.detail.coordinates && (!event.detail.coordinates[0] || event.detail.coordinates.length !== 4)) {
      return console.error('coords incomplete or missing', event.detail);
    } // find page to show


    const page = this._pageIndexByUrl(event.detail.file);

    if (page < 0) {
      return console.error('page not found', event.detail);
    }

    if (this.viewer.currentPage() !== page) {
      this.viewer.goToPage(page);
    }

    if (event.detail.coordinates) {
      // deconstruct given coordinates into variables
      const [x1, y1, w, h] = event.detail.coordinates;
      const currentRect = this.viewer.viewport.viewportToImageRectangle(this.viewer.viewport.getBounds(true)); // scroll into view?

      if (!currentRect.containsPoint(new OpenSeadragon.Point(x1, y1))) {
        this.viewer.viewport.fitBoundsWithConstraints(this.viewer.viewport.imageToViewportRectangle(x1, y1, currentRect.width, currentRect.height));
      } // create new overlay


      const overlay = this.overlay = document.createElement('div');
      overlay.id = overlayId; // place marker

      const marker = this.viewer.viewport.imageToViewportRectangle(x1, y1, w, h);
      this.viewer.addOverlay({
        element: overlay,
        location: marker
      });
    }
  }

  _pageIndexByUrl(file) {
    return this._facsimiles.indexOf(file);
  } // reset zoom


  resetZoom() {
    if (!this.viewer) {
      return;
    }

    this.viewer.viewport.goHome();
  }

}
customElements.define('pb-facsimile', PbFacsimile);

/**
 * A dropdown to select a DTS endpoint from a configured list.
 * The list may either be given as a JSON-formatted string within the
 * `endpoints` property or it can be loaded from a JSON file whose path
 * is specified via the `load` property.
 * 
 * The JSON should contain an array of objects, each having an `url` and
 * `title` property.
 * 
 * @fires dts-endpoint - Sets the endpoint
 */

class DtsSelectEndpoint extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The currently selected endpoint. Will be set from URL parameter if present.
       */
      endpoint: {
        type: String
      },
      label: {
        type: String
      },

      /**
       * Array of endpoints to select from, each being an object with
       * properties `url` and `title`.
       */
      endpoints: {
        type: Array
      },

      /**
       * Set to true to automatically select the first endpoint
       */
      auto: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.endpoints = [];
    this.label = 'dts.endpoint';
  }

  connectedCallback() {
    super.connectedCallback();
    this.endpoint = this.getParameter('endpoint');
  }

  updated(changedProperties) {
    super.updated();

    if (changedProperties.has('endpoints')) {
      const item = this.shadowRoot.getElementById('endpoints').selectedItem;

      if (!item && this.auto && this.endpoints.length > 0) {
        this.endpoint = this.endpoints[0].url;
      }
    }
  }

  render() {
    return html$1`
            <paper-dropdown-menu id="menu" label="${translate(this.label)}">
                <paper-listbox id="endpoints" slot="dropdown-content" class="dropdown-content" selected="${this.endpoint}" attr-for-selected="value"
                    @selected-item-changed="${this._selected}">
                    ${this.endpoints.map(ep => html$1`<paper-item value="${ep.url ? ep.url : ''}">${ep.title}</paper-item>`)}
                </paper-listbox>
            </paper-dropdown-menu>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
        `;
  }

  _selected() {
    const item = this.shadowRoot.getElementById('endpoints').selectedItem;

    if (!item) {
      return;
    }

    const newEndpoint = item.getAttribute('value');

    if (!newEndpoint) {
      return;
    }

    const endpoint = this.endpoints.find(endp => endp.url === newEndpoint);
    this.setParameter('endpoint', endpoint.url);
    this.pushHistory('dts-endpoint');
    console.log('<dts-select-endpoint> Setting endpoint to %s', newEndpoint);
    this.emitTo('dts-endpoint', {
      endpoint: endpoint.url,
      collection: endpoint.collection,
      reload: !this.endpoint
    });
    this.endpoint = endpoint.url;
  }

}
customElements.define('dts-select-endpoint', DtsSelectEndpoint);

/**
 * A client for the Distributed Text Services (DTS) protocol. This defines an API
 * for working with collections of text.
 * 
 *   
 * @slot toolbar - toolbar area
 * @slot pagination - pagination area
 * 
 * @csspart parent-link - Link to parent collection
 * @csspart collection-title - Collection title
 * @csspart title - Member title
 * @csspart author - Author
 * @csspart license - License information
 * @csspart link - Links
 * 
 * @fires pb-start-update - Fired before the element updates its content
 * @fires pb-results-received - Fired when results are received from the server
 * @fires pb-end-update - Fired after the element has finished updating its content
 * @fires dts-endpoint - When received sets the endpoint to the one passed in from the event
 * @fires pb-load - When received triggers the refresh accorting to the selected page 
 */

class DtsClient extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      baseUri: {
        type: String
      },
      data: {
        type: Object
      },
      collection: {
        type: String
      },
      page: {
        type: Number
      },
      perPage: {
        type: Number
      },
      _collectionEndpoint: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this._parentCollections = [];
    this.collection = 'default';
  }

  connectedCallback() {
    super.connectedCallback();
    this.collection = this.getParameter('id');
    this.page = this.getParameter('page');
    this.subscribeTo('dts-endpoint', ev => {
      this._setEndpoint(ev.detail.endpoint, ev.detail.collection, ev.detail.reload);
    });
    this.subscribeTo('pb-load', ev => {
      this.page = ev.detail.params.page;
      console.log('<dts-client> Loading page %d', this.page);

      this._update();
    });
  }

  firstUpdated() {
    super.firstUpdated();
    this.queryAPI = this.shadowRoot.getElementById('queryAPI');
    this.documentsAPI = this.shadowRoot.getElementById('documentsAPI');
    this.signalReady();
  }

  _setEndpoint(endpoint, collection, reload) {
    if (!reload) {
      this.page = null;
    }

    this.collection = collection;

    this._configureEndpoint(endpoint);

    this.baseUri = endpoint;
  }

  _configureEndpoint(newBaseUri) {
    if (newBaseUri) {
      console.log('<dts-client> initializing connection to endpoint %s', newBaseUri);
      this.emitTo('pb-start-update');
      this.queryAPI.url = newBaseUri;
      this.queryAPI.generateRequest();
    }
  }

  _navigate(ev, member, downwards = true) {
    ev.preventDefault();

    if (downwards) {
      this._parentCollections.push(this.collection);
    }

    this.collection = member && typeof member === 'object' ? member['@id'] : member;
    this.page = null;
    console.log('<dts-client> navigating to collection %s', this.collection);

    this._update();
  }

  _navigateUp(ev) {
    if (this._parentCollections.length === 0) {
      return;
    }

    this._navigate(ev, this._parentCollections.pop(), false);
  }

  _preview(ev, member) {
    ev.preventDefault();
    this.emitTo('pb-start-update');
    const path = member['dts:passage'] || member['dts:download'];
    const url = new URL(path, this.baseUri).toString();
    console.log('<dts-client> downloading %s', url);

    if (this.lessThanApiVersion('1.0.0')) {
      this.documentsAPI.url = `${this.getEndpoint()}/modules/lib/dts.xql`;
      this.documentsAPI.params = {
        'preview': url,
        'id': member['@id']
      };
    } else {
      this.documentsAPI.url = `${this.getEndpoint()}/api/dts/import`;
      this.documentsAPI.params = {
        uri: url,
        temp: true
      };
    }

    this.documentsAPI.generateRequest();
  }

  _download(ev, member) {
    this.emitTo('pb-start-update');
    const path = member['dts:passage'] || member['dts:download'];
    const url = new URL(path, this.baseUri).toString();
    console.log('<dts-client> importing %s', url);

    if (this.lessThanApiVersion('1.0.0')) {
      this.documentsAPI.url = `${this.getEndpoint()}/modules/lib/dts.xql`;
      this.documentsAPI.params = {
        'import': url,
        'id': member['@id']
      };
    } else {
      this.documentsAPI.url = `${this.getEndpoint()}/api/dts/import`;
      this.documentsAPI.params = {
        uri: url,
        temp: false
      };
    }

    this.documentsAPI.generateRequest();
  }

  _update() {
    this.emitTo('pb-start-update');
    const params = {};

    if (this.collection) {
      params.id = this.collection;
      this.setParameter('id', this.collection);
    }

    if (this.page) {
      params.page = this.page + 1;
      this.setParameter('page', this.page);
    }

    this.pushHistory('dts-client-navigate');
    this.queryAPI.params = params;
    this.queryAPI.url = this._collectionEndpoint;
    this.queryAPI.generateRequest();
  }

  _handleResponse() {
    const json = this.queryAPI.lastResponse;

    if (json['@type'] === 'EntryPoint') {
      this._collectionEndpoint = new URL(json.collections, this.baseUri).toString();
      console.log('<dts-client> configured collection endpoint: %s', this._collectionEndpoint);

      this._update();
    } else {
      this.data = json;
      console.log('<dts-client> received collection data: %o', json);

      if (!this.page && json.totalItems > json.member.length) {
        this.perPage = json.member.length;
      }

      this.emitTo('pb-results-received', {
        start: this.page && this.page > 0 ? this.page * this.perPage + 1 : 1,
        count: json.totalItems
      });
    }

    this.emitTo('pb-end-update');
  }

  _handlePreview() {
    const json = this.documentsAPI.lastResponse;
    this.emitTo('pb-end-update');
    const url = new URL(json.path, window.location.href);
    window.location = url;
  }

  _handleError(ev) {
    this.emitTo('pb-end-update');
    const msg = ev.target.lastError.response;
    const parser = new DOMParser();
    const doc = parser.parseFromString(msg, "application/xml");
    const node = doc.querySelector('message');
    const dialog = document.getElementById('errorDialog');
    const body = dialog.querySelector("paper-dialog-scrollable");

    if (node) {
      body.innerHTML = node.textContent;
    } else {
      body.innerHTML = ev.detail.error.message;
    }

    dialog.open();
  }

  static _getCreator(item) {
    const dc = item['dts:dublincore'];
    return dc ? dc['dc:creator'] : null;
  }

  static _getLicense(item) {
    const dc = item['dts:dublincore'];
    return dc ? dc['dc:license'] : null;
  }

  render() {
    return html$1`
            <slot name="toolbar"></slot>
            ${this.baseUri ? this._renderClient() : ''}
            
            <iron-ajax
                id="queryAPI"
                verbose
                handle-as="json"
                method="get"
                @response="${this._handleResponse}"
                @error="${this._handleError}"></iron-ajax>
            <iron-ajax
                id="documentsAPI"
                verbose
                handle-as="json"
                method="get"
                @response="${this._handlePreview}"
                @error="${this._handleError}"></iron-ajax>
        `;
  }

  _renderClient() {
    return html$1`
            <div class="uri">${this.baseUri}</div>
            <h3 part="collection-title">${this.data ? this.data.title : 'Loading ...'}</h3>
            <slot name="pagination"></slot>
            ${this._parentCollections.length > 0 || this.collection ? html$1`
                        <paper-button part="parent-link" @click="${this._navigateUp}">
                            <iron-icon icon="icons:arrow-upward"></iron-icon>
                            ${translate('browse.up')}
                        </paper-button>` : null}
            ${this.data ? this._renderMembers() : ''}
        `;
  }

  _renderMembers() {
    const members = [];
    this.data.member.forEach(member => {
      members.push(html$1`<div class="member">${this._renderMember(member)}</div>`);
    });
    return members;
  }

  _renderMember(member) {
    if (member['@type'] == 'Collection') {
      return html$1`
                <iron-icon icon="icons:folder-open"></iron-icon>
                <div class="details">
                    <a href="#" @click="${ev => this._navigate(ev, member)}" part="link">
                        <h4 class="collection" part="collection-title">
                            ${member.title}
                        </h4>
                    </a>
                </div>
            `;
    }

    const license = DtsClient._getLicense(member);

    return html$1`
            <iron-icon icon="icons:code"></iron-icon>
            <div class="details">
                <div>
                    <a href="#" @click="${ev => this._preview(ev, member)}" part="link">
                        <h4 part="title">
                            ${member.title}
                        </h4>
                    </a>
                    <p part="creator" class="creator">${DtsClient._getCreator(member)}</p>
                    ${license ? html$1`<p part="license" class="license"><a href="${license}">${translate('dts.licence')}</a></p>` : ''}
                </div>
                <iron-icon title="${translate('dts.import')}" icon="icons:file-download" 
                    @click="${ev => this._download(ev, member)}">
                </iron-icon>
            </div>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            .uri {
                color: #607d8a;
                margin-top: 12px;
                font-weight: bold;
            }
            h3 {
                margin-top: 0;
            }
            .member {
                display: flex;
            }
            .member .details {
                flex: 2;
                margin-left: 20px;
                display: flex;
                justify-content: space-between;
            }
            .member iron-icon {
                width: 24px;
            }
            .member h4 {
                margin: 0;
            }
            .member h4.collection {
                margin-bottom: 10px;
            }
            [name='toolbar'] {
                display: flex;
                justify-content: space-between;
                align-items: center;
                color: #f6a622;
                font-size: 85%;
            }
        `;
  }

}
customElements.define('dts-client', DtsClient);

/**
 * Embed a codepen project to show live code. Used for some documentation examples.
 *
 */

class PbCodepen extends LitElement {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * The user which created the codepen
       */
      user: {
        type: String
      },

      /**
       * Identifies the pen
       */
      hash: {
        type: String
      },

      /**
       * Height of the iframe in pixel
       */
      height: {
        type: Number
      },

      /**
       * Either 'dark' or 'light'
       */
      theme: {
        type: String
      },

      /**
       * If set, the codepen will not load before being
       * clicked by the user
       */
      preview: {
        type: Boolean
      },

      /**
       * Make the codepen editable (requires paid account)
       */
      editable: {
        type: Boolean
      }
    });
  }

  constructor() {
    super();
    this.height = 256;
    this.theme = 'light';
  }

  render() {
    let params = `height=${this.height}&theme-id=${this.theme}&default-tab=html,result`;

    if (this.editable) {
      params = `${params}&editable=true`;
    }

    const url = `https://codepen.io/${this.user}/embed/${this.preview ? 'preview/' : ''}${this.hash}?${params}`;
    return html$1`
            <iframe height="${this.height}" scrolling="no" title="${this.labe}l" 
                src="${url}" frameborder="no" allowtransparency="true" allowfullscreen>
                Loading codepen ...
            </iframe>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            iframe {
                width: 100%;
            }
        `;
  }

}
customElements.define('pb-codepen', PbCodepen);

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.marked = factory());
})(undefined, function () {

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  function createCommonjsModule(fn) {
    var module = {
      exports: {}
    };
    return fn(module, module.exports), module.exports;
  }

  var defaults = createCommonjsModule(function (module) {
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }

    function changeDefaults(newDefaults) {
      module.exports.defaults = newDefaults;
    }

    module.exports = {
      defaults: getDefaults(),
      getDefaults: getDefaults,
      changeDefaults: changeDefaults
    };
  });
  /**
   * Helpers
   */

  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  var getEscapeReplacement = function getEscapeReplacement(ch) {
    return escapeReplacements[ch];
  };

  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }

    return html;
  }

  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(unescapeTest, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';

      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }

      return '';
    });
  }

  var caret = /(^|[^\[])\^/g;

  function edit(regex, opt) {
    regex = regex.source || regex;
    opt = opt || '';
    var obj = {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }

  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      var prot;

      try {
        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
      } catch (e) {
        return null;
      }

      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return null;
      }
    }

    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }

    try {
      href = encodeURI(href).replace(/%25/g, '%');
    } catch (e) {
      return null;
    }

    return href;
  }

  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

  function resolveUrl(base, href) {
    if (!baseUrls[' ' + base]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (justDomain.test(base)) {
        baseUrls[' ' + base] = base + '/';
      } else {
        baseUrls[' ' + base] = rtrim(base, '/', true);
      }
    }

    base = baseUrls[' ' + base];
    var relativeBase = base.indexOf(':') === -1;

    if (href.substring(0, 2) === '//') {
      if (relativeBase) {
        return href;
      }

      return base.replace(protocol, '$1') + href;
    } else if (href.charAt(0) === '/') {
      if (relativeBase) {
        return href;
      }

      return base.replace(domain, '$1') + href;
    } else {
      return base + href;
    }
  }

  var noopTest = {
    exec: function noopTest() {}
  };

  function merge(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];

      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }

      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/);
    var i = 0;

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leading or trailing whitespace is ignored per the gfm spec
      cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }

    return cells;
  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
  // /c*$/ is vulnerable to REDOS.
  // invert: Remove suffix of non-c chars instead. Default falsey.


  function rtrim(str, c, invert) {
    var l = str.length;

    if (l === 0) {
      return '';
    } // Length of suffix matching the invert condition.


    var suffLen = 0; // Step left until we fail to match the invert condition.

    while (suffLen < l) {
      var currChar = str.charAt(l - suffLen - 1);

      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }

    return str.substr(0, l - suffLen);
  }

  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }

    var l = str.length;
    var level = 0,
        i = 0;

    for (; i < l; i++) {
      if (str[i] === '\\') {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;

        if (level < 0) {
          return i;
        }
      }
    }

    return -1;
  }

  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
    }
  } // copied from https://stackoverflow.com/a/5450113/806777


  function repeatString(pattern, count) {
    if (count < 1) {
      return '';
    }

    var result = '';

    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }

      count >>= 1;
      pattern += pattern;
    }

    return result + pattern;
  }

  var helpers = {
    escape: escape,
    unescape: unescape,
    edit: edit,
    cleanUrl: cleanUrl,
    resolveUrl: resolveUrl,
    noopTest: noopTest,
    merge: merge,
    splitCells: splitCells,
    rtrim: rtrim,
    findClosingBracket: findClosingBracket,
    checkSanitizeDeprecation: checkSanitizeDeprecation,
    repeatString: repeatString
  };
  var defaults$1 = defaults.defaults;
  var rtrim$1 = helpers.rtrim,
      splitCells$1 = helpers.splitCells,
      _escape = helpers.escape,
      findClosingBracket$1 = helpers.findClosingBracket;

  function outputLink(cap, link, raw) {
    var href = link.href;
    var title = link.title ? _escape(link.title) : null;
    var text = cap[1].replace(/\\([\[\]])/g, '$1');

    if (cap[0].charAt(0) !== '!') {
      return {
        type: 'link',
        raw: raw,
        href: href,
        title: title,
        text: text
      };
    } else {
      return {
        type: 'image',
        raw: raw,
        href: href,
        title: title,
        text: _escape(text)
      };
    }
  }

  function indentCodeCompensation(raw, text) {
    var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

    if (matchIndentToCode === null) {
      return text;
    }

    var indentToCode = matchIndentToCode[1];
    return text.split('\n').map(function (node) {
      var matchIndentInNode = node.match(/^\s+/);

      if (matchIndentInNode === null) {
        return node;
      }

      var indentInNode = matchIndentInNode[0];

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    }).join('\n');
  }
  /**
   * Tokenizer
   */


  var Tokenizer_1 = /*#__PURE__*/function () {
    function Tokenizer(options) {
      this.options = options || defaults$1;
    }

    var _proto = Tokenizer.prototype;

    _proto.space = function space(src) {
      var cap = this.rules.block.newline.exec(src);

      if (cap) {
        if (cap[0].length > 1) {
          return {
            type: 'space',
            raw: cap[0]
          };
        }

        return {
          raw: '\n'
        };
      }
    };

    _proto.code = function code(src, tokens) {
      var cap = this.rules.block.code.exec(src);

      if (cap) {
        var lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

        if (lastToken && lastToken.type === 'paragraph') {
          return {
            raw: cap[0],
            text: cap[0].trimRight()
          };
        }

        var text = cap[0].replace(/^ {1,4}/gm, '');
        return {
          type: 'code',
          raw: cap[0],
          codeBlockStyle: 'indented',
          text: !this.options.pedantic ? rtrim$1(text, '\n') : text
        };
      }
    };

    _proto.fences = function fences(src) {
      var cap = this.rules.block.fences.exec(src);

      if (cap) {
        var raw = cap[0];
        var text = indentCodeCompensation(raw, cap[3] || '');
        return {
          type: 'code',
          raw: raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: text
        };
      }
    };

    _proto.heading = function heading(src) {
      var cap = this.rules.block.heading.exec(src);

      if (cap) {
        var text = cap[2].trim(); // remove trailing #s

        if (/#$/.test(text)) {
          var trimmed = rtrim$1(text, '#');

          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            // CommonMark requires space before trailing #s
            text = trimmed.trim();
          }
        }

        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[1].length,
          text: text
        };
      }
    };

    _proto.nptable = function nptable(src) {
      var cap = this.rules.block.nptable.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
          raw: cap[0]
        };

        if (item.header.length === item.align.length) {
          var l = item.align.length;
          var i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells$1(item.cells[i], item.header.length);
          }

          return item;
        }
      }
    };

    _proto.hr = function hr(src) {
      var cap = this.rules.block.hr.exec(src);

      if (cap) {
        return {
          type: 'hr',
          raw: cap[0]
        };
      }
    };

    _proto.blockquote = function blockquote(src) {
      var cap = this.rules.block.blockquote.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ *> ?/gm, '');
        return {
          type: 'blockquote',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.list = function list(src) {
      var cap = this.rules.block.list.exec(src);

      if (cap) {
        var raw = cap[0];
        var bull = cap[2];
        var isordered = bull.length > 1;
        var list = {
          type: 'list',
          raw: raw,
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : '',
          loose: false,
          items: []
        }; // Get each top-level item.

        var itemMatch = cap[0].match(this.rules.block.item);
        var next = false,
            item,
            space,
            bcurr,
            bnext,
            addBack,
            loose,
            istask,
            ischecked;
        var l = itemMatch.length;
        bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);

        for (var i = 0; i < l; i++) {
          item = itemMatch[i];
          raw = item; // Determine whether the next list item belongs here.
          // Backpedal if it does not belong in this list.

          if (i !== l - 1) {
            bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

            if (!this.options.pedantic ? bnext[1].length > bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
              // nested list
              itemMatch.splice(i, 2, itemMatch[i] + '\n' + itemMatch[i + 1]);
              i--;
              l--;
              continue;
            } else {
              if ( // different bullet style
              !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                addBack = itemMatch.slice(i + 1).join('\n');
                list.raw = list.raw.substring(0, list.raw.length - addBack.length);
                i = l - 1;
              }
            }

            bcurr = bnext;
          } // Remove the list item's bullet
          // so it is seen as the next token.


          space = item.length;
          item = item.replace(/^ *([*+-]|\d+[.)]) ?/, ''); // Outdent whatever the
          // list item contains. Hacky.

          if (~item.indexOf('\n ')) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
          } // Determine whether item is loose or not.
          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
          // for discount behavior.


          loose = next || /\n\n(?!\s*$)/.test(item);

          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === '\n';
            if (!loose) loose = next;
          }

          if (loose) {
            list.loose = true;
          } // Check for task list items


          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.test(item);
            ischecked = undefined;

            if (istask) {
              ischecked = item[1] !== ' ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }
          }

          list.items.push({
            type: 'list_item',
            raw: raw,
            task: istask,
            checked: ischecked,
            loose: loose,
            text: item
          });
        }

        return list;
      }
    };

    _proto.html = function html(src) {
      var cap = this.rules.block.html.exec(src);

      if (cap) {
        return {
          type: this.options.sanitize ? 'paragraph' : 'html',
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.def = function def(src) {
      var cap = this.rules.block.def.exec(src);

      if (cap) {
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
        return {
          tag: tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    };

    _proto.table = function table(src) {
      var cap = this.rules.block.table.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          var l = item.align.length;
          var i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
          }

          return item;
        }
      }
    };

    _proto.lheading = function lheading(src) {
      var cap = this.rules.block.lheading.exec(src);

      if (cap) {
        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[2].charAt(0) === '=' ? 1 : 2,
          text: cap[1]
        };
      }
    };

    _proto.paragraph = function paragraph(src) {
      var cap = this.rules.block.paragraph.exec(src);

      if (cap) {
        return {
          type: 'paragraph',
          raw: cap[0],
          text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
        };
      }
    };

    _proto.text = function text(src, tokens) {
      var cap = this.rules.block.text.exec(src);

      if (cap) {
        var lastToken = tokens[tokens.length - 1];

        if (lastToken && lastToken.type === 'text') {
          return {
            raw: cap[0],
            text: cap[0]
          };
        }

        return {
          type: 'text',
          raw: cap[0],
          text: cap[0]
        };
      }
    };

    _proto.escape = function escape(src) {
      var cap = this.rules.inline.escape.exec(src);

      if (cap) {
        return {
          type: 'escape',
          raw: cap[0],
          text: _escape(cap[1])
        };
      }
    };

    _proto.tag = function tag(src, inLink, inRawBlock) {
      var cap = this.rules.inline.tag.exec(src);

      if (cap) {
        if (!inLink && /^<a /i.test(cap[0])) {
          inLink = true;
        } else if (inLink && /^<\/a>/i.test(cap[0])) {
          inLink = false;
        }

        if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = true;
        } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = false;
        }

        return {
          type: this.options.sanitize ? 'text' : 'html',
          raw: cap[0],
          inLink: inLink,
          inRawBlock: inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.link = function link(src) {
      var cap = this.rules.inline.link.exec(src);

      if (cap) {
        var trimmedUrl = cap[2].trim();

        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          // commonmark requires matching angle brackets
          if (!/>$/.test(trimmedUrl)) {
            return;
          } // ending angle bracket cannot be escaped


          var rtrimSlash = rtrim$1(trimmedUrl.slice(0, -1), '\\');

          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          // find closing parenthesis
          var lastParenIndex = findClosingBracket$1(cap[2], '()');

          if (lastParenIndex > -1) {
            var start = cap[0].indexOf('!') === 0 ? 5 : 4;
            var linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
        }

        var href = cap[2];
        var title = '';

        if (this.options.pedantic) {
          // split pedantic href and title
          var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : '';
        }

        href = href.trim();

        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            // pedantic allows starting angle bracket without ending angle bracket
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }

        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
          title: title ? title.replace(this.rules.inline._escapes, '$1') : title
        }, cap[0]);
      }
    };

    _proto.reflink = function reflink(src, links) {
      var cap;

      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = links[link.toLowerCase()];

        if (!link || !link.href) {
          var text = cap[0].charAt(0);
          return {
            type: 'text',
            raw: text,
            text: text
          };
        }

        return outputLink(cap, link, cap[0]);
      }
    };

    _proto.strong = function strong(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = '';
      }

      var match = this.rules.inline.strong.start.exec(src);

      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
        maskedSrc = maskedSrc.slice(-1 * src.length);
        var endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;
        endReg.lastIndex = 0;
        var cap;

        while ((match = endReg.exec(maskedSrc)) != null) {
          cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));

          if (cap) {
            return {
              type: 'strong',
              raw: src.slice(0, cap[0].length),
              text: src.slice(2, cap[0].length - 2)
            };
          }
        }
      }
    };

    _proto.em = function em(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = '';
      }

      var match = this.rules.inline.em.start.exec(src);

      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
        maskedSrc = maskedSrc.slice(-1 * src.length);
        var endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
        endReg.lastIndex = 0;
        var cap;

        while ((match = endReg.exec(maskedSrc)) != null) {
          cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));

          if (cap) {
            return {
              type: 'em',
              raw: src.slice(0, cap[0].length),
              text: src.slice(1, cap[0].length - 1)
            };
          }
        }
      }
    };

    _proto.codespan = function codespan(src) {
      var cap = this.rules.inline.code.exec(src);

      if (cap) {
        var text = cap[2].replace(/\n/g, ' ');
        var hasNonSpaceChars = /[^ ]/.test(text);
        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }

        text = _escape(text, true);
        return {
          type: 'codespan',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.br = function br(src) {
      var cap = this.rules.inline.br.exec(src);

      if (cap) {
        return {
          type: 'br',
          raw: cap[0]
        };
      }
    };

    _proto.del = function del(src) {
      var cap = this.rules.inline.del.exec(src);

      if (cap) {
        return {
          type: 'del',
          raw: cap[0],
          text: cap[2]
        };
      }
    };

    _proto.autolink = function autolink(src, mangle) {
      var cap = this.rules.inline.autolink.exec(src);

      if (cap) {
        var text, href;

        if (cap[2] === '@') {
          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = 'mailto:' + text;
        } else {
          text = _escape(cap[1]);
          href = text;
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.url = function url(src, mangle) {
      var cap;

      if (cap = this.rules.inline.url.exec(src)) {
        var text, href;

        if (cap[2] === '@') {
          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          var prevCapZero;

          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);

          text = _escape(cap[0]);

          if (cap[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {
      var cap = this.rules.inline.text.exec(src);

      if (cap) {
        var text;

        if (inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
        } else {
          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }

        return {
          type: 'text',
          raw: cap[0],
          text: text
        };
      }
    };

    return Tokenizer;
  }();

  var noopTest$1 = helpers.noopTest,
      edit$1 = helpers.edit,
      merge$1 = helpers.merge;
  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    nptable: noopTest$1,
    table: noopTest$1,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
  block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();
  block.listItemStart = edit$1(/^( *)(bull)/).replace('bull', block.bullet).getRegex();
  block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();
  /**
   * Normal Block Grammar
   */

  block.normal = merge$1({}, block);
  /**
   * GFM Block Grammar
   */

  block.gfm = merge$1({}, block.normal, {
    nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
    + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
    + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
    // Cells
    table: '^ *\\|(.+)\\n' // Header
    + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
    + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

  });
  block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */

  block.pedantic = merge$1({}, block.normal, {
    html: edit$1('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest$1,
    // fences not supported
    paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
  });
  /**
   * Inline-Level Grammar
   */

  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest$1,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    strong: {
      start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/,
      // (1) returns if starts w/ punctuation
      middle: /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
      endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation_\s]|$))/,
      // last char can't be punct, or final * must also be followed by punct (or endline)
      endUnd: /[^\s]__(?!_)(?:(?=[punctuation*\s])|$)/ // last char can't be a space, and final _ must preceed punct or \s (or endline)

    },
    em: {
      start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/,
      // (1) returns if starts w/ punctuation
      middle: /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
      endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation_\s]|$))/,
      // last char can't be punct, or final * must also be followed by punct (or endline)
      endUnd: /[^\s]_(?!_)(?:(?=[punctuation*\s])|$)/ // last char can't be a space, and final _ must preceed punct or \s (or endline)

    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest$1,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\s*punctuation])/
  }; // list of punctuation marks from common mark spec
  // without * and _ to workaround cases with double emphasis

  inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

  inline._blockSkip = '\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>';
  inline._overlapSkip = '__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*';
  inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();
  inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();
  inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
  inline.em.endAst = edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
  inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
  inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();
  inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
  inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
  inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();
  inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();
  inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();
  inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();
  /**
   * Normal Inline Grammar
   */

  inline.normal = merge$1({}, inline);
  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge$1({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit$1(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
    reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
  });
  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge$1({}, inline.normal, {
    escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
  });
  inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge$1({}, inline.gfm, {
    br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
    text: edit$1(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
  });
  var rules = {
    block: block,
    inline: inline
  };
  var defaults$2 = defaults.defaults;
  var block$1 = rules.block,
      inline$1 = rules.inline;
  var repeatString$1 = helpers.repeatString;
  /**
   * smartypants text replacement
   */

  function smartypants(text) {
    return text // em-dashes
    .replace(/---/g, "\u2014") // en-dashes
    .replace(/--/g, "\u2013") // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
    .replace(/'/g, "\u2019") // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replace(/"/g, "\u201D") // ellipses
    .replace(/\.{3}/g, "\u2026");
  }
  /**
   * mangle email addresses
   */


  function mangle(text) {
    var out = '',
        i,
        ch;
    var l = text.length;

    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);

      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  }
  /**
   * Block Lexer
   */


  var Lexer_1 = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || defaults$2;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      var rules = {
        block: block$1.normal,
        inline: inline$1.normal
      };

      if (this.options.pedantic) {
        rules.block = block$1.pedantic;
        rules.inline = inline$1.pedantic;
      } else if (this.options.gfm) {
        rules.block = block$1.gfm;

        if (this.options.breaks) {
          rules.inline = inline$1.breaks;
        } else {
          rules.inline = inline$1.gfm;
        }
      }

      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */

    /**
     * Static Lex Method
     */


    Lexer.lex = function lex(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    ;

    Lexer.lexInline = function lexInline(src, options) {
      var lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    ;

    var _proto = Lexer.prototype;

    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
      this.blockTokens(src, this.tokens, true);
      this.inline(this.tokens);
      return this.tokens;
    }
    /**
     * Lexing
     */
    ;

    _proto.blockTokens = function blockTokens(src, tokens, top) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (top === void 0) {
        top = true;
      }

      if (this.options.pedantic) {
        src = src.replace(/^ +$/gm, '');
      }

      var token, i, l, lastToken;

      while (src) {
        // newline
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);

          if (token.type) {
            tokens.push(token);
          }

          continue;
        } // code


        if (token = this.tokenizer.code(src, tokens)) {
          src = src.substring(token.raw.length);

          if (token.type) {
            tokens.push(token);
          } else {
            lastToken = tokens[tokens.length - 1];
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
          }

          continue;
        } // fences


        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // heading


        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // table no leading pipe (gfm)


        if (token = this.tokenizer.nptable(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // hr


        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // blockquote


        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.blockTokens(token.text, [], top);
          tokens.push(token);
          continue;
        } // list


        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          l = token.items.length;

          for (i = 0; i < l; i++) {
            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
          }

          tokens.push(token);
          continue;
        } // html


        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // def


        if (top && (token = this.tokenizer.def(src))) {
          src = src.substring(token.raw.length);

          if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }

          continue;
        } // table (gfm)


        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // lheading


        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // top-level paragraph


        if (top && (token = this.tokenizer.paragraph(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.text(src, tokens)) {
          src = src.substring(token.raw.length);

          if (token.type) {
            tokens.push(token);
          } else {
            lastToken = tokens[tokens.length - 1];
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _proto.inline = function inline(tokens) {
      var i, j, k, l2, row, token;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'paragraph':
          case 'text':
          case 'heading':
            {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }

          case 'table':
            {
              token.tokens = {
                header: [],
                cells: []
              }; // header

              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              } // cells


              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];

                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }

              break;
            }

          case 'blockquote':
            {
              this.inline(token.tokens);
              break;
            }

          case 'list':
            {
              l2 = token.items.length;

              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }

              break;
            }
        }
      }

      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    ;

    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (inLink === void 0) {
        inLink = false;
      }

      if (inRawBlock === void 0) {
        inRawBlock = false;
      }

      var token; // String with links masked to avoid interference with em and strong

      var maskedSrc = src;
      var match;
      var keepPrevChar, prevChar; // Mask out reflinks

      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);

        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      } // Mask out other blocks


      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }

      while (src) {
        if (!keepPrevChar) {
          prevChar = '';
        }

        keepPrevChar = false; // escape

        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // tag


        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
          src = src.substring(token.raw.length);
          inLink = token.inLink;
          inRawBlock = token.inRawBlock;
          tokens.push(token);
          continue;
        } // link


        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          }

          tokens.push(token);
          continue;
        } // reflink, nolink


        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          }

          tokens.push(token);
          continue;
        } // strong


        if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // em


        if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // code


        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // br


        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // del (gfm)


        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // autolink


        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // url (gfm)


        if (!inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
          src = src.substring(token.raw.length);
          prevChar = token.raw.slice(-1);
          keepPrevChar = true;
          tokens.push(token);
          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _createClass(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block$1,
          inline: inline$1
        };
      }
    }]);

    return Lexer;
  }();

  var defaults$3 = defaults.defaults;
  var cleanUrl$1 = helpers.cleanUrl,
      escape$1 = helpers.escape;
  /**
   * Renderer
   */

  var Renderer_1 = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || defaults$3;
    }

    var _proto = Renderer.prototype;

    _proto.code = function code(_code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];

      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang);

        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }

      _code = _code.replace(/\n$/, '') + '\n';

      if (!lang) {
        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
      }

      return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
    };

    _proto.blockquote = function blockquote(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    _proto.html = function html(_html) {
      return _html;
    };

    _proto.heading = function heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + '</h' + level + '>\n';
      } // ignore IDs


      return '<h' + level + '>' + text + '</h' + level + '>\n';
    };

    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    _proto.list = function list(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    };

    _proto.listitem = function listitem(text) {
      return '<li>' + text + '</li>\n';
    };

    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    };

    _proto.paragraph = function paragraph(text) {
      return '<p>' + text + '</p>\n';
    };

    _proto.table = function table(header, body) {
      if (body) body = '<tbody>' + body + '</tbody>';
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    };

    _proto.tablerow = function tablerow(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    } // span level renderer
    ;

    _proto.strong = function strong(text) {
      return '<strong>' + text + '</strong>';
    };

    _proto.em = function em(text) {
      return '<em>' + text + '</em>';
    };

    _proto.codespan = function codespan(text) {
      return '<code>' + text + '</code>';
    };

    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    _proto.del = function del(text) {
      return '<del>' + text + '</del>';
    };

    _proto.link = function link(href, title, text) {
      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<a href="' + escape$1(href) + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += '>' + text + '</a>';
      return out;
    };

    _proto.image = function image(href, title, text) {
      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<img src="' + href + '" alt="' + text + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    return Renderer;
  }();
  /**
   * TextRenderer
   * returns only the textual part of the token
   */


  var TextRenderer_1 = /*#__PURE__*/function () {
    function TextRenderer() {}

    var _proto = TextRenderer.prototype; // no need for block level renderers

    _proto.strong = function strong(text) {
      return text;
    };

    _proto.em = function em(text) {
      return text;
    };

    _proto.codespan = function codespan(text) {
      return text;
    };

    _proto.del = function del(text) {
      return text;
    };

    _proto.html = function html(text) {
      return text;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    _proto.link = function link(href, title, text) {
      return '' + text;
    };

    _proto.image = function image(href, title, text) {
      return '' + text;
    };

    _proto.br = function br() {
      return '';
    };

    return TextRenderer;
  }();
  /**
   * Slugger generates header id
   */


  var Slugger_1 = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }

    var _proto = Slugger.prototype;

    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim() // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
    }
    /**
     * Finds the next safe (unique) slug to use
     */
    ;

    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;

      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];

        do {
          occurenceAccumulator++;
          slug = originalSlug + '-' + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }

      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }

      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} options
     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
     */
    ;

    _proto.slug = function slug(value, options) {
      if (options === void 0) {
        options = {};
      }

      var slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    };

    return Slugger;
  }();

  var defaults$4 = defaults.defaults;
  var unescape$1 = helpers.unescape;
  /**
   * Parsing & Compiling
   */

  var Parser_1 = /*#__PURE__*/function () {
    function Parser(options) {
      this.options = options || defaults$4;
      this.options.renderer = this.options.renderer || new Renderer_1();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer_1();
      this.slugger = new Slugger_1();
    }
    /**
     * Static Parse Method
     */


    Parser.parse = function parse(tokens, options) {
      var parser = new Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    ;

    Parser.parseInline = function parseInline(tokens, options) {
      var parser = new Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    ;

    var _proto = Parser.prototype;

    _proto.parse = function parse(tokens, top) {
      if (top === void 0) {
        top = true;
      }

      var out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'space':
            {
              continue;
            }

          case 'hr':
            {
              out += this.renderer.hr();
              continue;
            }

          case 'heading':
            {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }

          case 'code':
            {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }

          case 'table':
            {
              header = ''; // header

              cell = '';
              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                  header: true,
                  align: token.align[j]
                });
              }

              header += this.renderer.tablerow(cell);
              body = '';
              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = '';
                l3 = row.length;

                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), {
                    header: false,
                    align: token.align[k]
                  });
                }

                body += this.renderer.tablerow(cell);
              }

              out += this.renderer.table(header, body);
              continue;
            }

          case 'blockquote':
            {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }

          case 'list':
            {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = '';

              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = '';

                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);

                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }

          case 'html':
            {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }

          case 'paragraph':
            {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }

          case 'text':
            {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;

              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }

              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    }
    /**
     * Parse Inline Tokens
     */
    ;

    _proto.parseInline = function parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      var out = '',
          i,
          token;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'escape':
            {
              out += renderer.text(token.text);
              break;
            }

          case 'html':
            {
              out += renderer.html(token.text);
              break;
            }

          case 'link':
            {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }

          case 'image':
            {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }

          case 'strong':
            {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'em':
            {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'codespan':
            {
              out += renderer.codespan(token.text);
              break;
            }

          case 'br':
            {
              out += renderer.br();
              break;
            }

          case 'del':
            {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'text':
            {
              out += renderer.text(token.text);
              break;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    };

    return Parser;
  }();

  var merge$2 = helpers.merge,
      checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,
      escape$2 = helpers.escape;
  var getDefaults = defaults.getDefaults,
      changeDefaults = defaults.changeDefaults,
      defaults$5 = defaults.defaults;
  /**
   * Marked
   */

  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }

    opt = merge$2({}, marked.defaults, opt || {});
    checkSanitizeDeprecation$1(opt);

    if (callback) {
      var highlight = opt.highlight;
      var tokens;

      try {
        tokens = Lexer_1.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      var done = function done(err) {
        var out;

        if (!err) {
          try {
            out = Parser_1.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    try {
      var _tokens = Lexer_1.lex(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(_tokens, opt.walkTokens);
      }

      return Parser_1.parse(_tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  }
  /**
   * Options
   */


  marked.options = marked.setOptions = function (opt) {
    merge$2(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };

  marked.getDefaults = getDefaults;
  marked.defaults = defaults$5;
  /**
   * Use Extension
   */

  marked.use = function (extension) {
    var opts = merge$2({}, extension);

    if (extension.renderer) {
      (function () {
        var renderer = marked.defaults.renderer || new Renderer_1();

        var _loop = function _loop(prop) {
          var prevRenderer = renderer[prop];

          renderer[prop] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var ret = extension.renderer[prop].apply(renderer, args);

            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.renderer) {
          _loop(prop);
        }

        opts.renderer = renderer;
      })();
    }

    if (extension.tokenizer) {
      (function () {
        var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();

        var _loop2 = function _loop2(prop) {
          var prevTokenizer = tokenizer[prop];

          tokenizer[prop] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var ret = extension.tokenizer[prop].apply(tokenizer, args);

            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.tokenizer) {
          _loop2(prop);
        }

        opts.tokenizer = tokenizer;
      })();
    }

    if (extension.walkTokens) {
      var walkTokens = marked.defaults.walkTokens;

      opts.walkTokens = function (token) {
        extension.walkTokens(token);

        if (walkTokens) {
          walkTokens(token);
        }
      };
    }

    marked.setOptions(opts);
  };
  /**
   * Run callback for every token
   */


  marked.walkTokens = function (tokens, callback) {
    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
      var token = _step.value;
      callback(token);

      switch (token.type) {
        case 'table':
          {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {
              var cell = _step2.value;
              marked.walkTokens(cell, callback);
            }

            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {
              var row = _step3.value;

              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                var _cell = _step4.value;
                marked.walkTokens(_cell, callback);
              }
            }

            break;
          }

        case 'list':
          {
            marked.walkTokens(token.items, callback);
            break;
          }

        default:
          {
            if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
      }
    }
  };
  /**
   * Parse Inline
   */


  marked.parseInline = function (src, opt) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked.parseInline(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    opt = merge$2({}, marked.defaults, opt || {});
    checkSanitizeDeprecation$1(opt);

    try {
      var tokens = Lexer_1.lexInline(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }

      return Parser_1.parseInline(tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  };
  /**
   * Expose
   */


  marked.Parser = Parser_1;
  marked.parser = Parser_1.parse;
  marked.Renderer = Renderer_1;
  marked.TextRenderer = TextRenderer_1;
  marked.Lexer = Lexer_1;
  marked.lexer = Lexer_1.lex;
  marked.Tokenizer = Tokenizer_1;
  marked.Slugger = Slugger_1;
  marked.parse = marked;
  var marked_1 = marked;
  return marked_1;
});

const renderer = new window.marked.Renderer();

renderer.code = function code(code, infostring, escaped) {
  return `<pb-code-highlight language="${infostring}" line-numbers>
        <template>${code}</template>
    </pb-code-highlight>`;
};

window.marked.setOptions({
  renderer
});

function removeIndent(input) {
  const indents = input.match(/^[^\S]*(?=\S)/gm);
  if (!indents || !indents[0].length) return input;
  indents.sort((a, b) => a.length - b.length);
  if (!indents[0].length) return input;
  return input.replace(RegExp('^' + indents[0], 'gm'), '');
}
/**
 * A component to render markdown. Content to render may either
 * 
 * 1. be specified via the `content` property
 * 2. included in the body of the element
 * 3. loaded from an external URL
 * 
 * Using option 2, if the markdown includes embedded HTML, make sure to wrap
 * the content into an `template` HTML element to prevent the browser from interpreting
 * it.
 * 
 * Using option 3, you can either specify an absolute or relative URL. Relative URLs
 * will be interpreted relative to the endpoint set by `pb-page`.
 */


class PbMarkdown extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * The markdown content to be rendered. If undefined,
       * markdown will be taken from the content of the element
       * or loaded from the specified URL.
       */
      content: {
        type: String
      },

      /**
       * An absolute or relative URL to load the markdown from.
       */
      url: {
        type: String
      }
    }, super.properties);
  }

  constructor() {
    super();
    this._url = null;
  }

  set url(value) {
    this._url = value;
    PbMarkdown.waitOnce("pb-page-ready", options => {
      this._load(options.endpoint);
    });
  }

  connectedCallback() {
    super.connectedCallback();
    this.style.display = "block";

    if (!this.content) {
      const content = document.createElement("div");

      for (let i = 0; i < this.childNodes.length; i++) {
        const node = this.childNodes[i];
        content.appendChild(document.importNode(node.content || node, true));
      }

      this.content = removeIndent(content.innerHTML);
    }

    this.subscribeTo("pb-zoom", ev => {
      this.zoom(ev.detail.direction);
    });
  }

  _load(server) {
    const url = this.toAbsoluteURL(this._url, server);
    fetch(url, {
      credentials: "same-origin"
    }).then(response => response.text()).catch(() => {
      console.error("<pb-markdown> failed to load content from %s", url.toString());
      return Promise.resolve(this.content);
    }).then(text => {
      this.content = text;
    });
  }

  createRenderRoot() {
    return this;
  }

  render() {
    if (!this.content) {
      return null;
    }

    return html$1`<div>${unsafeHTML(window.marked(this.content))}</div>`;
  }

  zoom(direction) {
    const fontSize = window.getComputedStyle(this).getPropertyValue("font-size");
    const size = parseInt(fontSize.replace(/^(\d+)px/, "$1"));

    if (direction === "in") {
      this.style.fontSize = size + 1 + "px";
    } else {
      this.style.fontSize = size - 1 + "px";
    }
  }

}
customElements.define('pb-markdown', PbMarkdown);

const _scrollObserver = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const observable = entry.target;
      observable.emitTo('pb-visible', {
        data: observable.data
      });
    }
  });
});
/**
 * An observable element, which will emit a signal `pb-visible` whenever
 * it becomes visible on the viewport. Use it to determine the current position
 * within a scrollable area.
 * 
 * @fires pb-visible - fired when the element becomes visible on the viewport
 */


class PbObservable extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * Payload data to be passed with the event
       */
      data: {
        type: String
      }
    }, super.properties);
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    if (_scrollObserver) {
      _scrollObserver.unobserve(this);
    }
  }

  firstUpdated() {
    _scrollObserver.observe(this);
  }

  render() {
    return html$1`<slot></slot>`;
  }

  static get styles() {
    return css`
            :host {
                display: inline;
            }
        `;
  }

}
customElements.define('pb-observable', PbObservable);

/**
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template$2 = html`<iron-iconset-svg name="av" size="24">
<svg><defs>
<g id="add-to-queue"><path d="M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12zm-5-7v2h-3v3h-2v-3H8v-2h3V7h2v3h3z"></path></g>
<g id="airplay"><path d="M6 22h12l-6-6zM21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4v-2H3V5h18v12h-4v2h4c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="album"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-5.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"></path></g>
<g id="art-track"><path d="M22 13h-8v-2h8v2zm0-6h-8v2h8V7zm-8 10h8v-2h-8v2zm-2-8v6c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V9c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2zm-1.5 6l-2.25-3-1.75 2.26-1.25-1.51L3.5 15h7z"></path></g>
<g id="av-timer"><path d="M11 17c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1zm0-14v4h2V5.08c3.39.49 6 3.39 6 6.92 0 3.87-3.13 7-7 7s-7-3.13-7-7c0-1.68.59-3.22 1.58-4.42L12 13l1.41-1.41-6.8-6.8v.02C4.42 6.45 3 9.05 3 12c0 4.97 4.02 9 9 9 4.97 0 9-4.03 9-9s-4.03-9-9-9h-1zm7 9c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zM6 12c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1z"></path></g>
<g id="branding-watermark"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16h-9v-6h9v6z"></path></g>
<g id="call-to-action"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3v-3h18v3z"></path></g>
<g id="closed-caption"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 7H9.5v-.5h-2v3h2V13H11v1c0 .55-.45 1-1 1H7c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1zm7 0h-1.5v-.5h-2v3h2V13H18v1c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1z"></path></g>
<g id="equalizer"><path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"></path></g>
<g id="explicit"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h4v2h-4v2h4v2H9V7h6v2z"></path></g>
<g id="fast-forward"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"></path></g>
<g id="fast-rewind"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"></path></g>
<g id="featured-play-list"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 8H3V9h9v2zm0-4H3V5h9v2z"></path></g>
<g id="featured-video"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 9H3V5h9v7z"></path></g>
<g id="fiber-dvr"><path d="M17.5 10.5h2v1h-2zm-13 0h2v3h-2zM21 3H3c-1.11 0-2 .89-2 2v14c0 1.1.89 2 2 2h18c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zM8 13.5c0 .85-.65 1.5-1.5 1.5H3V9h3.5c.85 0 1.5.65 1.5 1.5v3zm4.62 1.5h-1.5L9.37 9h1.5l1 3.43 1-3.43h1.5l-1.75 6zM21 11.5c0 .6-.4 1.15-.9 1.4L21 15h-1.5l-.85-2H17.5v2H16V9h3.5c.85 0 1.5.65 1.5 1.5v1z"></path></g>
<g id="fiber-manual-record"><circle cx="12" cy="12" r="8"></circle></g>
<g id="fiber-new"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zM8.5 15H7.3l-2.55-3.5V15H3.5V9h1.25l2.5 3.5V9H8.5v6zm5-4.74H11v1.12h2.5v1.26H11v1.11h2.5V15h-4V9h4v1.26zm7 3.74c0 .55-.45 1-1 1h-4c-.55 0-1-.45-1-1V9h1.25v4.51h1.13V9.99h1.25v3.51h1.12V9h1.25v5z"></path></g>
<g id="fiber-pin"><path d="M5.5 10.5h2v1h-2zM20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zM9 11.5c0 .85-.65 1.5-1.5 1.5h-2v2H4V9h3.5c.85 0 1.5.65 1.5 1.5v1zm3.5 3.5H11V9h1.5v6zm7.5 0h-1.2l-2.55-3.5V15H15V9h1.25l2.5 3.5V9H20v6z"></path></g>
<g id="fiber-smart-record"><g><circle cx="9" cy="12" r="8"></circle><path d="M17 4.26v2.09c2.33.82 4 3.04 4 5.65s-1.67 4.83-4 5.65v2.09c3.45-.89 6-4.01 6-7.74s-2.55-6.85-6-7.74z"></path></g></g>
<g id="forward-10"><path d="M4 13c0 4.4 3.6 8 8 8s8-3.6 8-8h-2c0 3.3-2.7 6-6 6s-6-2.7-6-6 2.7-6 6-6v4l5-5-5-5v4c-4.4 0-8 3.6-8 8zm6.8 3H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1.3.2.5.3.2.3.3.6.1.5.1.8v.7zm-.8-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z"></path></g>
<g id="forward-30"><path d="M9.6 13.5h.4c.2 0 .4-.1.5-.2s.2-.2.2-.4v-.2s-.1-.1-.1-.2-.1-.1-.2-.1h-.5s-.1.1-.2.1-.1.1-.1.2v.2h-1c0-.2 0-.3.1-.5s.2-.3.3-.4.3-.2.4-.2.4-.1.5-.1c.2 0 .4 0 .6.1s.3.1.5.2.2.2.3.4.1.3.1.5v.3s-.1.2-.1.3-.1.2-.2.2-.2.1-.3.2c.2.1.4.2.5.4s.2.4.2.6c0 .2 0 .4-.1.5s-.2.3-.3.4-.3.2-.5.2-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.4-.1-.6h.8v.2s.1.1.1.2.1.1.2.1h.5s.1-.1.2-.1.1-.1.1-.2v-.5s-.1-.1-.1-.2-.1-.1-.2-.1h-.6v-.7zm5.7.7c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1.3.2.5.3.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5zM4 13c0 4.4 3.6 8 8 8s8-3.6 8-8h-2c0 3.3-2.7 6-6 6s-6-2.7-6-6 2.7-6 6-6v4l5-5-5-5v4c-4.4 0-8 3.6-8 8z"></path></g>
<g id="forward-5"><path d="M4 13c0 4.4 3.6 8 8 8s8-3.6 8-8h-2c0 3.3-2.7 6-6 6s-6-2.7-6-6 2.7-6 6-6v4l5-5-5-5v4c-4.4 0-8 3.6-8 8zm6.7.9l.2-2.2h2.4v.7h-1.7l-.1.9s.1 0 .1-.1.1 0 .1-.1.1 0 .2 0h.2c.2 0 .4 0 .5.1s.3.2.4.3.2.3.3.5.1.4.1.6c0 .2 0 .4-.1.5s-.1.3-.3.5-.3.2-.5.3-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.3-.1-.5h.8c0 .2.1.3.2.4s.2.1.4.1c.1 0 .2 0 .3-.1l.2-.2s.1-.2.1-.3v-.6l-.1-.2-.2-.2s-.2-.1-.3-.1h-.2s-.1 0-.2.1-.1 0-.1.1-.1.1-.1.1h-.6z"></path></g>
<g id="games"><path d="M15 7.5V2H9v5.5l3 3 3-3zM7.5 9H2v6h5.5l3-3-3-3zM9 16.5V22h6v-5.5l-3-3-3 3zM16.5 9l-3 3 3 3H22V9h-5.5z"></path></g>
<g id="hd"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path></g>
<g id="hearing"><path d="M17 20c-.29 0-.56-.06-.76-.15-.71-.37-1.21-.88-1.71-2.38-.51-1.56-1.47-2.29-2.39-3-.79-.61-1.61-1.24-2.32-2.53C9.29 10.98 9 9.93 9 9c0-2.8 2.2-5 5-5s5 2.2 5 5h2c0-3.93-3.07-7-7-7S7 5.07 7 9c0 1.26.38 2.65 1.07 3.9.91 1.65 1.98 2.48 2.85 3.15.81.62 1.39 1.07 1.71 2.05.6 1.82 1.37 2.84 2.73 3.55.51.23 1.07.35 1.64.35 2.21 0 4-1.79 4-4h-2c0 1.1-.9 2-2 2zM7.64 2.64L6.22 1.22C4.23 3.21 3 5.96 3 9s1.23 5.79 3.22 7.78l1.41-1.41C6.01 13.74 5 11.49 5 9s1.01-4.74 2.64-6.36zM11.5 9c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5-2.5 1.12-2.5 2.5z"></path></g>
<g id="high-quality"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 11H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm7-1c0 .55-.45 1-1 1h-.75v1.5h-1.5V15H14c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v4zm-3.5-.5h2v-3h-2v3z"></path></g>
<g id="library-add"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z"></path></g>
<g id="library-books"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"></path></g>
<g id="library-music"><path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 5h-3v5.5c0 1.38-1.12 2.5-2.5 2.5S10 13.88 10 12.5s1.12-2.5 2.5-2.5c.57 0 1.08.19 1.5.51V5h4v2zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6z"></path></g>
<g id="loop"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"></path></g>
<g id="mic"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path></g>
<g id="mic-none"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1.2-9.1c0-.66.54-1.2 1.2-1.2.66 0 1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2-.66 0-1.2-.54-1.2-1.2V4.9zm6.5 6.1c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"></path></g>
<g id="mic-off"><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z"></path></g>
<g id="movie"><path d="M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z"></path></g>
<g id="music-video"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM8 15c0-1.66 1.34-3 3-3 .35 0 .69.07 1 .18V6h5v2h-3v7.03c-.02 1.64-1.35 2.97-3 2.97-1.66 0-3-1.34-3-3z"></path></g>
<g id="new-releases"><path d="M23 12l-2.44-2.78.34-3.68-3.61-.82-1.89-3.18L12 3 8.6 1.54 6.71 4.72l-3.61.81.34 3.68L1 12l2.44 2.78-.34 3.69 3.61.82 1.89 3.18L12 21l3.4 1.46 1.89-3.18 3.61-.82-.34-3.68L23 12zm-10 5h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
<g id="not-interested"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"></path></g>
<g id="note"><path d="M22 10l-6-6H4c-1.1 0-2 .9-2 2v12.01c0 1.1.9 1.99 2 1.99l16-.01c1.1 0 2-.89 2-1.99v-8zm-7-4.5l5.5 5.5H15V5.5z"></path></g>
<g id="pause"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></g>
<g id="pause-circle-filled"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"></path></g>
<g id="pause-circle-outline"><path d="M9 16h2V8H9v8zm3-14C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm1-4h2V8h-2v8z"></path></g>
<g id="play-arrow"><path d="M8 5v14l11-7z"></path></g>
<g id="play-circle-filled"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z"></path></g>
<g id="play-circle-outline"><path d="M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="playlist-add"><path d="M14 10H2v2h12v-2zm0-4H2v2h12V6zm4 8v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM2 16h8v-2H2v2z"></path></g>
<g id="playlist-add-check"><path d="M14 10H2v2h12v-2zm0-4H2v2h12V6zM2 16h8v-2H2v2zm19.5-4.5L23 13l-6.99 7-4.51-4.5L13 14l3.01 3 5.49-5.5z"></path></g>
<g id="playlist-play"><path d="M19 9H2v2h17V9zm0-4H2v2h17V5zM2 15h13v-2H2v2zm15-2v6l5-3-5-3z"></path></g>
<g id="queue"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z"></path></g>
<g id="queue-music"><path d="M15 6H3v2h12V6zm0 4H3v2h12v-2zM3 16h8v-2H3v2zM17 6v8.18c-.31-.11-.65-.18-1-.18-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3V8h3V6h-5z"></path></g>
<g id="queue-play-next"><path d="M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h2v-2H3V5h18v8h2V5c0-1.11-.9-2-2-2zm-8 7V7h-2v3H8v2h3v3h2v-3h3v-2h-3zm11 8l-4.5 4.5L18 21l3-3-3-3 1.5-1.5L24 18z"></path></g>
<g id="radio"><path d="M3.24 6.15C2.51 6.43 2 7.17 2 8v12c0 1.1.89 2 2 2h16c1.11 0 2-.9 2-2V8c0-1.11-.89-2-2-2H8.3l8.26-3.34L15.88 1 3.24 6.15zM7 20c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm13-8h-2v-2h-2v2H4V8h16v4z"></path></g>
<g id="recent-actors"><path d="M21 5v14h2V5h-2zm-4 14h2V5h-2v14zM14 5H2c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM8 7.75c1.24 0 2.25 1.01 2.25 2.25S9.24 12.25 8 12.25 5.75 11.24 5.75 10 6.76 7.75 8 7.75zM12.5 17h-9v-.75c0-1.5 3-2.25 4.5-2.25s4.5.75 4.5 2.25V17z"></path></g>
<g id="remove-from-queue"><path d="M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12zm-5-7v2H8v-2h8z"></path></g>
<g id="repeat"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"></path></g>
<g id="repeat-one"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v4H13z"></path></g>
<g id="replay"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"></path></g>
<g id="replay-10"><path d="M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.1 11H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1c.2.1.3.2.5.3s.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z"></path></g>
<g id="replay-30"><path d="M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-2.4 8.5h.4c.2 0 .4-.1.5-.2s.2-.2.2-.4v-.2s-.1-.1-.1-.2-.1-.1-.2-.1h-.5s-.1.1-.2.1-.1.1-.1.2v.2h-1c0-.2 0-.3.1-.5s.2-.3.3-.4.3-.2.4-.2.4-.1.5-.1c.2 0 .4 0 .6.1s.3.1.5.2.2.2.3.4.1.3.1.5v.3s-.1.2-.1.3-.1.2-.2.2-.2.1-.3.2c.2.1.4.2.5.4s.2.4.2.6c0 .2 0 .4-.1.5s-.2.3-.3.4-.3.2-.5.2-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.4-.1-.6h.8v.2s.1.1.1.2.1.1.2.1h.5s.1-.1.2-.1.1-.1.1-.2v-.5s-.1-.1-.1-.2-.1-.1-.2-.1h-.6v-.7zm5.7.7c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1.3.2.5.3.2.3.3.6.1.5.1.8v.7zm-.8-.8v-.5c0-.1-.1-.2-.1-.3s-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z"></path></g>
<g id="replay-5"><path d="M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.3 8.9l.2-2.2h2.4v.7h-1.7l-.1.9s.1 0 .1-.1.1 0 .1-.1.1 0 .2 0h.2c.2 0 .4 0 .5.1s.3.2.4.3.2.3.3.5.1.4.1.6c0 .2 0 .4-.1.5s-.1.3-.3.5-.3.2-.4.3-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.3-.1-.5h.8c0 .2.1.3.2.4s.2.1.4.1c.1 0 .2 0 .3-.1l.2-.2s.1-.2.1-.3v-.6l-.1-.2-.2-.2s-.2-.1-.3-.1h-.2s-.1 0-.2.1-.1 0-.1.1-.1.1-.1.1h-.7z"></path></g>
<g id="shuffle"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"></path></g>
<g id="skip-next"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path></g>
<g id="skip-previous"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></g>
<g id="slow-motion-video"><path d="M13.05 9.79L10 7.5v9l3.05-2.29L16 12zm0 0L10 7.5v9l3.05-2.29L16 12zm0 0L10 7.5v9l3.05-2.29L16 12zM11 4.07V2.05c-2.01.2-3.84 1-5.32 2.21L7.1 5.69c1.11-.86 2.44-1.44 3.9-1.62zM5.69 7.1L4.26 5.68C3.05 7.16 2.25 8.99 2.05 11h2.02c.18-1.46.76-2.79 1.62-3.9zM4.07 13H2.05c.2 2.01 1 3.84 2.21 5.32l1.43-1.43c-.86-1.1-1.44-2.43-1.62-3.89zm1.61 6.74C7.16 20.95 9 21.75 11 21.95v-2.02c-1.46-.18-2.79-.76-3.9-1.62l-1.42 1.43zM22 12c0 5.16-3.92 9.42-8.95 9.95v-2.02C16.97 19.41 20 16.05 20 12s-3.03-7.41-6.95-7.93V2.05C18.08 2.58 22 6.84 22 12z"></path></g>
<g id="snooze"><path d="M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-3-9h3.63L9 15.2V17h6v-2h-3.63L15 10.8V9H9v2z"></path></g>
<g id="sort-by-alpha"><path d="M14.94 4.66h-4.72l2.36-2.36zm-4.69 14.71h4.66l-2.33 2.33zM6.1 6.27L1.6 17.73h1.84l.92-2.45h5.11l.92 2.45h1.84L7.74 6.27H6.1zm-1.13 7.37l1.94-5.18 1.94 5.18H4.97zm10.76 2.5h6.12v1.59h-8.53v-1.29l5.92-8.56h-5.88v-1.6h8.3v1.26l-5.93 8.6z"></path></g>
<g id="stop"><path d="M6 6h12v12H6z"></path></g>
<g id="subscriptions"><path d="M20 8H4V6h16v2zm-2-6H6v2h12V2zm4 10v8c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2v-8c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2zm-6 4l-6-3.27v6.53L16 16z"></path></g>
<g id="subtitles"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM4 12h4v2H4v-2zm10 6H4v-2h10v2zm6 0h-4v-2h4v2zm0-4H10v-2h10v2z"></path></g>
<g id="surround-sound"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7.76 16.24l-1.41 1.41C4.78 16.1 4 14.05 4 12c0-2.05.78-4.1 2.34-5.66l1.41 1.41C6.59 8.93 6 10.46 6 12s.59 3.07 1.76 4.24zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm5.66 1.66l-1.41-1.41C17.41 15.07 18 13.54 18 12s-.59-3.07-1.76-4.24l1.41-1.41C19.22 7.9 20 9.95 20 12c0 2.05-.78 4.1-2.34 5.66zM12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="video-call"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4zM14 13h-3v3H9v-3H6v-2h3V8h2v3h3v2z"></path></g>
<g id="video-label"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 13H3V5h18v11z"></path></g>
<g id="video-library"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"></path></g>
<g id="videocam"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"></path></g>
<g id="videocam-off"><path d="M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z"></path></g>
<g id="volume-down"><path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"></path></g>
<g id="volume-mute"><path d="M7 9v6h4l5 5V4l-5 5H7z"></path></g>
<g id="volume-off"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></g>
<g id="volume-up"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></g>
<g id="web"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"></path></g>
<g id="web-asset"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm0 14H5V8h14v10z"></path></g>
</defs></svg>
</iron-iconset-svg>`;
document.head.appendChild(template$2.content);

/** Import external script dynamically */

function _import$1(name, location) {
  window.ESGlobalBridge.requestAvailability();
  return new Promise(resolve => {
    window.ESGlobalBridge.instance.load(name, location);
    window.addEventListener(`es-bridge-${name}-loaded`, () => resolve(), {
      once: true
    });
  });
}
/**
 * A viewer and player for MEI musical notation based on [Verovio](https://www.verovio.org/).
 * Supports optional MIDI playback using [web-midi-player](https://midi.yvesgurcan.com/).
 * Both libraries are loaded dynamically when the component is used the first time.
 * 
 * Viewing options to be selected by the user can be defined via nested `pb-option` elements:
 * 
 * ```html
 * <pb-mei id="viewer" player url="http://www.marenzio.org/mei/M-06-5/M_06_5_01_S_io_parto_i_moro_e_pur_partir_conviene.mei" 
 *         footer="none">
 *    <pb-option name="appXPath" on="./rdg[contains(@label, 'original')]" off="">Original Clefs</pb-option>
 *  </pb-mei>
 * 
 * @prop {"auto" | "encoded" | "none" | "always"} footer - Control footer layout
 * @prop {"auto" | "encoded" | "none"} header - Control footer layout
 * @prop {"auto" | "none" | "line" | "encoded" | "smart"} breaks - Define page and system breaks layout (default: "auto")
 */


class PbMei extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * URL of the MEI file to load. A relative URL would be resolved
       * relative to the TEI Publisher endpoint.
       */
      url: {
        type: String
      },

      /**
       * Set to enable MIDI player
       */
      player: {
        type: Boolean
      },
      header: {
        type: String
      },
      footer: {
        type: String
      },
      breaks: {
        type: String
      },

      /**
       * Set the XPath query for selecting <app> child elements, for example: "./rdg[contains(@source, 'source-id')]";
       * by default the <lem> or the first <rdg> is selected
       */
      appXPath: {
        type: String,
        attribute: 'app-xpath'
      },

      /**
       * Set the xPath query for selecting <choice> child elements, for example: "./orig"; by default the first child is selected
       */
      choiceXPath: {
        type: String,
        attribute: 'choice-xpath'
      },

      /**
       * Set the xPath query for selecting the <mdiv> to be rendered; only one <mdiv> can be rendered (default: "")
       */
      mdivXPath: {
        type: String,
        attribute: 'mdiv-xpath'
      },

      /**
       * Set the xPath query for selecting <subst> child elements, for example: "./del"; by default the first child is selected
       */
      substXPath: {
        type: String,
        attribute: 'subst-xpath'
      },
      _svg: {
        type: String
      }
    }, super.properties);
  }

  constructor() {
    super();
    this._data = null;
    this._svg = null;
    this._pages = 0;
    this._page = 0;
    this._midiPlayer = null;
    this._verovio = null;
    this.footer = 'auto';
    this.header = 'auto';
    this.breaks = 'auto';
    this.appXPath = null;
    this.choiceXPath = null;
    this.mdivXPath = null;
    this.substXPath = null;
    this._options = [];
  }

  connectedCallback() {
    super.connectedCallback();
    this.querySelectorAll('pb-option').forEach(option => {
      this._options.push({
        name: option.getAttribute('name'),
        on: option.getAttribute('on'),
        off: option.getAttribute('off'),
        label: option.innerHTML
      });
    });
  }

  firstUpdated() {
    super.firstUpdated();

    if (this.player) {
      _import$1("midiPlayer", 'https://cdn.jsdelivr.net/npm/web-midi-player@latest/index.js').then(() => {
        const {
          'web-midi-player': {
            default: MidiPlayer
          }
        } = window;
        this._midiPlayer = new MidiPlayer();
      });
    }

    _import$1("verovio", 'https://www.verovio.org/javascript/latest/verovio-toolkit.js').then(() => {
      this._verovio = new window.verovio.toolkit();
      PbMei.waitOnce('pb-page-ready', () => {
        this.load();
      });
    });
  }

  update(changedProps) {
    super.update(changedProps);

    if (changedProps.get('url')) {
      this.load();
    } else if ((changedProps.has('appXPath') || changedProps.has('choiceXPath') || changedProps.has('mdivXPath') || changedProps.has('substXPath')) && this._verovio) {
      this._verovio.setOptions(this._getOptions());

      this._verovio.loadData(this._data);

      this.showPage();
    }
  }

  load() {
    const link = this.toAbsoluteURL(this.url);
    fetch(link).then(response => response.text()).then(async data => {
      this._data = data;

      this._verovio.setOptions(this._getOptions());

      this._verovio.loadData(this._data);

      this._pages = this._verovio.getPageCount();
      this._page = 1;
      console.log('<pb-mei> Loaded %d pages', this._pages);
      this.showPage();
    });
  }

  showPage() {
    this._svg = this._verovio.renderToSVG(this._page, {});
  }

  async play() {
    const button = this.shadowRoot.getElementById('play');

    if (!button.active) {
      this._midiPlayer.stop();

      button.icon = 'av:play-arrow';
    } else {
      button.icon = 'av:stop';

      if (this._midiPaused) {
        this._midiPaused = false;

        this._midiPlayer.resume();
      } else {
        this._verovio.loadData(this._data);

        const mdata = this._verovio.renderToMIDI();

        const raw = window.atob(mdata);
        const rawLength = raw.length;
        const array = new Uint8Array(new ArrayBuffer(rawLength));

        for (let i = 0; i < rawLength; i += 1) {
          array[i] = raw.charCodeAt(i);
        }

        this._midiPlayer.play({
          arrayBuffer: array
        });
      }
    }
  }

  pause() {
    const button = this.shadowRoot.getElementById('play');

    if (button.active) {
      this._midiPaused = this._midiPlayer.pause();

      if (this._midiPaused) {
        button.icon = 'av:play-arrow';
        button.active = false;
      }
    }
  }

  render() {
    return html$1`
            <div id="toolbar">
                <div class="${this._pages === 1 ? 'hidden' : ''}">
                    <paper-icon-button id="pageLeft" icon="icons:chevron-left" @click="${this._previousPage}"
                        ?disabled="${this._page === 1}"></paper-icon-button>
                    <paper-icon-button id="pageRight" icon="icons:chevron-right" @click="${this._nextPage}"
                        ?disabled="${this._page === this._pages}"></paper-icon-button>
                </div>
                ${this._renderPlayer()}
                <div>${this._renderOptions()}</div>
            </div>
            ${this._svg ? html$1`<div id="output">${unsafeHTML(this._svg)}</div>` : html$1`<div id="output">${translate('dialogs.loading')}</div>`}
        `;
  }

  _renderPlayer() {
    if (this.player) {
      return html$1`
                <div id="player">
                    <paper-icon-button id="play" icon="av:play-arrow" toggles @click="${this.play}"></paper-icon-button>
                    <paper-icon-button icon="av:pause" @click="${this.pause}"></paper-icon-button>
                </div>
            `;
    }

    return null;
  }

  _renderOptions() {
    return this._options.map(option => html$1`<paper-checkbox @change="${ev => this._setOption(option, ev.target.checked)}">${option.label}</paper-checkbox>`);
  }

  _setOption(option, checked) {
    let value;

    if (checked) {
      value = option.on && option.on.length > 0 ? option.on : null;
    } else {
      value = option.off && option.off.length > 0 ? option.off : null;
    }

    this[option.name] = value;
  }

  _nextPage(ev) {
    ev.preventDefault();

    if (this._page < this._pages) {
      this._page += 1;
      this.showPage();
    }
  }

  _previousPage(ev) {
    ev.preventDefault();

    if (this._page > 1) {
      this._page -= 1;
      this.showPage();
    }
  }

  _getOptions() {
    const options = {
      // svg content should scale with the width of the component
      svgViewBox: true,
      adjustPageHeight: true,
      footer: this.footer,
      header: this.header,
      breaks: this.breaks,
      appXPathQuery: [this.appXPath],
      substXPathQuery: [this.substXPath],
      choiceXPathQuery: [this.choiceXPath]
    };

    if (this.mdivXPath) {
      options.mdivXPathQuery = this.mdivXPath;
    }

    return options;
  }

  static get styles() {
    return css`
            :host {
                display: grid;
                grid-template-rows: auto 1fr;
            }

            #toolbar {
                display: flex;
                align-items: center;
            }

            #toolbar div {
                margin-right: 30px;
            }

            #toolbar div:last-child {
                margin-right: 0;
            }

            #output {
                width: 100%;
                overflow: auto;
            }

            .hidden {
                display: none;
            }
        `;
  }

}
customElements.define('pb-mei', PbMei);

function _query(datasource, query) {
  const queryResult = [];
  datasource.forEach(item => {
    let objText, objValue;

    if (typeof item === 'object') {
      objText = item.text;
      objValue = item.value;
    } else {
      objText = item.toString();
      objValue = objText;
    }

    if (objText.toLowerCase().indexOf(query) > -1) {
      // NOTE: the structure of the result object matches with the current template. For custom templates, you
      // might need to return more data
      const resultItem = {};
      resultItem.text = objText;
      resultItem.value = objValue;
      queryResult.push(resultItem);
    }
  });
  return queryResult;
}
/**
 * Provides an input with attached autocomplete. The autocomplete suggestions can be read
 * either from a static list or a remote endpoint to which the current user input is sent.
 * 
 * @cssprop --pb-search-label-color - Color of the label and underline
 * @cssprop --pb-search-input-color - Text color for input field
 * @cssprop --pb-search-focus-color - Color for label and underline if input has focus
 * @cssprop --pb-search-suggestions-color - Color for the labels shown in the suggestions dropdown
 * @cssprop --pb-search-suggestions-background - Background for the suggestions dropdown
 * @slot - default unnamed slot
 */


class PbAutocomplete extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * Name of the form field which will be submitted
       */
      name: {
        type: String
      },

      /**
       * Value of the form field which will be submitted
       */
      value: {
        type: String
      },

      /**
       * Placeholder to display if field is empty
       */
      placeholder: {
        type: String,
        attribute: 'placeholder'
      },

      /**
       * Optional URL to query for suggestions. If relative, it is interpreted
       * relative to the endpoint defined on a surrounding `pb-page`.
       * 
       * Upon autocomplete, the current input by the user will be sent with a query parameter
       * `query`. The name/values of form controls nested within `pb-autocomplete` will also be
       * appended to the request as parameters. This allows the server side code to distinguish
       * different states.
       */
      source: {
        type: String
      },

      /**
       * If set, the entire list of possible suggestions will be preloaded upon initialization of the
       * component.
       */
      preload: {
        type: Boolean
      },

      /**
       * A static list of suggestions. Use instead of `source`. May either be a flat array of strings,
       * or an array containing objects of the form `{"text": "", "value": ""}, in which case "value" denotes
       * the value to be used when the enclosing form is submitted, and "text" is the label to be displayed.
       */
      suggestions: {
        type: Array
      },

      /**
       * By default suggestions are filtered by prefix, i.e. only suggestions starting with the prefix
       * typed by the user are shown. Set this property to true to search for the user-provided string
       * anywhere within the suggestion text.
       */
      substring: {
        type: Boolean
      },

      /**
       * An icon to display next to the input.
       */
      icon: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.placeholder = 'search.placeholder';
    this.suggestions = [];
    this.lastSelected = null;
    this.preload = false;
    this.substring = false;
    this._hiddenInput = null;
    this._initialized = false;
  }

  connectedCallback() {
    super.connectedCallback();
  }

  firstUpdated() {
    const inIronForm = this.closest('iron-form,pb-search,pb-custom-form');

    if (!inIronForm) {
      this._hiddenInput = document.createElement('input');
      this._hiddenInput.type = 'hidden';
      this._hiddenInput.name = this.name;
      this.appendChild(this._hiddenInput);
    }

    const autocomplete = this.shadowRoot.getElementById('autocomplete');
    autocomplete.addEventListener('autocomplete-change', this._autocomplete.bind(this));

    if (this.preload && this.source) {
      if (this.substring) {
        autocomplete.queryFn = _query;
      }

      PbAutocomplete.waitOnce('pb-page-ready', () => {
        this._sendRequest();
      });
    } else if (this.value) {
      if (this.source) {
        PbAutocomplete.waitOnce('pb-page-ready', () => {
          //console.log('send autocomplete request for remote source %s on value %s', this.source, this.value);
          this._sendRequest(this.value);
        });
      } else {
        const input = this.shadowRoot.getElementById('search');
        const value = this.suggestions.find(suggestion => {
          if (suggestion.text) {
            return suggestion.value === this.value;
          }

          return suggestion === this.value;
        });

        if (value) {
          input.value = value.text || value;

          if (this._hiddenInput) {
            this._hiddenInput.value = value.value || value;
          }
        }

        if (this._hiddenInput) {
          this._hiddenInput.value = this.value;
        }
      }
    }
  }

  render() {
    return html$1`
            <custom-style>
                <style>
                    :host {
                        --suggestions-item: {
                            color: var(--pb-search-suggestions-color, black);
                        };
                        --suggestions-wrapper: {
                            background: var(--pb-search-suggestions-background, white);
                        };
                    }
                </style>
            </custom-style>
            <slot></slot>
            <paper-input id="search" type="search" name="query" @keyup="${this._setInput}" label="${translate(this.placeholder)}"
                always-float-label>
                ${this.icon ? html$1`<iron-icon icon="${this.icon}" slot="prefix"></iron-icon>` : null}
            </paper-input>
            <paper-autocomplete-suggestions id="autocomplete" for="search" .source="${this.suggestions}" ?remote-source="${!this.preload && this.source}"
                @autocomplete-selected="${this._autocompleteSelected}"></paper-autocomplete-suggestions>
          
        <iron-ajax
            id="autocompleteLoader"
            verbose
            handle-as="json"
            method="get"
            with-credentials
            @response="${this._updateSuggestions}"></iron-ajax>

        
    `;
  }

  static get styles() {
    return css`
            :host {
                --paper-input-container-color: var(--pb-search-label-color, var(--paper-grey-500, #303030));
                --paper-input-container-input-color: var(--pb-search-input-color, var(--pb-color-primary, #000000));
                --paper-input-container-focus-color: var(--pb-search-focus-color, var(--paper-grey-500, #303030));

                display: flex;
                align-items: center;
            }

            ::slotted {
                display: block;
                margin-left: 10px;
            }
        `;
  }

  _autocomplete(ev) {
    const search = this.shadowRoot.getElementById('search');

    this._sendRequest(search.value);
  }

  _sendRequest(query) {
    const loader = this.shadowRoot.getElementById('autocompleteLoader');
    loader.url = this.toAbsoluteURL(this.source);

    const params = this._getParameters();

    params['query'] = query;
    loader.params = params; //console.log('send request for %s with %o', loaderId, params);

    loader.generateRequest();
  }

  _updateSuggestions() {
    const loader = this.shadowRoot.getElementById('autocompleteLoader');

    if (this._initialized) {
      const autocomplete = this.shadowRoot.getElementById('autocomplete');

      if (loader.lastResponse) {
        this.suggestions = loader.lastResponse;
        autocomplete.suggestions(this.suggestions);
      }
    } else if (loader.lastResponse) {
      const suggestions = loader.lastResponse;
      const input = this.shadowRoot.getElementById('search');
      const value = suggestions.find(suggestion => {
        if (suggestion.text) {
          return suggestion.value === this.value;
        }

        return suggestion === this.value;
      });

      if (value) {
        input.value = value.text || value;

        if (this._hiddenInput) {
          this._hiddenInput.value = value.value || value;
        }
      } else if (this._hiddenInput) {
        this._hiddenInput.value = this.value;
      }

      if (this.preload) {
        this.suggestions = suggestions;
      }
    }

    this._initialized = true;
  }

  _getParameters() {
    const params = {};
    const inputs = this.querySelectorAll('[name]');
    inputs.forEach(input => {
      params[input.name] = input.value;
    });
    return params;
  }

  _autocompleteSelected(ev) {
    this.lastSelected = ev.detail.text;
    const input = this.shadowRoot.getElementById('search');
    input.value = ev.detail.text;
    this.value = ev.detail.value;

    if (this._hiddenInput) {
      this._hiddenInput.value = this.value;
    }

    this.emitTo('pb-autocomplete-selected', {
      text: ev.detail.text,
      value: ev.detail.value
    });
  }

  _setInput(ev) {
    const input = this.shadowRoot.getElementById('search');
    this.value = input.value;

    if (this._hiddenInput) {
      this._hiddenInput.value = this.value;
    }

    if (ev.keyCode === 13) {
      const entry = this.suggestions.find(suggestion => {
        if (suggestion.text) {
          return suggestion.value === this.value;
        }

        return suggestion === this.value;
      });

      if (!entry) {
        return;
      }

      if (entry.value) {
        this.emitTo('pb-autocomplete-selected', {
          text: entry.text,
          value: entry.value
        });
      } else {
        this.emitTo('pb-autocomplete-selected', {
          text: entry,
          value: entry
        });
      }
    }
  }

}
customElements.define('pb-autocomplete', PbAutocomplete);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
`<iron-label>` provides a version of the `<label>` element that works with
Custom Elements as well as native elements.

All text in the `iron-label` will be applied to the target element as a
screen-reader accessible description.

There are three ways to use `iron-label` to target an element:

1. place an element inside iron-label and some text:

        <iron-label>
          Label for the Button
          <paper-button>button</paper-button>
        </iron-label>

2. place some elements inside iron-label and target one with the
`iron-label-target` attribute. The other elements will provide the label for
that element Note: This is not necessary if the element you want to label is the
first element child of iron-label:

        <iron-label>
          <span>Label for the Button</span>
          <paper-button iron-label-target>button</paper-button>
        </iron-label>

        <iron-label>
          <paper-button>button</paper-button>
          <span>Label for the Button</span>
        </iron-label>

3. Set the `for` attribute on the `iron-label` element with the id of the target
element in the same document or ShadowRoot:

        <iron-label for="foo">
          Context for the button with the "foo" class"
        </iron-label>
        <paper-button id="foo">Far away button</paper-button>

All taps on the `iron-label` will be forwarded to the "target" element.

@group Iron Elements
@element iron-label
@demo demo/index.html
@homepage polymer.github.io
*/

const IronLabel = Polymer({
  is: 'iron-label',
  listeners: {
    'tap': '_tapHandler'
  },
  properties: {
    /**
     * An ID reference to another element that needs to be
     * labelled by this `iron-label` element.
     */
    for: {
      type: String,
      value: '',
      reflectToAttribute: true,
      observer: '_forChanged'
    },

    /**
     * @type {Element}
     */
    _forElement: Object
  },
  attached: function () {
    this._forChanged();
  },
  ready: function () {
    this._generateLabelId();
  },
  // generate a unique id for this element
  _generateLabelId: function () {
    if (!this.id) {
      var id = 'iron-label-' + IronLabel._labelNumber++;
      dom(this).setAttribute('id', id);
    }
  },
  _findTarget: function () {
    if (this.for) {
      // external target
      var scope = dom(this).getOwnerRoot();
      return dom(scope).querySelector('#' + this.for);
    } else {
      // explicit internal target
      var el = dom(this).querySelector('[iron-label-target]');

      if (!el) {
        // implicit internal target
        el = dom(this).firstElementChild;
      }

      return el;
    }
  },
  _tapHandler: function (ev) {
    if (!this._forElement) {
      return;
    }

    var target = dom(ev).localTarget;

    if (target === this._forElement) {
      return;
    }

    this._forElement.focus();

    this._forElement.click();
  },
  _applyLabelledBy: function () {
    if (this._forElement) {
      dom(this._forElement).setAttribute('aria-labelledby', this.id);
    }
  },
  _forChanged: function () {
    if (this._forElement) {
      dom(this._forElement).removeAttribute('aria-labelledby');
    }

    this._forElement = this._findTarget();

    this._applyLabelledBy();
  }
}); // global counter for unique label ids

IronLabel._labelNumber = 0;

/**
 * Replacement for an HTML select element with additional features:
 *
 * 1. item list can be loaded from remote endpoint via AJAX
 * 2. may contain additional nested form in the slot
 *    named `subform`, whose values will be sent with the AJAX request
 *
 * @slot - a static list of paper-item to be shown as options. each paper-item should have a value attribute
 * @slot subform - additional form controls
 * @csspart label - the label shown above a multi-selection box (does not apply to single-selection)
 */

class PbSelect extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * Label to display above the select or inside if nothing is selected
       */
      label: {
        type: String
      },

      /**
       * Initial value to select. If not set, no item will be selected
       */
      value: {
        type: String,
        reflect: true
      },

      /**
       * If `multi` is set, specify initial values via this property
       * instead of using `value`
       */
      values: {
        type: Array,
        reflect: true
      },

      /**
       * name used when submitted inside a form
       */
      name: {
        type: String
      },

      /**
       * Optional URL to query for suggestions. If relative, it is interpreted
       * relative to the endpoint defined on a surrounding `pb-page`.
       */
      source: {
        type: String
      },
      multi: {
        type: Boolean
      },
      _items: {
        type: Array
      },
      _selected: {
        type: Array
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.value = null;
    this.values = [];
    this._items = [];
    this._selected = [];
    this._inIronForm = false;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-i18n-update', this._refresh.bind(this)); // in multi-select mode, copy any value set via 'value' to 'values'

    if (this.multi) {
      if (this.values.length === 0 && this.value) {
        this.values = [this.value];
      } // delete this.value so it is not picked up by iron-form


      this.value = undefined;
    }
  }

  firstUpdated() {
    super.firstUpdated();
    this._inIronForm = this.closest('iron-form, pb-search,pb-custom-form');
    const slot = this.shadowRoot.querySelector('[name="subform"]');

    if (slot) {
      slot.assignedNodes().forEach(node => {
        if (this.name) {
          node.addEventListener('change', this._loadRemote.bind(this));
        }

        const inputs = node.querySelectorAll('[name]');
        inputs.forEach(input => {
          input.addEventListener('change', this._loadRemote.bind(this));
        });
      });
    }

    PbSelect.waitOnce('pb-page-ready', () => {
      this._loadRemote();
    });
  }

  _refresh() {
    const listbox = this.shadowRoot.getElementById('list');

    if (listbox) {
      setTimeout(() => {
        const old = listbox.selected;
        listbox.selected = undefined;
        listbox.selected = old;
      });
    }
  }

  _clear(selector) {
    const slot = this.shadowRoot.querySelector(selector);

    if (slot) {
      slot.assignedNodes().forEach(node => {
        node.parentNode.removeChild(node);
      });
    }
  }

  _loadRemote() {
    if (this.source) {
      let url = this.toAbsoluteURL(this.source);

      if (url.indexOf('?') > -1) {
        url = `${url}&${this._getParameters()}`;
      } else {
        url = `${url}?${this._getParameters()}`;
      }

      console.log('<pb-select> loading items from %s', url);
      fetch(url, {
        method: 'GET',
        mode: 'cors',
        credentials: 'same-origin'
      }).then(response => response.json()).then(json => {
        this._clear('slot:not([name])');

        const items = [];
        json.forEach(item => {
          items.push({
            label: item.text,
            value: item.value
          });
        });
        console.log('<pb-select> loaded %d items', items.length);
        this._items = items;
      }).catch(() => {
        console.error('<pb-select> request to %s failed', url);
      });
    }
  }

  _getParameters() {
    const slot = this.shadowRoot.querySelector('[name="subform"]');
    const params = [];

    if (slot) {
      slot.assignedNodes().forEach(node => {
        const inputs = node.querySelectorAll('[name]');
        inputs.forEach(input => {
          params.push(`${input.name}=${encodeURIComponent(input.value)}`);
        });
      });
    }

    return params.join('&');
  }

  render() {
    if (this.multi) {
      return html$1`
                <slot name="subform"></slot>
                <iron-label for="list" part="label">${translate(this.label)}</iron-label>
                ${this.multi ? html$1`<paper-listbox id="list" slot="dropdown-content" class="dropdown-content" 
                    .selectedValues="${this.values}" multi
                    attr-for-selected="value" @iron-select="${this._changed}" @iron-deselect="${this._changed}">
                    <slot></slot>
                    ${this._items.map(item => html$1`<paper-item value="${item.value}">${item.label}</paper-item>`)}
                </paper-listbox>` : html$1`<paper-listbox id="list" slot="dropdown-content" class="dropdown-content" 
                    .selected="${this.value}"
                    attr-for-selected="value" @iron-select="${this._changed}" @iron-deselect="${this._changed}">
                    <slot></slot>
                    ${this._items.map(item => html$1`<paper-item value="${item.value}">${item.label}</paper-item>`)}
                </paper-listbox>`}
                <slot name="output"></slot>
            `;
    }

    return html$1`
            <slot name="subform"></slot>
            <paper-dropdown-menu label="${translate(this.label)}">
                <paper-listbox id="list" slot="dropdown-content" class="dropdown-content" .selected="${this.value}"
                    attr-for-selected="value" @iron-select="${this._changed}">
                    <slot></slot>
                    ${this._items.map(item => html$1`<paper-item value="${item.value}">${item.label}</paper-item>`)}
                </paper-listbox>
            </paper-dropdown-menu>
            <slot name="output"></slot>
        `;
  }

  _changed() {
    const list = this.shadowRoot.getElementById('list');
    const oldSelected = Array.of(this._selected);

    if (this.multi) {
      this._selected = list.selectedValues;
      this.values = this._selected;
    } else {
      this._selected = [list.selected];
      this.value = list.selected;
    } // check if selected items really changed


    if (this._selected.length === oldSelected.length && this._selected.every((val, index) => val === oldSelected[index])) {
      return;
    }

    if (!this._inIronForm || this.multi) {
      this._clear('[name="output"]');

      const vals = this.multi ? this.values : [this.value];
      vals.forEach(val => {
        const hidden = document.createElement('input');
        hidden.type = 'hidden';
        hidden.name = this.name;
        hidden.value = val;
        hidden.slot = 'output';
        this.appendChild(hidden);
      });
    }

    this.dispatchEvent(new CustomEvent('change'));
  }

  static get styles() {
    return css`
            :host {
                display: flex;
                flex-direction: column;
                position:relative;
                margin-top:1rem;
            }

            iron-label {
                font: var(--pb-base-font);
                font-size:var(--pb-font-caption);
                font-weight: 400;
                color: var(--pb-color-lighter);
            }
            
            paper-listbox{
                overflow:auto;
            }
        `;
  }

}
customElements.define('pb-select', PbSelect);

/**
 * A component with a button which copies the contained content to the clipboard.
 * Use for the typical 'quote this content as' hints on a webpage.
 *  
 * @slot content - contains the actual content to copy to the clipboard
 */

class PbClipboard extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * Label to display above the text to be copied
       */
      label: {
        type: String
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.label = 'clipboard.label';
  }

  render() {
    return html$1`
            <h3>${translate(this.label)}</h3>
            <div>
                <slot></slot>
                <paper-icon-button icon="icons:content-copy" @click="${this._copy}"
                    title="${translate('clipboard.copy')}"></paper-icon-button>
            </div>
        `;
  }
  /**
   * Copy text content from the <slot> to the clipboard
   */


  _copy() {
    const slot = this.shadowRoot.querySelector('slot'); // first import nodes from the slot into a temporary div

    const content = document.createElement('div');
    slot.assignedNodes().forEach(node => {
      content.appendChild(document.importNode(node, true));
    }); // copy the innerText of the temp div into the clipboard

    navigator.clipboard.writeText(content.innerText);
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
            h3 {
                margin: 0;
                font-size: .85em;
                font-weight: normal;
                color: #3a3a3a;
            }
            div {
                display: flex;
                align-items: center;
                padding: 0 16px;
            }
        `;
  }

}
customElements.define('pb-clipboard', PbClipboard);

/* eslint-disable class-methods-use-this */

/**
 * Abstract base class to be implemented by all connectors.
 */
class Registry {
  constructor(configElem) {
    this._prefix = configElem.getAttribute('prefix');
    this._config = {
      name: configElem.getAttribute('name'),
      properties: {}
    };
    this._register = this._config.name;
  }

  get register() {
    return this._register;
  }
  /**
   * Return a descriptive name for the registry
   *
   * @returns {String} registry name
   */


  get name() {
    return this._register;
  }

  set name(name) {
    this._register = name;
  }
  /**
   * Query the authority and return a RegistryResult.
   *
   * @param {String} key the search string
   */


  query(key) {
    throw new Error('Method query not implemented');
  }
  /**
   * Retrieve information about a registry entry and display it
   * using the given container.
   *
   * @param {String} id the id to look up
   * @param {HTMLElement} container reference to an element which should be used as container for displaying the information
   * @returns {Promise} a promise
   */


  info(id, container) {
    container.innerHTML = 'not implemented';
    return Promise.resolve();
  }
  /**
   * Return an XML fragment for the specified item to be inserted
   * into the document.
   *
   * @param item the item to output
   */


  select(item) {
    /* do nothing by default */
  }
  /**
   * Retrieve a raw JSON record for the given key as returned by the endpoint.
   * 
   * @param {string} key the key to look up
   * @returns {Promise<any>} promise resolving to the JSON record returned by the endpoint
   */


  async getRecord(key) {
    return Promise.reject();
  }

}

/* eslint-disable class-methods-use-this */
class Metagrid extends Registry {
  async query(key) {
    const query = key.replace(/[^\w\s]+/g, '');
    const results = [];
    const url = `https://api.metagrid.ch/search?query=${encodeURIComponent(query)}`;
    return new Promise(resolve => {
      fetch(url).then(response => response.json()).then(json => {
        json.resources.forEach(item => {
          const name = `${item.metadata.last_name}, ${item.metadata.first_name} `;
          const result = {
            register: this._register,
            id: `${item.provider.slug}-${item.identifier}`,
            label: name,
            details: `${item.metadata.birth_date} - ${item.metadata.death_date}`,
            link: item.link.uri,
            provider: item.provider.slug
          };
          results.push(result);
        });
        resolve({
          totalItems: json.meta.total,
          items: results
        });
      });
    });
  }

  info(key, container) {
    const p = key.indexOf('-');
    const slug = key.substring(0, p);
    return new Promise(resolve => {
      this.getRecord(key).then(json => {
        const output = `
          <h3 class="label">
            <a href="https://${json.link.uri}" target="_blank">
              ${json.metadata.last_name}, ${json.metadata.first_name}
            </a>
          </h3>
          <p>${json.metadata.birth_date} - ${json.metadata.death_date}</p>
        `;
        container.innerHTML = output;
        resolve({
          id: `${slug}-${json.identifier}`,
          strings: [`${json.metadata.first_name} ${json.metadata.last_name}`]
        });
      });
    });
  }
  /**
   * Retrieve a raw JSON record for the given key as returned by the endpoint.
   * 
   * @param {string} key the key to look up
   * @returns {Promise<any>} promise resolving to the JSON record returned by the endpoint
   */


  async getRecord(key) {
    const p = key.indexOf('-');
    const slug = key.substring(0, p);
    const id = key.substring(p + 1);
    return fetch(`https://api.metagrid.ch/search?slug=${slug}&query=${id}`).then(response => response.json()).then(json => {
      const item = json.resources[0];
      const output = Object.assign({}, item);
      output.name = `${item.metadata.first_name} ${item.metadata.last_name}`;
      output.links = [`https://${item.link.uri}`];

      if (item.metadata.birth_date && item.metadata.birth_date.length > 0) {
        output.birth = item.metadata.birth_date;
      }

      if (item.metadata.death_date && item.metadata.death_date.length > 0) {
        output.death = item.metadata.death_date;
      }

      return output;
    }).catch(reason => Promise.reject(reason));
  }

}

class GeoNames extends Registry {
  constructor(configElem) {
    super(configElem);
    this.user = configElem.getAttribute('user');
  }

  async query(key) {
    const results = [];
    return new Promise(resolve => {
      fetch(`https://secure.geonames.org/searchJSON?formatted=true&q=${encodeURIComponent(key)}&maxRows=100&&username=${this.user}&style=full`).then(response => response.json()).then(json => {
        json.geonames.forEach(item => {
          const result = {
            register: this._register,
            id: this._prefix ? `${this._prefix}-${item.geonameId}` : item.geonameId,
            label: item.toponymName,
            details: `${item.fcodeName} - ${item.adminName1}, ${item.countryName}`,
            link: `https://www.geonames.org/${item.geonameId}`,
            strings: [item.toponymName],
            provider: 'geonames.org'
          };
          results.push(result);
        });
        resolve({
          totalItems: json.totalResultsCount,
          items: results
        });
      });
    });
  }

  info(key, container) {
    if (!key) {
      return Promise.resolve({});
    }

    return new Promise((resolve, reject) => {
      this.getRecord(key).then(json => {
        if (json.status) {
          reject(json.status.message);
          return;
        }

        const output = `
            <h3 class="label">
              <a href="${json.link}" target="_blank">${json.name}</a>
            </h3>
            <p class="fcode">${json.note} - ${json.region}, ${json.country}</p>
          `;
        container.innerHTML = output;
        resolve({
          id: this._prefix ? `${this._prefix}-${json.geonameId}` : json.geonameId,
          strings: [json.name]
        });
      }).catch(() => reject());
    });
  }
  /**
   * Retrieve a raw JSON record for the given key as returned by the endpoint.
   *
   * @param {string} key the key to look up
   * @returns {Promise<any>} promise resolving to the JSON record returned by the endpoint
   */


  async getRecord(key) {
    const id = this._prefix ? key.substring(this._prefix.length + 1) : key;
    return fetch(`https://secure.geonames.org/getJSON?geonameId=${encodeURIComponent(id)}&username=${this.user}`).then(response => {
      if (response.ok) {
        return response.json();
      }

      return Promise.reject(response.status);
    }).then(json => {
      const output = Object.assign({}, json);
      output.name = json.toponymName;
      output.country = json.countryName;
      output.region = json.adminName1;
      output.note = json.fcodeName;
      output.links = [`https://www.geonames.org/${json.geonameId}`, `https://${json.wikipediaURL}`];
      return output;
    }).catch(() => Promise.reject());
  }

}

function expandTemplate(template = '', options) {
  return template.replace(/\${([^}]+)}/g, (match, p) => {
    let replacement;

    if (options[p]) {
      replacement = options[p];
    }

    return replacement || '';
  });
}

function getTemplate(configElem, selector) {
  const template = configElem.querySelector(selector);

  if (template instanceof HTMLTemplateElement) {
    const wrapper = document.createElement('div');
    wrapper.appendChild(template.content.cloneNode(true));
    return wrapper.innerHTML;
  }

  return '';
}

class Airtable extends Registry {
  constructor(configElem) {
    super(configElem);
    this.apiKey = configElem.getAttribute('api-key');
    this.baseKey = configElem.getAttribute('base');
    this.table = configElem.getAttribute('table');
    this.view = configElem.getAttribute('view');
    this.filterExpr = configElem.getAttribute('filter');
    this.labelExpr = configElem.getAttribute('label');
    const fieldsDef = configElem.getAttribute('fields');

    if (fieldsDef) {
      this.fields = fieldsDef.split(/\s*,\s*/);
    } else {
      this.fields = ['ID'];
    }

    const tokenizeDef = configElem.getAttribute('tokenize');

    if (tokenizeDef) {
      this.tokenize = tokenizeDef.split(/\s*,\s*/);
    } else {
      this.tokenize = [this.fields[0]];
    }

    this.tokenizeChars = configElem.getAttribute('tokenize-regex') || "\\W";
    this.infoExpr = getTemplate(configElem, '.info');
    this.detailExpr = getTemplate(configElem, '.detail');

    this._init();
  }

  _init() {
    window.ESGlobalBridge.requestAvailability();
    const path = resolveURL('https://unpkg.com/airtable@0.11.1/build/airtable.browser.js');
    window.ESGlobalBridge.instance.load('airtable', path);
    window.addEventListener('es-bridge-airtable-loaded', this._initAirtable.bind(this), {
      once: true
    });
  }

  _initAirtable() {
    const Airtable = require('airtable');

    this.base = new Airtable({
      apiKey: this.apiKey
    }).base(this.baseKey);
  }

  async query(key) {
    key = key.toLowerCase();
    const results = [];
    const filter = this.filterExpr ? expandTemplate(this.filterExpr, {
      key
    }) : null;
    const options = {
      fields: this.fields,
      // Selecting the first 3 records in Grid view:
      maxRecords: 100
    };

    if (this.view) {
      options.view = this.view;
    }

    if (filter) {
      options.filterByFormula = filter;
    }

    return new Promise((resolve, reject) => {
      this.base(this.table).select(options).firstPage((err, records) => {
        if (err) {
          console.error(err);
          reject(err);
          return;
        }

        records.forEach(record => {
          const data = {};
          this.fields.forEach(field => {
            data[field] = record.get(field);
          });
          const result = {
            register: this._register,
            id: record.id,
            label: expandTemplate(this.labelExpr, data),
            details: expandTemplate(this.detailExpr, data),
            provider: 'airtable'
          };
          results.push(result);
        });
        resolve({
          totalItems: 3,
          items: results
        });
      });
    });
  }

  info(key, container) {
    return new Promise((resolve, reject) => {
      const options = {
        fields: this.fields,
        filterByFormula: `RECORD_ID()='${key}'`
      };
      this.base(this.table).select(options).firstPage((err, records) => {
        if (err) {
          switch (err.statusCode) {
            case 404:
              reject(`No record found for ${key} in table ${this.table}`);
              break;

            default:
              reject(`${err.statusCode}: ${err.message}`);
              break;
          }

          return;
        }

        const record = records[0];

        if (Object.keys(record.fields).length === 0) {
          console.warn(`Retrieved an empty record for %s from table %s`, key, this.table);
          return;
        }

        let strings = [];
        const data = {};
        this.fields.forEach(field => {
          const value = record.get(field);

          if (value) {
            data[field] = value;
            strings.push(value);
          }
        });
        const regex = new RegExp(this.tokenizeChars);
        this.tokenize.forEach(key => {
          strings = strings.concat(data[key].split(regex));
        });
        strings = strings.filter(tok => !/^\d+$/.test(tok));
        strings.sort((s1, s2) => s2.length - s1.length);
        console.log(strings);
        container.innerHTML = expandTemplate(this.infoExpr, data);
        resolve({
          id: record.id,
          strings
        });
      });
    });
  }

}

/* eslint-disable class-methods-use-this */

function _details(item) {
  let professions = '';

  if (item.professionOrOccupation && item.professionOrOccupation.length > 0) {
    professions = item.professionOrOccupation.map(p => p.label).join(', ');
  }

  if (item.biographicalOrHistoricalInformation) {
    professions = `${professions}; ${item.biographicalOrHistoricalInformation.join(', ')}`;
  }

  const dates = [];

  if (item.dateOfBirth && item.dateOfBirth.length > 0) {
    dates.push(item.dateOfBirth[0]);
  }

  if (item.dateOfDeath && item.dateOfDeath.length > 0) {
    dates.push(' - ');
    dates.push(item.dateOfDeath[0]);
  }

  if (dates.length > 0) {
    return `${dates.join('')}${professions ? `; ${professions}` : ''}`;
  }

  return professions;
}
/**
 * Uses https://lobid.org to query the German GND
 */


class GND extends Registry {
  query(key) {
    const results = [];
    let filter;

    switch (this._register) {
      case 'place':
        filter = 'PlaceOrGeographicName';
        break;

      case 'term':
        filter = 'SubjectHeading';
        break;

      case 'organization':
        filter = 'CorporateBody';
        break;

      default:
        filter = 'Person';
        break;
    }

    return new Promise(resolve => {
      fetch(`https://lobid.org/gnd/search?q=${encodeURIComponent(key)}&filter=%2B%28type%3A${filter}%29&format=json&size=100`).then(response => response.json()).then(json => {
        json.member.forEach(item => {
          const result = {
            register: this._register,
            id: this._prefix ? `${this._prefix}-${item.gndIdentifier}` : item.gndIdentifier,
            label: item.preferredName,
            link: item.id,
            details: _details(item),
            strings: [item.preferredName].concat(item.variantName),
            provider: 'GND'
          };
          results.push(result);
        });
        resolve({
          totalItems: json.totalItems,
          items: results
        });
      });
    });
  }
  /**
   * Retrieve a raw JSON record for the given key as returned by the endpoint.
   *
   * @param {string} key the key to look up
   * @returns {Promise<any>} promise resolving to the JSON record returned by the endpoint
   */


  async getRecord(key) {
    const id = this._prefix ? key.substring(this._prefix.length + 1) : key;
    return fetch(`https://lobid.org/gnd/${id}.json`).then(response => {
      if (response.ok) {
        return response.json();
      }

      return Promise.reject();
    }).then(json => {
      const output = Object.assign({}, json);
      output.name = json.preferredName;
      output.link = json.id;

      if (json.dateOfBirth && json.dateOfBirth.length > 0) {
        output.birth = json.dateOfBirth[0];
      }

      if (json.dateOfDeath && json.dateOfDeath.length > 0) {
        output.death = json.dateOfDeath[0];
      }

      if (json.biographicalOrHistoricalInformation) {
        output.note = json.biographicalOrHistoricalInformation.join('; ');
      }

      if (json.professionOrOccupation && json.professionOrOccupation.length > 0) {
        output.profession = json.professionOrOccupation.map(prof => prof.label);
      }

      return output;
    }).catch(() => Promise.reject());
  }

  info(key, container) {
    if (!key) {
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      this.getRecord(key).then(json => {
        let info;

        if (json.type.indexOf('SubjectHeading') > -1) {
          info = this.infoSubject(json);
        } else if (json.type.indexOf('AuthorityResource') > -1) {
          info = this.infoPerson(json);
        }

        const output = `
          <h3 class="label">
            <a href="https://${json.id}" target="_blank"> ${json.preferredName} </a>
          </h3>
          ${info}
        `;
        container.innerHTML = output;
        resolve({
          id: this._prefix ? `${this._prefix}-${json.gndIdentifier}` : json.gndIdentifier,
          strings: [json.preferredName].concat(json.variantName)
        });
      }).catch(() => reject());
    });
  }

  infoPerson(json) {
    const professions = json.professionOrOccuption ? json.professionOrOccupation.map(prof => prof.label) : [];
    return `<p>${json.dateOfBirth} - ${json.dateOfDeath}</p>
      <p>${professions.join(' ')}</p>`;
  }

  infoSubject(json) {
    if (json.broaderTermGeneral) {
      const terms = json.broaderTermGeneral.map(term => term.label);
      return `<p>${terms.join(', ')}</p>`;
    }

    return '';
  }

}

class KBGA extends Registry {
  constructor(configElem) {
    super(configElem);
    this._api = configElem.getAttribute('api');
  }

  async query(key) {
    const results = [];
    const register = this.getRegister();
    const searchParam = register === 'bibls' ? 'biblsearch' : 'search';
    const url = `https://meta.karl-barth.ch/api/${register}?${searchParam}=${encodeURIComponent(key)}`;
    const label = this.getLabelField();
    return new Promise(resolve => {
      fetch(url).then(response => response.json()).then(json => {
        json.data.forEach(item => {
          if (this._register === 'organization' && item.authority_type !== 'organisation' || this._register === 'person' && item.authority_type !== 'person') {
            return;
          }

          const result = {
            register: this._register,
            id: this._prefix ? `${this._prefix}:${item['full-id']}` : item['full-id'],
            label: typeof label === "string" ? item[label] : label(item),
            details: `${item['full-id']}`,
            link: `https://meta.karl-barth.ch/${register}/${item.id}`,
            strings: [typeof label === "string" ? item[label] : label(item)],
            provider: 'KBGA'
          };
          results.push(result);
        });
        resolve({
          totalItems: json.meta.total,
          items: results
        });
      });
    });
  }

  info(key, container) {
    if (!key) {
      return Promise.resolve({});
    }

    const label = this.getLabelField();
    return new Promise(resolve => {
      this.getRecord(key).then(json => {
        const died = json.data.death ? ` ${json.data.death}` : '';
        const dates = json.data.birth ? `<p>* ${json.data.birth} ${died}</p>` : '';
        const note = json.data.note_bio ? `<p>${json.data.note_bio}</p>` : '';
        const output = `
            <h3 class="label"><a href="https://${json.wikipediaURL}" target="_blank">${typeof label === 'string' ? json.data[label] : label(json.data)}</a></h3>
              ${dates}
              ${note}
          `;
        container.innerHTML = output;
        resolve({
          id: json.data['full-id'],
          strings: [typeof label === 'string' ? json.data[label] : label(json.data)]
        });
      });
    });
  }
  /**
  * Retrieve a raw JSON record for the given key as returned by the endpoint.
  * 
  * @param {string} key the key to look up
  * @returns {Promise<any>} promise resolving to the JSON record returned by the endpoint
  */


  async getRecord(key) {
    const id = key.replace(/^.*-([^-]+)$/, '$1');
    return fetch(`https://meta.karl-barth.ch/api/${this.getRegister()}/${id}`).then(response => response.json()).then(json => {
      const output = Object.assign({}, json);
      output.name = json.data[this.getLabelField()];

      switch (this._register) {
        case 'place':
          output.country = json.data.country;
          output.location = json.data.location.coordinates;
          output.links = json.data.links.map(link => link.url);
          break;

        case 'person':
          output.birth = json.data.birth;
          output.death = json.data.death;
          output.note = json.data.note_bio;
          output.links = [`https://${json.wikipediaURL}`];
          break;
      }

      return output;
    }).catch(reason => Promise.reject(reason));
  }

  getLabelField() {
    let label;

    switch (this._register) {
      case 'place':
        label = 'placeName_full';
        break;

      case 'term':
        label = 'fullLabel';
        break;

      case 'abbreviation':
        label = 'label';
        break;

      case 'bibl':
        label = 'asHtml';
        break;

      default:
        label = 'persName_full';
        break;
    }

    return label;
  }

  getRegister() {
    if (this._api) {
      return this._api;
    }

    let register;

    switch (this._register) {
      case 'person':
      case 'organization':
        register = 'actors';
        break;

      case 'place':
        register = 'places';
        break;

      case 'term':
        register = 'terms';
        break;

      case 'abbreviation':
        register = 'abbreviations';
        break;

      case 'bibl':
        register = 'bibls';
        break;

      default:
        register = this._register;
    }

    return register;
  }

}

/**
 * Connector for the corporate archive of Georgfischer AG.
 */

class GF extends Registry {
  constructor(configElem) {
    super(configElem);
    this._api = configElem.getAttribute('api');
  }

  async query(key) {
    const results = [];
    const register = this.getRegister();
    const url = `https://archives.georgfischer.com/api/${register}?search=${encodeURIComponent(key)}`;
    const label = this.getLabelField();
    return new Promise(resolve => {
      fetch(url).then(response => response.json()).then(json => {
        if (!json.data) {
          resolve({
            totalItems: 0,
            items: []
          });
          return;
        }

        json.data.forEach(item => {
          if (this._register === 'organization' && item.authority_type === 'Person' || this._register === 'person' && item.authority_type !== 'Person') {
            return;
          }

          const result = {
            register: this._register,
            id: this._prefix ? `${this._prefix}-${item.id}` : item.id,
            label: item[label],
            details: `${item.id}`,
            link: `https://archives.georgfischer.com/api/${register}/${item.id}`,
            strings: [item[label]],
            provider: 'GF'
          };
          results.push(result);
        });
        resolve({
          totalItems: json.meta.total,
          items: results
        });
      }).catch(reason => Promise.reject(reason));
    });
  }

  info(key, container) {
    if (!key) {
      return Promise.resolve({});
    }

    const id = this._prefix ? key.substring(this._prefix.length + 1) : key;
    const label = this.getLabelField();
    return new Promise(resolve => {
      this.getRecord(id).then(json => {
        const died = json.data.death ? ` ${json.data.death}` : '';
        const dates = json.data.birth ? `<p>* ${json.data.birth} ${died}</p>` : '';
        const note = json.data.note_bio ? `<p>${json.data.note_bio}</p>` : '';
        const output = `
            <h3 class="label"><a href="https://${json.wikipediaURL}" target="_blank">${json.data[label]}</a></h3>
              ${dates}
              ${note}
          `;
        container.innerHTML = output;
        resolve({
          id: this._prefix ? `${this._prefix}-${json.data.id}` : json.data.id,
          strings: [json.data[label]]
        });
      });
    });
  }
  /**
  * Retrieve a raw JSON record for the given key as returned by the endpoint.
  * 
  * @param {string} key the key to look up
  * @returns {Promise<any>} promise resolving to the JSON record returned by the endpoint
  */


  async getRecord(key) {
    const id = key.replace(/^.*-([^-]+)$/, '$1');
    const url = `https://archives.georgfischer.com/api/${this.getRegister()}/${id}`;
    return fetch(url).then(response => response.json()).then(json => {
      const output = Object.assign({}, json);
      output.name = json.data[this.getLabelField()];

      switch (this._register) {
        case 'place':
          output.country = json.data.country;
          output.location = json.data.location.coordinates;
          output.links = json.data.links.map(link => link.url);
          break;

        case 'person':
          output.birth = json.data.birth;
          output.death = json.data.death;
          output.note = json.data.note_bio;
          output.links = [`https://${json.wikipediaURL}`];
          break;
      }

      return output;
    }).catch(reason => Promise.reject(reason));
  }

  getLabelField() {
    let label;

    switch (this._register) {
      case 'term':
        label = 'label';
        break;

      default:
        label = 'fullname';
        break;
    }

    return label;
  }

  getRegister() {
    if (this._api) {
      return this._api;
    }

    let register;

    switch (this._register) {
      case 'person':
      case 'organization':
        register = 'actors';
        break;

      case 'place':
        register = 'places';
        break;

      case 'term':
        register = 'keywords';
        break;

      case 'abbreviation':
        register = 'abbreviations';
        break;

      default:
        register = this._register;
    }

    return register;
  }

}

/* eslint-disable class-methods-use-this */
// - strings <- types
// - use scheme#types in @type output?
// - test with other providers, inside custom connector
// - documentation

async function getServiceManifest(endpoint) {
  const response = await fetch(endpoint);
  const data = await response.json();
  return data;
}

class ReconciliationService extends Registry {
  constructor(configElem) {
    super(configElem);
    this.endpoint = configElem.getAttribute('endpoint');
    this.debug = configElem.getAttribute('debug');
    getServiceManifest(this.endpoint).then(result => {
      this.ORConfig = result;

      if (this.debug) {
        console.log('OpenReconcile connector for register \'%s\' at endpoint <%s>. Using config: %o', this._register, this.endpoint, this.ORConfig);
      }
    });
  }
  /**
   * Query the authority and return a RegistryResult.
   *
   * @param {String} key the search string
   */


  async query(key) {
    const results = [];
    const paramsObj = {
      q1: {
        query: key
      }
    };
    return new Promise(resolve => {
      fetch(this.endpoint, {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: "queries=".concat(JSON.stringify(paramsObj))
      }).then(response => response.json()).then(json => {
        json.q1.result.forEach(item => {
          if (this.ORConfig.view) {
            this.view = this.ORConfig.view.url.replace('{{id}}', item.id);
          } else {
            this.view = item.id;
          }

          if (item.description) {
            this.description = item.description;
          } else if (item.type) {
            this.description = item.type.map(t => t.name.toString()).join(', ');
          } else {
            this.description = "";
          }

          const result = {
            register: this._register,
            id: this._prefix ? `${this._prefix}-${item.id}` : item.id,
            label: item.name,
            link: this.view,
            details: this.description,
            provider: 'OpenReconcile'
          };
          results.push(result);
        });

        if (this.debug) {
          console.log('OpenReconcile results: %o', results);
        }

        resolve({
          totalItems: json.q1.result.length,
          items: results
        });
      });
    });
  }
  /**
   * Retrieve information about a registry entry and display it
   * using the given container.
   *
   * @param {String} id the id to look up
   * @param {HTMLElement} container reference to an element which should be used as container for displaying the information
   * @returns {Promise} a promise
   */


  info(id, container) {
    if (!id) {
      return Promise.resolve({});
    }

    if (!this.ORConfig.preview) {
      container.innerHTML = 'no \'preview\' information in endpoint\'s manifest';
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      const rawid = this._prefix ? id.substring(this._prefix.length + 1) : id;
      const url = this.ORConfig.preview.url.replace('{{id}}', encodeURIComponent(rawid));
      fetch(url).then(response => response.text()).then(output => {
        container.innerHTML = output;
        resolve({
          id: this._prefix ? `${this._prefix}-${rawid}` : rawid
        });
      }).catch(() => reject());
    });
  }

}

class Custom extends Registry {
  constructor(endpoint, configElem) {
    super(configElem);
    this._endpoint = endpoint;
    this._connectors = createConnectors(endpoint, configElem);

    this._connectors.forEach(connector => {
      connector.name = this.name;
    });

    console.log('custom connector: endpoint: %s; using authorities: %o', this._endpoint, this._connectors);
  }

  async query(key) {
    return new Promise(resolve => {
      fetch(`${this._endpoint}/api/register/search/${this._register}?query=${encodeURIComponent(key)}`).then(response => response.json()).then(async json => {
        let results = [];
        const localResults = new Set();
        json.forEach(item => {
          results.push({
            register: this._register,
            id: item.id,
            label: item.label,
            link: item.link,
            details: item.details,
            provider: 'local'
          });
          localResults.add(item.id);
        });
        let totalItems = json.length;

        for (const connector of this._connectors) {
          // eslint-disable-next-line no-await-in-loop
          const dr = await connector.query(key);
          results = results.concat(dr.items.filter(result => !localResults.has(result.id)));
          totalItems += dr.totalItems;
        }

        resolve({
          totalItems,
          items: results
        });
      });
    });
  }

  info(key, container) {
    if (!key) {
      return Promise.resolve({});
    }

    const id = key;
    return new Promise((resolve, reject) => {
      fetch(`${this._endpoint}/api/register/${this._register}/${encodeURIComponent(id)}`).then(async response => {
        if (response.ok) {
          const json = await response.json();
          container.innerHTML = json.details;
          resolve({
            id: json.id,
            strings: json.strings
          });
          return;
        }

        if (response.status === 404) {
          for (const connector of this._connectors) {
            try {
              // eslint-disable-next-line no-await-in-loop
              const cr = await connector.info(key, container);

              if (cr) {
                resolve(cr);
              }
            } catch (e) {// not found: continue
            }
          }
        }

        reject();
      });
    });
  }
  /**
   * 
   * @param {any} item 
   * @returns {Promise}
   */


  async select(item) {
    let entry;

    for (const connector of this._connectors) {
      // eslint-disable-next-line no-await-in-loop
      entry = await connector.getRecord(item.id);

      if (entry) {
        break;
      }
    }

    if (!entry) {
      return Promise.reject(`No record found for ID ${item.id}`);
    }

    return fetch(`${this._endpoint}/api/register/${this._register}/${encodeURIComponent(item.id)}`, {
      method: 'POST',
      mode: "cors",
      credentials: "same-origin",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(entry)
    }).then(response => response.json());
  }

}

function createConnectors(endpoint, root) {
  const authorities = [];
  root.querySelectorAll(':scope > pb-authority').forEach(configElem => {
    const connector = configElem.getAttribute('connector');
    let instance;

    switch (connector) {
      case 'GND':
        instance = new GND(configElem);
        break;

      case 'GeoNames':
        instance = new GeoNames(configElem);
        break;

      case 'Airtable':
        instance = new Airtable(configElem);
        break;

      case 'KBGA':
        instance = new KBGA(configElem);
        break;

      case 'GF':
        instance = new GF(configElem);
        break;

      case 'ReconciliationService':
        instance = new ReconciliationService(configElem);
        break;

      case 'Custom':
        instance = new Custom(endpoint, configElem);
        break;

      default:
        instance = new Metagrid(configElem);
        break;
    }

    authorities.push(instance);
  });
  return authorities;
}

/**
 * Performs authority lookups via configurable connectors.
 */

class PbAuthorityLookup extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * The query string to be sent to the authority
       */
      query: {
        type: String,
        reflect: true
      },

      /**
       * Enable to alphabetically reorder authority search results by label.
       * Otherwise results are shown as returned by the authority.
       */
      sortByLabel: {
        type: Boolean,
        attribute: 'sort-by-label'
      },

      /**
       * A list of comma-separated stopwords which should be excluded
       * when searching for other occurrences of an authority in the
       * HTML text
       */
      stopwords: {
        type: String
      },
      _results: {
        type: Array
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.query = '';
    this.type = null;
    this.sortByLabel = false;
    this._results = [];
    this._authorities = {};
  }

  connectedCallback() {
    super.connectedCallback();
    this._stopwordSet = new Set();

    if (this.stopwords) {
      this.stopwords.split(/\s*,\s*/).forEach(sw => this._stopwordSet.add(sw.toLowerCase()));
    }

    this.subscribeTo('pb-authority-lookup', ev => {
      this.query = ev.detail.query;
      this.type = ev.detail.type;
      this._results = [];

      this._query();
    });
    PbAuthorityLookup.waitOnce('pb-page-ready', () => {
      const connectors = createConnectors(this.getEndpoint(), this);
      connectors.forEach(connector => {
        this._authorities[connector.register] = connector;
      });
    });
    console.log('<pb-authority-lookup> Registered authorities: %o', this._authorities);
  }

  render() {
    return html$1`
      <paper-input
        id="query"
        label="${translate('Search for')}"
        always-float-label
        value="${this.query}"
        @change="${this._queryChanged}"
      >
        <iron-icon icon="icons:search" slot="prefix"></iron-icon>
      </paper-input>
      <div id="output">
        <table part="output">
          ${this._results.map(item => this._formatItem(item))}
        </table>
      </div>
    `;
  }

  async lookup(register, id, container) {
    if (!id || id === '') {
      console.log('<pb-authority-lookup> Key is empty');
      container.innerHTML = '';
      return Promise.resolve();
    }

    const authority = this._authorities[register];
    console.log('<pb-authority-lookup> Retrieving info for %s from %s', id, register);
    let info = await authority.info(id, container);

    if (info.strings) {
      info = Object.assign(info, {
        strings: info.strings.filter(s => s && !this._stopwordSet.has(s.toLowerCase()))
      });
    }

    return info;
  }

  _formatItem(item) {
    return html$1`
      <tr>
        <td>
          <paper-icon-button
            icon="icons:add"
            @click="${() => this._select(item)}"
          ></paper-icon-button>
        </td>
        <td>
          <div>
            ${item.link ? html$1`<a target="_blank" href="${item.link}">${unsafeHTML(item.label)}</a>` : html$1`${unsafeHTML(item.label)}`}
          </div>
          ${item.details ? html$1`<div class="details" part="details">${item.details}</div>` : null}
        </td>
        <td>${item.occurrences > 0 ? html$1`<span class="occurrences" part="occurrences">${item.occurrences}</span>` : null}</td>
        <td>${item.provider ? html$1`<div><span class="source" part="source">${item.provider}</span></div>` : null}</td>
        <td><span class="register" part="register">${item.register}</span></td>
      </tr>
    `;
  }

  _select(item) {
    const connector = this._authorities[item.register];

    if (connector) {
      connector.select(item);
    }

    const options = {
      strings: item.strings,
      properties: {
        ref: item.id
      }
    };
    this.emitTo('pb-authority-select', options);
  }

  _queryChanged() {
    this._results = [];
    this.query = this.shadowRoot.getElementById('query').value;

    this._query();
  }

  _query() {
    this.emitTo('pb-start-update');

    this._authorities[this.type].query(this.query).then(results => {
      this._occurrences(results.items).then(merged => {
        this._results = merged;
      });

      this.emitTo('pb-end-update');
      this.shadowRoot.getElementById('query').focus();
    });
  }

  _occurrences(items) {
    const params = new FormData();
    params.append('register', this.type);
    items.forEach(item => {
      params.append('id', item.id);
    });
    return new Promise(resolve => {
      fetch(`${this.getEndpoint()}/api/annotations/occurrences`, {
        method: 'POST',
        body: params
      }).then(response => {
        if (response.ok) {
          return response.json();
        }
      }).then(json => {
        items.forEach(item => {
          if (json[item.id]) {
            item.occurrences = json[item.id];
          } else {
            item.occurrences = 0;
          }
        });
        items.sort((i1, i2) => {
          const d = i2.occurrences - i1.occurrences;

          if (d === 0) {
            if (i1.provider === 'local' && i2.provider !== 'local') {
              return -1;
            }

            if (i2.provider === 'local' && i1.provider !== 'local') {
              return 1;
            }

            return this.sortByLabel ? i1.label.localeCompare(i2.label) : 0;
          }

          return d;
        });
        resolve(items);
      });
    });
  }

  static get styles() {
    return css`
      :host {
        display: flex;
        flex-direction: column;
      }
      #output {
        overflow: auto;
        /*FireFox*/
        scrollbar-width: none;
      }

      #output table {
        width: 100%;
      }
      #output td {
        vertical-align: top;
        padding-bottom: 8px;
      }
      #output td:nth-child(3), #output td:nth-child(4), #output td:nth-child(5) {
        text-align: right;
        vertical-align: middle;
      }

      .details, .source, .register, .occurrences {
        font-size: .85rem;
      }

      .source, .register, .occurrences {
        border-radius: 4px;
        padding: 4px;
        color: var(--pb-color-inverse);
      }

      .source {
        background-color: #637b8c;
      }
      .register {
        background-color: var(--pb-color-lighter);
      }
      .occurrences {
        background-color: var(--pb-color-focus);
      }
    `;
  }

}
customElements.define('pb-authority-lookup', PbAuthorityLookup);

/**
 * This component talks to the blacklab API of TEI-Publisher to
 * load KWIC results from a remote Blacklab instance. It displays
 * a list of documents that match the query given by `pattern`.
 *
 * **Note**: There's no demo for this component yet as it would need a blacklab instance.
 * 
 * For each document a list of hits (matches) is displayed each showing the hit
 * in context of the text.
 *
 * Document Id and hits are links that can be used to open the document
 * and navigate through the hits with the help of pb-view and pb-blacklab-highlight
 * components.
 *
 * @doc - an optional document Id to limit the search to
 * @param pattern - a CQL (Common Query Language) conformant query (required)
 * @perPage - a number to indicate how many result entries to display on one page. Will be passed down to pb-paginate
 * @csspart paginator - the pb-paginate component
 * @csspart label - the pb-paginate label
 */

class PbBlacklabResults extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * results from a kwic search
       */
      data: {
        type: Object
      },
      documents: {
        type: Array
      },

      /**
       * document id
       */
      doc: {
        type: String
      },

      /**
       * how many hits per page. will be passed down to pb-paginate
       */
      perPage: {
        type: Number,
        attribute: 'per-page'
      },

      /**
       * must be a valid CQL query as a string
       */
      pattern: {
        type: String
      },

      /**
       * first document number to be displayed
       */
      first: {
        type: Number
      },

      /**
       * sort order of query results
       */
      sort: {
        type: String
      },

      /**
       * target for links
       */
      target: {
        type: String,
        attribute: 'target'
      }
    });
  }

  constructor() {
    super();
    this.data = {
      documents: []
    };
    this.documents = [];
    this.first = 1;
    this.doc = null;
    this.sort = null;
  }

  static get styles() {
    return css`
            :host {
                display: block;
                max-width:100%;
            }
            table{
                width:100%;
            }
            .docName{
                text-align:left;
            }
            pb-paginate{
                justify-content:center;
                padding-bottom:3rem;
            }
            th, td{
                padding:0.3rem;
            }
            th:nth-child(1),td:nth-child(1){
                width:35%;
            }
            th:nth-child(5), td:nth-child(5){
                width:35%;
            }
            .left, .hit-count{
                text-align:right;
            }
            .right{
                text-align:left;
            }
            td.hit{
                text-align:center;
                white-space:nowrap;
            }
            table{
                cell-spacing:0;
                cell-padding:0;
            }
            tr{
                cell-spacing:0;
                cell-padding:0;
            }
            .t-head th{
                border-bottom:thin solid #999;
            }
            td.hit{
                position:relative;
                padding:0 1rem;
            }
            [icon=create]{
                display:none;
                position:absolute;
                top:-8px;
                right:-8px;
                color:blue;
            }
            td.hit:hover [icon=create]{
                display:inline-block;
            }

        `;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-load', event => {
      // ### handle pb-load received from pb-paginate to set number of first displayed document
      this.first = Number(event.detail.params.start);
      this.load();
    });
    this.subscribeTo('force-load', event => {
      this.load();
      this.requestUpdate();
    });
    this.subscribeTo('pb-results-received', event => {
      this.data = event.detail.data;
      this.documents = this.data.documents;

      this._animate();
    });
  }

  render() {
    return html$1`
            <pb-paginate part="paginator" per-page="${this.perPage}" range="5"></pb-paginate>
            <table>
                <tr class="t-head">
                    <th class="docName">Doc Id</th>
                    <th class="left">before</th>
                    <th>hit</th>
                    <th class="right">after</th>
                    <th class="hit-count">hits</th>
                </tr>
                ${this.documents.map(document => html$1`
                    <tr>
                        <td colspan="4" class="docName">
                            <a href="${this.target}/${document.id}.xml?pattern=${this.pattern}&page=${document.matches[0].page[0]}"
                               target="_blank">${document.id}</a>
                        </td>
                        <td class="hit-count">
                            <span class="hit-count">${document.hits}</span>
                        </td>
                    </tr>
                    ${document.matches.map(match => html$1`
                        <tr>
                            <td class="left" colspan="2">${match.left}</td>
                            <td class="hit">
                                <a href="${this.target}/${document.id}.xml?pattern=${this.pattern}&match=${match.match.words[0]}&page=${match.page[0]}" target="_blank">${match.match.display}</a>
                                <!--<paper-icon-button icon="create"></paper-icon-button>-->
                            </td>
                            <td class="right" colspan="2">${match.right}</td>
                        </tr>
                    `)}
                `)}
            </table>
        `;
  }

  async load() {
    if (!this.getEndpoint()) return;
    if (!this.pattern) return;
    let url = `${this.getEndpoint()}/api/blacklab/search?pattern=${this.pattern}&start=${this.first}&per-page=${this.perPage}`;

    if (this.doc) {
      url += `&doc=${this.doc}`;
    }

    if (this.sort) {
      url += `&sort=${this.sort}`;
    }

    await fetch(url, {
      method: 'GET',
      mode: 'cors',
      credentials: 'same-origin'
    }).then(response => response.json()).then(data => {
      this.data = data;
      localStorage.setItem('pb-kwic-results', JSON.stringify(this.data));
      this.emitTo('pb-results-received', {
        "count": data.docs ? parseInt(data.docs, 10) : 0,
        "start": data.start,
        "params": data.params,
        "data": data
      }, []);
    }).catch(error => {
      alert(`Error retrieving remote content: ${error}`);
    });
  }

  _animate() {
    anime$1({
      targets: this.shadowRoot.querySelector('table'),
      opacity: [0, 1],
      duration: 200,
      delay: 200,
      easing: 'linear'
    });
  }

}
customElements.define('pb-blacklab-results', PbBlacklabResults);

/**
 * This component queries the blacklab API of TEI-Publisher for a list of text matches
 * in a given document. The query is given as a CQL querystring (see pattern property).
 *
 * **Note**: There's no demo for this component yet as it would need a blacklab instance. 
 * 
 * The component displays 2 navigation buttons to jump to previous / next match and
 * a display of the current index and total number of matches.
 *
 * When navigating and the requested match is not on the current page a pb-refresh is dispatched
 * to load the correct page. Once the page has dispatch pb-update this component will refresh and trigger
 * loading of matches from the API.
 *
 * Highlighting is accomplished by marking the matched text with the following CSS classes:
 * - kwic-start - for the start of the match
 * - kwic-end - for the end of the match (might be on the same node as 'kwic-start'
 * - kwic-current - to set a different highlight color for the current match
 *
 * When navigating the browser URL will be updated to allow bookmarks for a certain match.
 *
 * Note: this component does no caching of query results yet. In case of heavier use the data can be taken
 * from localStorage ('pb-kwic-results') as usually pb-kwic-results has been visited by the user before. For
 * stability reasons this was not done in this version.
 *
 *
 * When data are present highlights are processed.
 *
 */

class PbBlacklabHighlight extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * one-based index of the current highlight
       */
      current: {
        type: Number
      },

      /**
       * the id of the view for which highlights shall be displayed
       */
      view: {
        type: String
      },

      /**
       * CQL search pattern send to the Blacklab API
       */
      pattern: {
        type: String
      },

      /**
       * optional match parameter on the URL. If present page will display appropriate hit
       */
      match: {
        type: String
      },

      /**
       * the document id
       */
      docid: {
        type: String
      },

      /**
       * holds the results of querying the 'api/blacklab/doc' endpoint
       */
      hits: {
        type: Array
      },

      /**
       * contains full response after successful loading
       */
      kwicData: {
        type: Object
      },

      /**
       * optional: may hold id of match element to be highlighted
       */
      matchParam: {
        type: String
      },

      /**
       * the pageId to display
       */
      pageId: {
        type: String
      },

      /**
       * how many hits shall be loaded. Defaults to 100. This value is passed to the blacklab API
       */
      perDocument: {
        type: Number,
        attribute: 'per-document'
      }
    });
  }

  connectedCallback() {
    super.connectedCallback();
    this.current = 1;
    this.perDocument = 100;
    this.hits = [];
    this.kwicData = {};
    /*
     * waiting for the page to be ready before storing a reference to the shadowDOM of the view element this
     * component is attached to via the 'view' attribute.
     */

    PbBlacklabHighlight.waitOnce('pb-page-ready', () => {
      this.viewElement = document.getElementById(this.view);

      if (!this.viewElement) {
        console.error(`${this}: view element with id ${this.view} does not exist`);
        return;
      }

      this.shadow = this.viewElement.shadowRoot;
    });
    this.subscribeTo('pb-update', () => {
      this._loadDocResults();
    });
    this.subscribeTo('pb-refresh', ev => {
      this.dynMatch = ev.detail.match;
    });
  }

  render() {
    return html$1`
            ${this.hits.length !== 0 ? html$1`
                <section class="kwic-display">
                    <paper-icon-button icon="icons:arrow-back" @click="${this._handlePrev}" ?disabled="${this.current === 1}"></paper-icon-button>
                    <span class="current">${this.current}</span> / <span class="counter">${this.count}</span>
                    <paper-icon-button icon="icons:arrow-forward" @click="${this._handleNext}" ?disabled="${this.current === this.hits.length}"></paper-icon-button>
                </section>` : ''}
        `;
  }
  /**
   * loads matches from blacklab API, marks matches with CSS classes and displays the current match.
   *
   * The URL query params are used to set params for blacklab API
   *
   * @returns {Promise<void>}
   * @private
   */


  async _loadDocResults() {
    // console.log('endpoint for loading kwic matches', this.getEndpoint());
    if (!this.getEndpoint()) return;
    const params = new URLSearchParams(window.location.search);
    this.pattern = params.get('pattern');
    /*
     * a dynMatch exists when the reloading was triggered by an nav action (prev/next)
     * the match param will be passed by the respective nav handler
     */

    if (this.dynMatch) {
      this.matchParam = this.dynMatch;
    } else {
      this.matchParam = params.get('match');
    }

    this.pageId = params.get('id');
    this.docId = params.get('doc');
    const url = `${this.getEndpoint()}/api/blacklab/doc?pattern=${this.pattern}&doc=${this.docId}&per-document=${this.perDocument}&format=json`;
    await fetch(url, {
      method: 'GET',
      mode: 'cors',
      credentials: 'same-origin'
    }).then(response => response.json()).then(data => {
      this.kwicData = data;
    }).then(() => {
      this._markAllMatches();

      this._showMatch(this.matchParam);
    }).catch(error => {
      console.error('Error retrieving remote content: ', error);
    });
  }

  _markAllMatches() {
    const docs = this.kwicData.documents;
    this.count = this.kwicData.hits;
    this.hits = docs[Object.keys(docs)[0]].hits; // 'jump over' docPid

    if (Array.isArray(this.hits)) {
      this.hits.forEach(hit => {
        const startId = hit.match.words[0];
        const endId = hit.match.words[1];

        this._addMarkerClasses(startId, endId);
      });
    } else {
      // ### it's just a single hit and we get object instead of array
      const startId = this.hits.match.words[0];
      const endId = this.hits.match.words[1];

      this._addMarkerClasses(startId, endId); // this._scrollTo(startId, endId);

    }

    this.requestUpdate();
  }

  _showMatch(matchId) {
    const matchObj = this._getMatchObject(matchId);

    this._navigateToMatch(matchObj);
  }
  /**
   * If a match id is given it will be looked up in the loaded data and returned.
   *
   * If no match is given the first match in the response will be used.
   *
   * @param match
   * @returns {[]|*}
   * @private
   */


  _getMatchObject(match) {
    // ### if there's no match param passed in from url return the appropriate object representing current match
    if (!match) {
      if (Array.isArray(this.hits)) {
        // return this.hits[0];
        return this.hits[this.current - 1];
      }

      return this.hits;
    }

    if (Array.isArray(this.hits)) {
      const targetHit = this.hits.find(hit => hit.match.words[0] === match);
      this.current = this.hits.findIndex(hit => hit === targetHit) + 1;
      return targetHit;
    }

    this.current = 1;
    return this.hits;
  }

  _navigateToMatch(matchObj) {
    const matchPage = matchObj.page[0];
    const matchId = matchObj.match.words[0];
    const newUrl = `${this._endpoint}/${this.docId}.xml?doc=${this.docId}&pattern=${this.pattern}&match=${matchObj.match.words[0]}&id=${matchPage}`;

    if (this.pageId !== matchPage) {
      this.emitTo('pb-refresh', {
        id: matchPage,
        match: matchId
      });
    } else {
      this._highlight(matchObj);

      window.history.replaceState({}, '', newUrl);
    }
  }

  _highlight(matchObj) {
    this._resetCurrentMarker();

    const startid = matchObj.match.words[0];
    const endid = matchObj.match.words[1];
    const startElem = this.shadow.querySelector(`#${startid}`);

    if (startElem) {
      startElem.parentNode.classList.add('kwic-current');
    }

    const endElem = this.shadow.querySelector(`#${endid}`);

    if (endElem) {
      endElem.parentNode.classList.add('kwic-current');
    }

    startElem.scrollIntoView({
      block: "center",
      inline: "nearest"
    });
  }

  _resetCurrentMarker() {
    const old = this.shadow.querySelectorAll('.kwic-current');
    Array.from(old).forEach(elem => {
      elem.classList.remove('kwic-current');
    });
  }

  _addMarkerClasses(startId, endId) {
    const start = this.shadow.querySelector(`#${startId}`);

    if (!start) {
      return;
    }

    start.parentNode.classList.add('kwic-start');
    const end = this.shadow.getElementById(endId);

    if (end) {
      end.parentNode.classList.add('kwic-end');
    } else {
      start.classList.add('kwic-end');
    }
  }

  _handlePrev() {
    this.current -= 1;
    const prevMatchObj = this.hits[this.current - 1];

    this._navigateToMatch(prevMatchObj);
  }

  _handleNext() {
    const nextMatchObj = this.hits[this.current];

    this._navigateToMatch(nextMatchObj);

    this.current += 1;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
            .counter, .current{
                padding:0 0.5rem;
            }

        `;
  }
  /*
      _handleClear(ev) {
          ev.preventDefault();
          localStorage.removeItem('pb-kwic-doc-matches');
      }
  */


}
customElements.define('pb-blacklab-highlight', PbBlacklabHighlight);

function t(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
  }
}

function e(e, n, r) {
  return n && t(e.prototype, n), r && t(e, r), e;
}

function n() {
  return (n = Object.assign || function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];

      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }

    return t;
  }).apply(this, arguments);
}

function r(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, i$1(t, e);
}

function i$1(t, e) {
  return (i$1 = Object.setPrototypeOf || function (t, e) {
    return t.__proto__ = e, t;
  })(t, e);
}

function o(t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}

function s(t, e) {
  (null == e || e > t.length) && (e = t.length);

  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];

  return r;
}

function a(t, e) {
  var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
  if (n) return (n = n.call(t)).next.bind(n);

  if (Array.isArray(t) || (n = function (t, e) {
    if (t) {
      if ("string" == typeof t) return s(t, e);
      var n = Object.prototype.toString.call(t).slice(8, -1);
      return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(t, e) : void 0;
    }
  }(t)) || e && t && "number" == typeof t.length) {
    n && (t = n);
    var r = 0;
    return function () {
      return r >= t.length ? {
        done: !0
      } : {
        done: !1,
        value: t[r++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var u,
    l,
    c,
    p,
    h,
    f,
    d = {},
    _ = [],
    m = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

function g(t, e) {
  for (var n in e) t[n] = e[n];

  return t;
}

function v(t) {
  var e = t.parentNode;
  e && e.removeChild(t);
}

function y(t, e, n) {
  var r,
      i,
      o,
      s = arguments,
      a = {};

  for (o in e) "key" == o ? r = e[o] : "ref" == o ? i = e[o] : a[o] = e[o];

  if (arguments.length > 3) for (n = [n], o = 3; o < arguments.length; o++) n.push(s[o]);
  if (null != n && (a.children = n), "function" == typeof t && null != t.defaultProps) for (o in t.defaultProps) void 0 === a[o] && (a[o] = t.defaultProps[o]);
  return b(t, a, r, i, null);
}

function b(t, e, n, r, i) {
  var o = {
    type: t,
    props: e,
    key: n,
    ref: r,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    __h: null,
    constructor: void 0,
    __v: null == i ? ++u.__v : i
  };
  return null != u.vnode && u.vnode(o), o;
}

function k(t) {
  return t.children;
}

function S(t, e) {
  this.props = t, this.context = e;
}

function C(t, e) {
  if (null == e) return t.__ ? C(t.__, t.__.__k.indexOf(t) + 1) : null;

  for (var n; e < t.__k.length; e++) if (null != (n = t.__k[e]) && null != n.__e) return n.__e;

  return "function" == typeof t.type ? C(t) : null;
}

function P(t) {
  var e, n;

  if (null != (t = t.__) && null != t.__c) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++) if (null != (n = t.__k[e]) && null != n.__e) {
      t.__e = t.__c.base = n.__e;
      break;
    }

    return P(t);
  }
}

function x(t) {
  (!t.__d && (t.__d = !0) && c.push(t) && !N.__r++ || h !== u.debounceRendering) && ((h = u.debounceRendering) || p)(N);
}

function N() {
  for (var t; N.__r = c.length;) t = c.sort(function (t, e) {
    return t.__v.__b - e.__v.__b;
  }), c = [], t.some(function (t) {
    var e, n, r, i, o, s;
    t.__d && (o = (i = (e = t).__v).__e, (s = e.__P) && (n = [], (r = g({}, i)).__v = i.__v + 1, A(s, i, r, e.__n, void 0 !== s.ownerSVGElement, null != i.__h ? [o] : null, n, null == o ? C(i) : o, i.__h), U(n, i), i.__e != o && P(i)));
  });
}

function E(t, e, n, r, i, o, s, a, u, l) {
  var c,
      p,
      h,
      f,
      m,
      g,
      v,
      y = r && r.__k || _,
      w = y.length;

  for (n.__k = [], c = 0; c < e.length; c++) if (null != (f = n.__k[c] = null == (f = e[c]) || "boolean" == typeof f ? null : "string" == typeof f || "number" == typeof f || "bigint" == typeof f ? b(null, f, null, null, f) : Array.isArray(f) ? b(k, {
    children: f
  }, null, null, null) : f.__b > 0 ? b(f.type, f.props, f.key, null, f.__v) : f)) {
    if (f.__ = n, f.__b = n.__b + 1, null === (h = y[c]) || h && f.key == h.key && f.type === h.type) y[c] = void 0;else for (p = 0; p < w; p++) {
      if ((h = y[p]) && f.key == h.key && f.type === h.type) {
        y[p] = void 0;
        break;
      }

      h = null;
    }
    A(t, f, h = h || d, i, o, s, a, u, l), m = f.__e, (p = f.ref) && h.ref != p && (v || (v = []), h.ref && v.push(h.ref, null, f), v.push(p, f.__c || m, f)), null != m ? (null == g && (g = m), "function" == typeof f.type && null != f.__k && f.__k === h.__k ? f.__d = u = F(f, u, t) : u = T(t, f, h, y, m, u), l || "option" !== n.type ? "function" == typeof n.type && (n.__d = u) : t.value = "") : u && h.__e == u && u.parentNode != t && (u = C(h));
  }

  for (n.__e = g, c = w; c--;) null != y[c] && ("function" == typeof n.type && null != y[c].__e && y[c].__e == n.__d && (n.__d = C(r, c + 1)), M(y[c], y[c]));

  if (v) for (c = 0; c < v.length; c++) H(v[c], v[++c], v[++c]);
}

function F(t, e, n) {
  var r, i;

  for (r = 0; r < t.__k.length; r++) (i = t.__k[r]) && (i.__ = t, e = "function" == typeof i.type ? F(i, e, n) : T(n, i, i, t.__k, i.__e, e));

  return e;
}

function T(t, e, n, r, i, o) {
  var s, a, u;
  if (void 0 !== e.__d) s = e.__d, e.__d = void 0;else if (null == n || i != o || null == i.parentNode) t: if (null == o || o.parentNode !== t) t.appendChild(i), s = null;else {
    for (a = o, u = 0; (a = a.nextSibling) && u < r.length; u += 2) if (a == i) break t;

    t.insertBefore(i, o), s = o;
  }
  return void 0 !== s ? s : i.nextSibling;
}

function D(t, e, n) {
  "-" === e[0] ? t.setProperty(e, n) : t[e] = null == n ? "" : "number" != typeof n || m.test(e) ? n : n + "px";
}

function R(t, e, n, r, i) {
  var o;

  t: if ("style" === e) {
    if ("string" == typeof n) t.style.cssText = n;else {
      if ("string" == typeof r && (t.style.cssText = r = ""), r) for (e in r) n && e in n || D(t.style, e, "");
      if (n) for (e in n) r && n[e] === r[e] || D(t.style, e, n[e]);
    }
  } else if ("o" === e[0] && "n" === e[1]) o = e !== (e = e.replace(/Capture$/, "")), e = e.toLowerCase() in t ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + o] = n, n ? r || t.addEventListener(e, o ? I : L, o) : t.removeEventListener(e, o ? I : L, o);else if ("dangerouslySetInnerHTML" !== e) {
    if (i) e = e.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== e && "list" !== e && "form" !== e && "tabIndex" !== e && "download" !== e && e in t) try {
      t[e] = null == n ? "" : n;
      break t;
    } catch (t) {}
    "function" == typeof n || (null != n && (!1 !== n || "a" === e[0] && "r" === e[1]) ? t.setAttribute(e, n) : t.removeAttribute(e));
  }
}

function L(t) {
  this.l[t.type + !1](u.event ? u.event(t) : t);
}

function I(t) {
  this.l[t.type + !0](u.event ? u.event(t) : t);
}

function A(t, e, n, r, i, o, s, a, l) {
  var c,
      p,
      h,
      f,
      m,
      y,
      b,
      w,
      C,
      P,
      x,
      N = e.type;
  if (void 0 !== e.constructor) return null;
  null != n.__h && (l = n.__h, a = e.__e = n.__e, e.__h = null, o = [a]), (c = u.__b) && c(e);

  try {
    t: if ("function" == typeof N) {
      if (w = e.props, C = (c = N.contextType) && r[c.__c], P = c ? C ? C.props.value : c.__ : r, n.__c ? b = (p = e.__c = n.__c).__ = p.__E : ("prototype" in N && N.prototype.render ? e.__c = p = new N(w, P) : (e.__c = p = new S(w, P), p.constructor = N, p.render = O), C && C.sub(p), p.props = w, p.state || (p.state = {}), p.context = P, p.__n = r, h = p.__d = !0, p.__h = []), null == p.__s && (p.__s = p.state), null != N.getDerivedStateFromProps && (p.__s == p.state && (p.__s = g({}, p.__s)), g(p.__s, N.getDerivedStateFromProps(w, p.__s))), f = p.props, m = p.state, h) null == N.getDerivedStateFromProps && null != p.componentWillMount && p.componentWillMount(), null != p.componentDidMount && p.__h.push(p.componentDidMount);else {
        if (null == N.getDerivedStateFromProps && w !== f && null != p.componentWillReceiveProps && p.componentWillReceiveProps(w, P), !p.__e && null != p.shouldComponentUpdate && !1 === p.shouldComponentUpdate(w, p.__s, P) || e.__v === n.__v) {
          p.props = w, p.state = p.__s, e.__v !== n.__v && (p.__d = !1), p.__v = e, e.__e = n.__e, e.__k = n.__k, e.__k.forEach(function (t) {
            t && (t.__ = e);
          }), p.__h.length && s.push(p);
          break t;
        }

        null != p.componentWillUpdate && p.componentWillUpdate(w, p.__s, P), null != p.componentDidUpdate && p.__h.push(function () {
          p.componentDidUpdate(f, m, y);
        });
      }
      p.context = P, p.props = w, p.state = p.__s, (c = u.__r) && c(e), p.__d = !1, p.__v = e, p.__P = t, c = p.render(p.props, p.state, p.context), p.state = p.__s, null != p.getChildContext && (r = g(g({}, r), p.getChildContext())), h || null == p.getSnapshotBeforeUpdate || (y = p.getSnapshotBeforeUpdate(f, m)), x = null != c && c.type === k && null == c.key ? c.props.children : c, E(t, Array.isArray(x) ? x : [x], e, n, r, i, o, s, a, l), p.base = e.__e, e.__h = null, p.__h.length && s.push(p), b && (p.__E = p.__ = null), p.__e = !1;
    } else null == o && e.__v === n.__v ? (e.__k = n.__k, e.__e = n.__e) : e.__e = function (t, e, n, r, i, o, s, a) {
      var u,
          l,
          c,
          p,
          h = n.props,
          f = e.props,
          m = e.type,
          g = 0;
      if ("svg" === m && (i = !0), null != o) for (; g < o.length; g++) if ((u = o[g]) && (u === t || (m ? u.localName == m : 3 == u.nodeType))) {
        t = u, o[g] = null;
        break;
      }

      if (null == t) {
        if (null === m) return document.createTextNode(f);
        t = i ? document.createElementNS("http://www.w3.org/2000/svg", m) : document.createElement(m, f.is && f), o = null, a = !1;
      }

      if (null === m) h === f || a && t.data === f || (t.data = f);else {
        if (o = o && _.slice.call(t.childNodes), l = (h = n.props || d).dangerouslySetInnerHTML, c = f.dangerouslySetInnerHTML, !a) {
          if (null != o) for (h = {}, p = 0; p < t.attributes.length; p++) h[t.attributes[p].name] = t.attributes[p].value;
          (c || l) && (c && (l && c.__html == l.__html || c.__html === t.innerHTML) || (t.innerHTML = c && c.__html || ""));
        }

        if (function (t, e, n, r, i) {
          var o;

          for (o in n) "children" === o || "key" === o || o in e || R(t, o, null, n[o], r);

          for (o in e) i && "function" != typeof e[o] || "children" === o || "key" === o || "value" === o || "checked" === o || n[o] === e[o] || R(t, o, e[o], n[o], r);
        }(t, f, h, i, a), c) e.__k = [];else if (g = e.props.children, E(t, Array.isArray(g) ? g : [g], e, n, r, i && "foreignObject" !== m, o, s, t.firstChild, a), null != o) for (g = o.length; g--;) null != o[g] && v(o[g]);
        a || ("value" in f && void 0 !== (g = f.value) && (g !== t.value || "progress" === m && !g) && R(t, "value", g, h.value, !1), "checked" in f && void 0 !== (g = f.checked) && g !== t.checked && R(t, "checked", g, h.checked, !1));
      }
      return t;
    }(n.__e, e, n, r, i, o, s, l);

    (c = u.diffed) && c(e);
  } catch (t) {
    e.__v = null, (l || null != o) && (e.__e = a, e.__h = !!l, o[o.indexOf(a)] = null), u.__e(t, e, n);
  }
}

function U(t, e) {
  u.__c && u.__c(e, t), t.some(function (e) {
    try {
      t = e.__h, e.__h = [], t.some(function (t) {
        t.call(e);
      });
    } catch (t) {
      u.__e(t, e.__v);
    }
  });
}

function H(t, e, n) {
  try {
    "function" == typeof t ? t(e) : t.current = e;
  } catch (t) {
    u.__e(t, n);
  }
}

function M(t, e, n) {
  var r, i, o;

  if (u.unmount && u.unmount(t), (r = t.ref) && (r.current && r.current !== t.__e || H(r, null, e)), n || "function" == typeof t.type || (n = null != (i = t.__e)), t.__e = t.__d = void 0, null != (r = t.__c)) {
    if (r.componentWillUnmount) try {
      r.componentWillUnmount();
    } catch (t) {
      u.__e(t, e);
    }
    r.base = r.__P = null;
  }

  if (r = t.__k) for (o = 0; o < r.length; o++) r[o] && M(r[o], e, n);
  null != i && v(i);
}

function O(t, e, n) {
  return this.constructor(t, n);
}

function j(t, e, n) {
  var r, i, o;
  u.__ && u.__(t, e), i = (r = "function" == typeof n) ? null : n && n.__k || e.__k, o = [], A(e, t = (!r && n || e).__k = y(k, null, [t]), i || d, d, void 0 !== e.ownerSVGElement, !r && n ? [n] : i ? null : e.firstChild ? _.slice.call(e.childNodes) : null, o, !r && n ? n : i ? i.__e : e.firstChild, r), U(o, t);
}

function W() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t) {
    var e = 16 * Math.random() | 0;
    return ("x" == t ? e : 3 & e | 8).toString(16);
  });
}

u = {
  __e: function (t, e) {
    for (var n, r, i; e = e.__;) if ((n = e.__c) && !n.__) try {
      if ((r = n.constructor) && null != r.getDerivedStateFromError && (n.setState(r.getDerivedStateFromError(t)), i = n.__d), null != n.componentDidCatch && (n.componentDidCatch(t), i = n.__d), i) return n.__E = n;
    } catch (e) {
      t = e;
    }

    throw t;
  },
  __v: 0
}, l = function (t) {
  return null != t && void 0 === t.constructor;
}, S.prototype.setState = function (t, e) {
  var n;
  n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = g({}, this.state), "function" == typeof t && (t = t(g({}, n), this.props)), t && g(n, t), null != t && this.__v && (e && this.__h.push(e), x(this));
}, S.prototype.forceUpdate = function (t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), x(this));
}, S.prototype.render = k, c = [], p = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, N.__r = 0, f = 0;

var B = function () {
  function t(t) {
    this._id = void 0, this._id = t || W();
  }

  return e(t, [{
    key: "id",
    get: function () {
      return this._id;
    }
  }]), t;
}(),
    z = {
  search: {
    placeholder: "Type a keyword..."
  },
  sort: {
    sortAsc: "Sort column ascending",
    sortDesc: "Sort column descending"
  },
  pagination: {
    previous: "Previous",
    next: "Next",
    navigate: function (t, e) {
      return "Page " + t + " of " + e;
    },
    page: function (t) {
      return "Page " + t;
    },
    showing: "Showing",
    of: "of",
    to: "to",
    results: "results"
  },
  loading: "Loading...",
  noRecordsFound: "No matching records found",
  error: "An error happened while fetching the data"
},
    q = function () {
  function t(t) {
    this._language = void 0, this._defaultLanguage = void 0, this._language = t, this._defaultLanguage = z;
  }

  var e = t.prototype;
  return e.getString = function (t, e) {
    if (!e || !t) return null;
    var n = t.split("."),
        r = n[0];

    if (e[r]) {
      var i = e[r];
      return "string" == typeof i ? function () {
        return i;
      } : "function" == typeof i ? i : this.getString(n.slice(1).join("."), i);
    }

    return null;
  }, e.translate = function (t) {
    var e,
        n = this.getString(t, this._language);
    return (e = n || this.getString(t, this._defaultLanguage)) ? e.apply(void 0, [].slice.call(arguments, 1)) : t;
  }, t;
}(),
    G = function (t) {
  function e(e, n) {
    var r, i;
    return (r = t.call(this, e, n) || this).config = void 0, r._ = void 0, r.config = function (t) {
      if (!t) return null;
      var e = Object.keys(t);
      return e.length ? t[e[0]].props.value : null;
    }(n), r.config && (r._ = (i = r.config.translator, function (t) {
      return i.translate.apply(i, [t].concat([].slice.call(arguments, 1)));
    })), r;
  }

  return r(e, t), e;
}(S),
    X = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  return r(e, t), e.prototype.render = function () {
    return y(this.props.parentElement, {
      dangerouslySetInnerHTML: {
        __html: this.props.content
      }
    });
  }, e;
}(G);

function $(t, e) {
  return y(X, {
    content: t,
    parentElement: e
  });
}

X.defaultProps = {
  parentElement: "span"
};

var K,
    V = function (t) {
  function e(e) {
    var n;
    return (n = t.call(this) || this).data = void 0, n.update(e), n;
  }

  r(e, t);
  var n = e.prototype;
  return n.cast = function (t) {
    return t instanceof HTMLElement ? $(t.outerHTML) : t;
  }, n.update = function (t) {
    return this.data = this.cast(t), this;
  }, e;
}(B),
    Y = function (t) {
  function n(e) {
    var n;
    return (n = t.call(this) || this)._cells = void 0, n.cells = e || [], n;
  }

  r(n, t);
  var i = n.prototype;
  return i.cell = function (t) {
    return this._cells[t];
  }, i.toArray = function () {
    return this.cells.map(function (t) {
      return t.data;
    });
  }, n.fromCells = function (t) {
    return new n(t.map(function (t) {
      return new V(t.data);
    }));
  }, e(n, [{
    key: "cells",
    get: function () {
      return this._cells;
    },
    set: function (t) {
      this._cells = t;
    }
  }, {
    key: "length",
    get: function () {
      return this.cells.length;
    }
  }]), n;
}(B),
    Z = function (t) {
  function n(e) {
    var n;
    return (n = t.call(this) || this)._rows = void 0, n._length = void 0, n.rows = e instanceof Array ? e : e instanceof Y ? [e] : [], n;
  }

  return r(n, t), n.prototype.toArray = function () {
    return this.rows.map(function (t) {
      return t.toArray();
    });
  }, n.fromRows = function (t) {
    return new n(t.map(function (t) {
      return Y.fromCells(t.cells);
    }));
  }, n.fromArray = function (t) {
    return new n((t = function (t) {
      return !t[0] || t[0] instanceof Array ? t : [t];
    }(t)).map(function (t) {
      return new Y(t.map(function (t) {
        return new V(t);
      }));
    }));
  }, e(n, [{
    key: "rows",
    get: function () {
      return this._rows;
    },
    set: function (t) {
      this._rows = t;
    }
  }, {
    key: "length",
    get: function () {
      return this._length || this.rows.length;
    },
    set: function (t) {
      this._length = t;
    }
  }]), n;
}(B),
    J = function () {
  function t() {
    this.callbacks = void 0;
  }

  var e = t.prototype;
  return e.init = function (t) {
    this.callbacks || (this.callbacks = {}), t && !this.callbacks[t] && (this.callbacks[t] = []);
  }, e.on = function (t, e) {
    return this.init(t), this.callbacks[t].push(e), this;
  }, e.off = function (t, e) {
    var n = t;
    return this.init(), this.callbacks[n] && 0 !== this.callbacks[n].length ? (this.callbacks[n] = this.callbacks[n].filter(function (t) {
      return t != e;
    }), this) : this;
  }, e.emit = function (t) {
    var e = arguments,
        n = t;
    return this.init(n), this.callbacks[n].length > 0 && (this.callbacks[n].forEach(function (t) {
      return t.apply(void 0, [].slice.call(e, 1));
    }), !0);
  }, t;
}();

!function (t) {
  t[t.Initiator = 0] = "Initiator", t[t.ServerFilter = 1] = "ServerFilter", t[t.ServerSort = 2] = "ServerSort", t[t.ServerLimit = 3] = "ServerLimit", t[t.Extractor = 4] = "Extractor", t[t.Transformer = 5] = "Transformer", t[t.Filter = 6] = "Filter", t[t.Sort = 7] = "Sort", t[t.Limit = 8] = "Limit";
}(K || (K = {}));

var Q = function (t) {
  function n(e) {
    var n;
    return (n = t.call(this) || this).id = void 0, n._props = void 0, n._props = {}, n.id = W(), e && n.setProps(e), n;
  }

  r(n, t);
  var i = n.prototype;
  return i.process = function () {
    var t = [].slice.call(arguments);
    this.validateProps instanceof Function && this.validateProps.apply(this, t), this.emit.apply(this, ["beforeProcess"].concat(t));

    var e = this._process.apply(this, t);

    return this.emit.apply(this, ["afterProcess"].concat(t)), e;
  }, i.setProps = function (t) {
    return Object.assign(this._props, t), this.emit("propsUpdated", this), this;
  }, e(n, [{
    key: "props",
    get: function () {
      return this._props;
    }
  }]), n;
}(J),
    tt = function (t) {
  function n() {
    return t.apply(this, arguments) || this;
  }

  return r(n, t), n.prototype._process = function (t) {
    return this.props.keyword ? (e = String(this.props.keyword).trim(), n = this.props.columns, r = this.props.ignoreHiddenColumns, i = t, o = this.props.selector, e = e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), new Z(i.rows.filter(function (t, i) {
      return t.cells.some(function (t, s) {
        if (!t) return !1;
        if (r && n && n[s] && "object" == typeof n[s] && n[s].hidden) return !1;
        var a = "";
        if ("function" == typeof o) a = o(t.data, i, s);else if ("object" == typeof t.data) {
          var u = t.data;
          u && u.props && u.props.content && (a = u.props.content);
        } else a = String(t.data);
        return new RegExp(e, "gi").test(a);
      });
    }))) : t;
    var e, n, r, i, o;
  }, e(n, [{
    key: "type",
    get: function () {
      return K.Filter;
    }
  }]), n;
}(Q);

function et() {
  var t = "gridjs";
  return "" + t + [].slice.call(arguments).reduce(function (t, e) {
    return t + "-" + e;
  }, "");
}

function nt() {
  return [].slice.call(arguments).filter(function (t) {
    return t;
  }).reduce(function (t, e) {
    return (t || "") + " " + e;
  }, "").trim() || null;
}

var rt,
    it = function (t) {
  function n(e) {
    var n;
    return (n = t.call(this) || this)._state = void 0, n.dispatcher = void 0, n.dispatcher = e, n._state = n.getInitialState(), e.register(n._handle.bind(o(n))), n;
  }

  r(n, t);
  var i = n.prototype;
  return i._handle = function (t) {
    this.handle(t.type, t.payload);
  }, i.setState = function (t) {
    var e = this._state;
    this._state = t, this.emit("updated", t, e);
  }, e(n, [{
    key: "state",
    get: function () {
      return this._state;
    }
  }]), n;
}(J),
    ot = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var n = e.prototype;
  return n.getInitialState = function () {
    return {
      keyword: null
    };
  }, n.handle = function (t, e) {
    "SEARCH_KEYWORD" === t && this.search(e.keyword);
  }, n.search = function (t) {
    this.setState({
      keyword: t
    });
  }, e;
}(it),
    st = function () {
  function t(t) {
    this.dispatcher = void 0, this.dispatcher = t;
  }

  return t.prototype.dispatch = function (t, e) {
    this.dispatcher.dispatch({
      type: t,
      payload: e
    });
  }, t;
}(),
    at = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  return r(e, t), e.prototype.search = function (t) {
    this.dispatch("SEARCH_KEYWORD", {
      keyword: t
    });
  }, e;
}(st),
    ut = function (t) {
  function i() {
    return t.apply(this, arguments) || this;
  }

  return r(i, t), i.prototype._process = function (t) {
    if (!this.props.keyword) return t;
    var e = {};
    return this.props.url && (e.url = this.props.url(t.url, this.props.keyword)), this.props.body && (e.body = this.props.body(t.body, this.props.keyword)), n({}, t, e);
  }, e(i, [{
    key: "type",
    get: function () {
      return K.ServerFilter;
    }
  }]), i;
}(Q),
    lt = new (function () {
  function t() {}

  var e = t.prototype;
  return e.format = function (t, e) {
    return "[Grid.js] [" + e.toUpperCase() + "]: " + t;
  }, e.error = function (t, e) {
    void 0 === e && (e = !1);
    var n = this.format(t, "error");
    if (e) throw Error(n);
    console.error(n);
  }, e.warn = function (t) {
    console.warn(this.format(t, "warn"));
  }, e.info = function (t) {
    console.info(this.format(t, "info"));
  }, t;
}())(),
    ct = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  return r(e, t), e;
}(G);

!function (t) {
  t[t.Header = 0] = "Header", t[t.Footer = 1] = "Footer", t[t.Cell = 2] = "Cell";
}(rt || (rt = {}));

var pt = function () {
  function t() {
    this.plugins = void 0, this.plugins = [];
  }

  var e = t.prototype;
  return e.get = function (t) {
    var e = this.plugins.filter(function (e) {
      return e.id === t;
    });
    return e.length > 0 ? e[0] : null;
  }, e.add = function (t) {
    return t.id ? null !== this.get(t.id) ? (lt.error("Duplicate plugin ID: " + t.id), this) : (this.plugins.push(t), this) : (lt.error("Plugin ID cannot be empty"), this);
  }, e.remove = function (t) {
    return this.plugins.splice(this.plugins.indexOf(this.get(t)), 1), this;
  }, e.list = function (t) {
    return (null != t || null != t ? this.plugins.filter(function (e) {
      return e.position === t;
    }) : this.plugins).sort(function (t, e) {
      return t.order - e.order;
    });
  }, t;
}(),
    ht = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  return r(e, t), e.prototype.render = function () {
    var t = this;

    if (this.props.pluginId) {
      var e = this.config.plugin.get(this.props.pluginId);
      return e ? y(k, {}, y(e.component, n({
        plugin: e
      }, e.props, this.props.props))) : null;
    }

    return void 0 !== this.props.position ? y(k, {}, this.config.plugin.list(this.props.position).map(function (e) {
      return y(e.component, n({
        plugin: e
      }, e.props, t.props.props));
    })) : null;
  }, e;
}(G),
    ft = function (t) {
  function e(e, n) {
    var r;
    (r = t.call(this, e, n) || this).searchProcessor = void 0, r.actions = void 0, r.store = void 0, r.storeUpdatedFn = void 0, r.actions = new at(r.config.dispatcher), r.store = new ot(r.config.dispatcher);
    var i,
        s = e.keyword;
    return e.enabled && (s && r.actions.search(s), r.storeUpdatedFn = r.storeUpdated.bind(o(r)), r.store.on("updated", r.storeUpdatedFn), i = e.server ? new ut({
      keyword: e.keyword,
      url: e.server.url,
      body: e.server.body
    }) : new tt({
      keyword: e.keyword,
      columns: r.config.header && r.config.header.columns,
      ignoreHiddenColumns: e.ignoreHiddenColumns || void 0 === e.ignoreHiddenColumns,
      selector: e.selector
    }), r.searchProcessor = i, r.config.pipeline.register(i)), r;
  }

  r(e, t);
  var n = e.prototype;
  return n.componentWillUnmount = function () {
    this.config.pipeline.unregister(this.searchProcessor), this.store.off("updated", this.storeUpdatedFn);
  }, n.storeUpdated = function (t) {
    this.searchProcessor.setProps({
      keyword: t.keyword
    });
  }, n.onChange = function (t) {
    this.actions.search(t.target.value);
  }, n.render = function () {
    if (!this.props.enabled) return null;
    var t,
        e,
        n,
        r = this.onChange.bind(this);
    return this.searchProcessor instanceof ut && (t = r, e = this.props.debounceTimeout, r = function () {
      var r = arguments;
      return new Promise(function (i) {
        n && clearTimeout(n), n = setTimeout(function () {
          return i(t.apply(void 0, [].slice.call(r)));
        }, e);
      });
    }), y("div", {
      className: et(nt("search", this.config.className.search))
    }, y("input", {
      type: "search",
      placeholder: this._("search.placeholder"),
      "aria-label": this._("search.placeholder"),
      onInput: r,
      className: nt(et("input"), et("search", "input")),
      value: this.store.state.keyword
    }));
  }, e;
}(ct);

ft.defaultProps = {
  debounceTimeout: 250
};

var dt = function (t) {
  function n() {
    return t.apply(this, arguments) || this;
  }

  r(n, t);
  var i = n.prototype;
  return i.validateProps = function () {
    if (isNaN(Number(this.props.limit)) || isNaN(Number(this.props.page))) throw Error("Invalid parameters passed");
  }, i._process = function (t) {
    var e = this.props.page;
    return new Z(t.rows.slice(e * this.props.limit, (e + 1) * this.props.limit));
  }, e(n, [{
    key: "type",
    get: function () {
      return K.Limit;
    }
  }]), n;
}(Q),
    _t = function (t) {
  function i() {
    return t.apply(this, arguments) || this;
  }

  return r(i, t), i.prototype._process = function (t) {
    var e = {};
    return this.props.url && (e.url = this.props.url(t.url, this.props.page, this.props.limit)), this.props.body && (e.body = this.props.body(t.body, this.props.page, this.props.limit)), n({}, t, e);
  }, e(i, [{
    key: "type",
    get: function () {
      return K.ServerLimit;
    }
  }]), i;
}(Q),
    mt = function (t) {
  function n(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).processor = void 0, r.onUpdateFn = void 0, r.setTotalFromTabularFn = void 0, r.state = {
      limit: e.limit,
      page: e.page || 0,
      total: 0
    }, r;
  }

  r(n, t);
  var i = n.prototype;
  return i.componentWillMount = function () {
    var t,
        e = this;
    this.props.enabled && (this.setTotalFromTabularFn = this.setTotalFromTabular.bind(this), this.props.server ? (t = new _t({
      limit: this.state.limit,
      page: this.state.page,
      url: this.props.server.url,
      body: this.props.server.body
    }), this.config.pipeline.on("afterProcess", this.setTotalFromTabularFn)) : (t = new dt({
      limit: this.state.limit,
      page: this.state.page
    })).on("beforeProcess", this.setTotalFromTabularFn), this.processor = t, this.config.pipeline.register(t), this.config.pipeline.on("error", function () {
      e.setState({
        total: 0,
        page: 0
      });
    }));
  }, i.setTotalFromTabular = function (t) {
    this.setTotal(t.length);
  }, i.onUpdate = function (t) {
    this.props.resetPageOnUpdate && t !== this.processor && this.setPage(0);
  }, i.componentDidMount = function () {
    this.onUpdateFn = this.onUpdate.bind(this), this.config.pipeline.on("updated", this.onUpdateFn);
  }, i.componentWillUnmount = function () {
    this.config.pipeline.unregister(this.processor), this.config.pipeline.off("updated", this.onUpdateFn);
  }, i.setPage = function (t) {
    if (t >= this.pages || t < 0 || t === this.state.page) return null;
    this.setState({
      page: t
    }), this.processor.setProps({
      page: t
    });
  }, i.setTotal = function (t) {
    this.setState({
      total: t
    });
  }, i.renderPages = function () {
    var t = this;
    if (this.props.buttonsCount <= 0) return null;
    var e = Math.min(this.pages, this.props.buttonsCount),
        n = Math.min(this.state.page, Math.floor(e / 2));
    return this.state.page + Math.floor(e / 2) >= this.pages && (n = e - (this.pages - this.state.page)), y(k, null, this.pages > e && this.state.page - n > 0 && y(k, null, y("button", {
      tabIndex: 0,
      role: "button",
      onClick: this.setPage.bind(this, 0),
      title: this._("pagination.firstPage"),
      "aria-label": this._("pagination.firstPage"),
      className: this.config.className.paginationButton
    }, this._("1")), y("button", {
      tabIndex: -1,
      className: nt(et("spread"), this.config.className.paginationButton)
    }, "...")), Array.from(Array(e).keys()).map(function (e) {
      return t.state.page + (e - n);
    }).map(function (e) {
      return y("button", {
        tabIndex: 0,
        role: "button",
        onClick: t.setPage.bind(t, e),
        className: nt(t.state.page === e ? nt(et("currentPage"), t.config.className.paginationButtonCurrent) : null, t.config.className.paginationButton),
        title: t._("pagination.page", e + 1),
        "aria-label": t._("pagination.page", e + 1)
      }, t._("" + (e + 1)));
    }), this.pages > e && this.pages > this.state.page + n + 1 && y(k, null, y("button", {
      tabIndex: -1,
      className: nt(et("spread"), this.config.className.paginationButton)
    }, "..."), y("button", {
      tabIndex: 0,
      role: "button",
      onClick: this.setPage.bind(this, this.pages - 1),
      title: this._("pagination.page", this.pages),
      "aria-label": this._("pagination.page", this.pages),
      className: this.config.className.paginationButton
    }, this._("" + this.pages))));
  }, i.renderSummary = function () {
    return y(k, null, this.props.summary && this.state.total > 0 && y("div", {
      role: "status",
      "aria-live": "polite",
      className: nt(et("summary"), this.config.className.paginationSummary),
      title: this._("pagination.navigate", this.state.page + 1, this.pages)
    }, this._("pagination.showing"), " ", y("b", null, this._("" + (this.state.page * this.state.limit + 1))), " ", this._("pagination.to"), " ", y("b", null, this._("" + Math.min((this.state.page + 1) * this.state.limit, this.state.total))), " ", this._("pagination.of"), " ", y("b", null, this._("" + this.state.total)), " ", this._("pagination.results")));
  }, i.render = function () {
    return this.props.enabled ? y("div", {
      className: nt(et("pagination"), this.config.className.pagination)
    }, this.renderSummary(), y("div", {
      className: et("pages")
    }, this.props.prevButton && y("button", {
      tabIndex: 0,
      role: "button",
      disabled: 0 === this.state.page,
      onClick: this.setPage.bind(this, this.state.page - 1),
      title: this._("pagination.previous"),
      "aria-label": this._("pagination.previous"),
      className: nt(this.config.className.paginationButton, this.config.className.paginationButtonPrev)
    }, this._("pagination.previous")), this.renderPages(), this.props.nextButton && y("button", {
      tabIndex: 0,
      role: "button",
      disabled: this.pages === this.state.page + 1 || 0 === this.pages,
      onClick: this.setPage.bind(this, this.state.page + 1),
      title: this._("pagination.next"),
      "aria-label": this._("pagination.next"),
      className: nt(this.config.className.paginationButton, this.config.className.paginationButtonNext)
    }, this._("pagination.next")))) : null;
  }, e(n, [{
    key: "pages",
    get: function () {
      return Math.ceil(this.state.total / this.state.limit);
    }
  }]), n;
}(ct);

function gt(t, e) {
  return "string" == typeof t ? t.indexOf("%") > -1 ? e / 100 * parseInt(t, 10) : parseInt(t, 10) : t;
}

function vt(t) {
  return t ? Math.floor(t) + "px" : "";
}

mt.defaultProps = {
  summary: !0,
  nextButton: !0,
  prevButton: !0,
  buttonsCount: 3,
  limit: 10,
  resetPageOnUpdate: !0
};

var yt = function (t) {
  function e(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).tableElement = void 0, r.tableClassName = void 0, r.tableStyle = void 0, r.tableElement = r.props.tableRef.current.base.cloneNode(!0), r.tableElement.style.position = "absolute", r.tableElement.style.width = "100%", r.tableElement.style.zIndex = "-2147483640", r.tableElement.style.visibility = "hidden", r.tableClassName = r.tableElement.className, r.tableStyle = r.tableElement.style.cssText, r;
  }

  r(e, t);
  var i = e.prototype;
  return i.widths = function () {
    this.tableElement.className = this.tableClassName + " " + et("shadowTable"), this.tableElement.style.tableLayout = "auto", this.tableElement.style.width = "auto", this.tableElement.style.padding = "0", this.tableElement.style.margin = "0", this.tableElement.style.border = "none", this.tableElement.style.outline = "none";
    var t = Array.from(this.base.parentNode.querySelectorAll("thead th")).reduce(function (t, e) {
      var r;
      return e.style.width = e.clientWidth + "px", n(((r = {})[e.getAttribute("data-column-id")] = {
        minWidth: e.clientWidth
      }, r), t);
    }, {});
    return this.tableElement.className = this.tableClassName, this.tableElement.style.cssText = this.tableStyle, this.tableElement.style.tableLayout = "auto", Array.from(this.base.parentNode.querySelectorAll("thead th")).reduce(function (t, e) {
      return t[e.getAttribute("data-column-id")].width = e.clientWidth, t;
    }, t);
  }, i.render = function () {
    var t = this;
    return this.props.tableRef.current ? y("div", {
      ref: function (e) {
        e && e.appendChild(t.tableElement);
      }
    }) : null;
  }, e;
}(G);

function bt(t) {
  if (!t) return "";
  var e = t.split(" ");
  return 1 === e.length && /([a-z][A-Z])+/g.test(t) ? t : e.map(function (t, e) {
    return 0 == e ? t.toLowerCase() : t.charAt(0).toUpperCase() + t.slice(1).toLowerCase();
  }).join("");
}

var wt = function (t) {
  function i() {
    var e;
    return (e = t.call(this) || this)._columns = void 0, e._columns = [], e;
  }

  r(i, t);
  var o = i.prototype;
  return o.adjustWidth = function (t) {
    var e = t.container,
        n = t.tableRef,
        r = t.tempRef,
        o = t.tempRef || !0;
    if (!e) return this;
    var s = e.clientWidth,
        u = {
      current: null
    },
        l = {};

    if (n.current && o) {
      var c = y(yt, {
        tableRef: n
      });
      c.ref = u, j(c, r.current), l = u.current.widths();
    }

    for (var p, h = a(i.tabularFormat(this.columns).reduce(function (t, e) {
      return t.concat(e);
    }, [])); !(p = h()).done;) {
      var f = p.value;
      f.columns && f.columns.length > 0 || (!f.width && o ? f.id in l && (f.width = vt(l[f.id].width), f.minWidth = vt(l[f.id].minWidth)) : f.width = vt(gt(f.width, s)));
    }

    return n.current && o && j(null, r.current), this;
  }, o.setSort = function (t, e) {
    for (var r, i = a(e || this.columns || []); !(r = i()).done;) {
      var o = r.value;
      o.columns && o.columns.length > 0 && (o.sort = {
        enabled: !1
      }), void 0 === o.sort && t.sort && (o.sort = {
        enabled: !0
      }), o.sort ? "object" == typeof o.sort && (o.sort = n({
        enabled: !0
      }, o.sort)) : o.sort = {
        enabled: !1
      }, o.columns && this.setSort(t, o.columns);
    }
  }, o.setFixedHeader = function (t, e) {
    for (var n, r = a(e || this.columns || []); !(n = r()).done;) {
      var i = n.value;
      void 0 === i.fixedHeader && (i.fixedHeader = t.fixedHeader), i.columns && this.setFixedHeader(t, i.columns);
    }
  }, o.setResizable = function (t, e) {
    for (var n, r = a(e || this.columns || []); !(n = r()).done;) {
      var i = n.value;
      void 0 === i.resizable && (i.resizable = t.resizable), i.columns && this.setResizable(t, i.columns);
    }
  }, o.setID = function (t) {
    for (var e, n = a(t || this.columns || []); !(e = n()).done;) {
      var r = e.value;
      r.id || "string" != typeof r.name || (r.id = bt(r.name)), r.id || lt.error('Could not find a valid ID for one of the columns. Make sure a valid "id" is set for all columns.'), r.columns && this.setID(r.columns);
    }
  }, o.populatePlugins = function (t, e) {
    for (var r, i = a(e); !(r = i()).done;) {
      var o = r.value;
      void 0 !== o.plugin && t.plugin.add(n({
        id: o.id,
        props: {}
      }, o.plugin, {
        position: rt.Cell
      }));
    }
  }, i.fromColumns = function (t) {
    for (var e, n = new i(), r = a(t); !(e = r()).done;) {
      var o = e.value;
      if ("string" == typeof o || l(o)) n.columns.push({
        name: o
      });else if ("object" == typeof o) {
        var s = o;
        s.columns && (s.columns = i.fromColumns(s.columns).columns), "object" == typeof s.plugin && void 0 === s.data && (s.data = null), n.columns.push(o);
      }
    }

    return n;
  }, i.fromUserConfig = function (t) {
    var e = new i();
    return t.from ? e.columns = i.fromHTMLTable(t.from).columns : t.columns ? e.columns = i.fromColumns(t.columns).columns : !t.data || "object" != typeof t.data[0] || t.data[0] instanceof Array || (e.columns = Object.keys(t.data[0]).map(function (t) {
      return {
        name: t
      };
    })), e.columns.length ? (e.setID(), e.setSort(t), e.setFixedHeader(t), e.setResizable(t), e.populatePlugins(t, e.columns), e) : null;
  }, i.fromHTMLTable = function (t) {
    for (var e, n = new i(), r = a(t.querySelector("thead").querySelectorAll("th")); !(e = r()).done;) {
      var o = e.value;
      n.columns.push({
        name: o.innerHTML,
        width: o.width
      });
    }

    return n;
  }, i.tabularFormat = function (t) {
    var e = [],
        n = t || [],
        r = [];

    if (n && n.length) {
      e.push(n);

      for (var i, o = a(n); !(i = o()).done;) {
        var s = i.value;
        s.columns && s.columns.length && (r = r.concat(s.columns));
      }

      r.length && (e = e.concat(this.tabularFormat(r)));
    }

    return e;
  }, i.leafColumns = function (t) {
    var e = [],
        n = t || [];
    if (n && n.length) for (var r, i = a(n); !(r = i()).done;) {
      var o = r.value;
      o.columns && 0 !== o.columns.length || e.push(o), o.columns && (e = e.concat(this.leafColumns(o.columns)));
    }
    return e;
  }, i.maximumDepth = function (t) {
    return this.tabularFormat([t]).length - 1;
  }, e(i, [{
    key: "columns",
    get: function () {
      return this._columns;
    },
    set: function (t) {
      this._columns = t;
    }
  }, {
    key: "visibleColumns",
    get: function () {
      return this._columns.filter(function (t) {
        return !t.hidden;
      });
    }
  }]), i;
}(B),
    kt = function () {
  function t() {
    this._callbacks = void 0, this._isDispatching = void 0, this._isHandled = void 0, this._isPending = void 0, this._lastID = void 0, this._pendingPayload = void 0, this._callbacks = {}, this._isDispatching = !1, this._isHandled = {}, this._isPending = {}, this._lastID = 1;
  }

  var e = t.prototype;
  return e.register = function (t) {
    var e = "ID_" + this._lastID++;
    return this._callbacks[e] = t, e;
  }, e.unregister = function (t) {
    if (!this._callbacks[t]) throw Error("Dispatcher.unregister(...): " + t + " does not map to a registered callback.");
    delete this._callbacks[t];
  }, e.waitFor = function (t) {
    if (!this._isDispatching) throw Error("Dispatcher.waitFor(...): Must be invoked while dispatching.");

    for (var e = 0; e < t.length; e++) {
      var n = t[e];

      if (this._isPending[n]) {
        if (!this._isHandled[n]) throw Error("Dispatcher.waitFor(...): Circular dependency detected while ' +\n            'waiting for " + n + ".");
      } else {
        if (!this._callbacks[n]) throw Error("Dispatcher.waitFor(...): " + n + " does not map to a registered callback.");

        this._invokeCallback(n);
      }
    }
  }, e.dispatch = function (t) {
    if (this._isDispatching) throw Error("Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.");

    this._startDispatching(t);

    try {
      for (var e in this._callbacks) this._isPending[e] || this._invokeCallback(e);
    } finally {
      this._stopDispatching();
    }
  }, e.isDispatching = function () {
    return this._isDispatching;
  }, e._invokeCallback = function (t) {
    this._isPending[t] = !0, this._callbacks[t](this._pendingPayload), this._isHandled[t] = !0;
  }, e._startDispatching = function (t) {
    for (var e in this._callbacks) this._isPending[e] = !1, this._isHandled[e] = !1;

    this._pendingPayload = t, this._isDispatching = !0;
  }, e._stopDispatching = function () {
    delete this._pendingPayload, this._isDispatching = !1;
  }, t;
}(),
    St = function () {},
    Ct = function (t) {
  function e(e) {
    var n;
    return (n = t.call(this) || this).data = void 0, n.set(e), n;
  }

  r(e, t);
  var n = e.prototype;
  return n.get = function () {
    try {
      return Promise.resolve(this.data()).then(function (t) {
        return {
          data: t,
          total: t.length
        };
      });
    } catch (t) {
      return Promise.reject(t);
    }
  }, n.set = function (t) {
    return t instanceof Array ? this.data = function () {
      return t;
    } : t instanceof Function && (this.data = t), this;
  }, e;
}(St),
    Pt = function (t) {
  function e(e) {
    var n;
    return (n = t.call(this) || this).options = void 0, n.options = e, n;
  }

  r(e, t);
  var i = e.prototype;
  return i.handler = function (t) {
    return "function" == typeof this.options.handle ? this.options.handle(t) : t.ok ? t.json() : (lt.error("Could not fetch data: " + t.status + " - " + t.statusText, !0), null);
  }, i.get = function (t) {
    var e = n({}, this.options, t);
    return "function" == typeof e.data ? e.data(e) : fetch(e.url, e).then(this.handler.bind(this)).then(function (t) {
      return {
        data: e.then(t),
        total: "function" == typeof e.total ? e.total(t) : void 0
      };
    });
  }, e;
}(St),
    xt = function () {
  function t() {}

  return t.createFromUserConfig = function (t) {
    var e = null;
    return t.data && (e = new Ct(t.data)), t.from && (e = new Ct(this.tableElementToArray(t.from)), t.from.style.display = "none"), t.server && (e = new Pt(t.server)), e || lt.error("Could not determine the storage type", !0), e;
  }, t.tableElementToArray = function (t) {
    for (var e, n, r = [], i = a(t.querySelector("tbody").querySelectorAll("tr")); !(e = i()).done;) {
      for (var o, s = [], u = a(e.value.querySelectorAll("td")); !(o = u()).done;) {
        var l = o.value;
        1 === l.childNodes.length && l.childNodes[0].nodeType === Node.TEXT_NODE ? s.push((n = l.innerHTML, new DOMParser().parseFromString(n, "text/html").documentElement.textContent)) : s.push($(l.innerHTML));
      }

      r.push(s);
    }

    return r;
  }, t;
}(),
    Nt = "undefined" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

function Et(t, e, n) {
  if (!t.s) {
    if (n instanceof Ft) {
      if (!n.s) return void (n.o = Et.bind(null, t, e));
      1 & e && (e = n.s), n = n.v;
    }

    if (n && n.then) return void n.then(Et.bind(null, t, e), Et.bind(null, t, 2));
    t.s = e, t.v = n;
    var r = t.o;
    r && r(t);
  }
}

var Ft = function () {
  function t() {}

  return t.prototype.then = function (e, n) {
    var r = new t(),
        i = this.s;

    if (i) {
      var o = 1 & i ? e : n;

      if (o) {
        try {
          Et(r, 1, o(this.v));
        } catch (t) {
          Et(r, 2, t);
        }

        return r;
      }

      return this;
    }

    return this.o = function (t) {
      try {
        var i = t.v;
        1 & t.s ? Et(r, 1, e ? e(i) : i) : n ? Et(r, 1, n(i)) : Et(r, 2, i);
      } catch (t) {
        Et(r, 2, t);
      }
    }, r;
  }, t;
}();

function Tt(t) {
  return t instanceof Ft && 1 & t.s;
}

var Dt,
    Rt = function (t) {
  function n(e) {
    var n;
    return (n = t.call(this) || this)._steps = new Map(), n.cache = new Map(), n.lastProcessorIndexUpdated = -1, e && e.forEach(function (t) {
      return n.register(t);
    }), n;
  }

  r(n, t);
  var i = n.prototype;
  return i.clearCache = function () {
    this.cache = new Map(), this.lastProcessorIndexUpdated = -1;
  }, i.register = function (t, e) {
    if (void 0 === e && (e = null), null === t.type) throw Error("Processor type is not defined");
    t.on("propsUpdated", this.processorPropsUpdated.bind(this)), this.addProcessorByPriority(t, e), this.afterRegistered(t);
  }, i.unregister = function (t) {
    if (t) {
      var e = this._steps.get(t.type);

      e && e.length && (this._steps.set(t.type, e.filter(function (e) {
        return e != t;
      })), this.emit("updated", t));
    }
  }, i.addProcessorByPriority = function (t, e) {
    var n = this._steps.get(t.type);

    if (!n) {
      var r = [];
      this._steps.set(t.type, r), n = r;
    }

    if (null === e || e < 0) n.push(t);else if (n[e]) {
      var i = n.slice(0, e - 1),
          o = n.slice(e + 1);

      this._steps.set(t.type, i.concat(t).concat(o));
    } else n[e] = t;
  }, i.getStepsByType = function (t) {
    return this.steps.filter(function (e) {
      return e.type === t;
    });
  }, i.getSortedProcessorTypes = function () {
    return Object.keys(K).filter(function (t) {
      return !isNaN(Number(t));
    }).map(function (t) {
      return Number(t);
    });
  }, i.process = function (t) {
    try {
      var e = this,
          n = function (t) {
        return e.lastProcessorIndexUpdated = i.length, e.emit("afterProcess", o), o;
      },
          r = e.lastProcessorIndexUpdated,
          i = e.steps,
          o = t,
          s = function (t, n) {
        try {
          var s = function (t, e, n) {
            if ("function" == typeof t[Nt]) {
              var r,
                  i,
                  o,
                  s = t[Nt]();

              if (function t(n) {
                try {
                  for (; !(r = s.next()).done;) if ((n = e(r.value)) && n.then) {
                    if (!Tt(n)) return void n.then(t, o || (o = Et.bind(null, i = new Ft(), 2)));
                    n = n.v;
                  }

                  i ? Et(i, 1, n) : i = n;
                } catch (t) {
                  Et(i || (i = new Ft()), 2, t);
                }
              }(), s.return) {
                var a = function (t) {
                  try {
                    r.done || s.return();
                  } catch (t) {}

                  return t;
                };

                if (i && i.then) return i.then(a, function (t) {
                  throw a(t);
                });
                a();
              }

              return i;
            }

            if (!("length" in t)) throw new TypeError("Object is not iterable");

            for (var u = [], l = 0; l < t.length; l++) u.push(t[l]);

            return function (t, e, n) {
              var r,
                  i,
                  o = -1;
              return function n(s) {
                try {
                  for (; ++o < t.length;) if ((s = e(o)) && s.then) {
                    if (!Tt(s)) return void s.then(n, i || (i = Et.bind(null, r = new Ft(), 2)));
                    s = s.v;
                  }

                  r ? Et(r, 1, s) : r = s;
                } catch (t) {
                  Et(r || (r = new Ft()), 2, t);
                }
              }(), r;
            }(u, function (t) {
              return e(u[t]);
            });
          }(i, function (t) {
            var n = e.findProcessorIndexByID(t.id),
                i = function () {
              if (n >= r) return Promise.resolve(t.process(o)).then(function (n) {
                e.cache.set(t.id, o = n);
              });
              o = e.cache.get(t.id);
            }();

            if (i && i.then) return i.then(function () {});
          });
        } catch (t) {
          return n(t);
        }

        return s && s.then ? s.then(void 0, n) : s;
      }(0, function (t) {
        throw lt.error(t), e.emit("error", o), t;
      });

      return Promise.resolve(s && s.then ? s.then(n) : n());
    } catch (t) {
      return Promise.reject(t);
    }
  }, i.findProcessorIndexByID = function (t) {
    return this.steps.findIndex(function (e) {
      return e.id == t;
    });
  }, i.setLastProcessorIndex = function (t) {
    var e = this.findProcessorIndexByID(t.id);
    this.lastProcessorIndexUpdated > e && (this.lastProcessorIndexUpdated = e);
  }, i.processorPropsUpdated = function (t) {
    this.setLastProcessorIndex(t), this.emit("propsUpdated"), this.emit("updated", t);
  }, i.afterRegistered = function (t) {
    this.setLastProcessorIndex(t), this.emit("afterRegister"), this.emit("updated", t);
  }, e(n, [{
    key: "steps",
    get: function () {
      for (var t, e = [], n = a(this.getSortedProcessorTypes()); !(t = n()).done;) {
        var r = this._steps.get(t.value);

        r && r.length && (e = e.concat(r));
      }

      return e.filter(function (t) {
        return t;
      });
    }
  }]), n;
}(J),
    Lt = function (t) {
  function n() {
    return t.apply(this, arguments) || this;
  }

  return r(n, t), n.prototype._process = function (t) {
    try {
      return Promise.resolve(this.props.storage.get(t));
    } catch (t) {
      return Promise.reject(t);
    }
  }, e(n, [{
    key: "type",
    get: function () {
      return K.Extractor;
    }
  }]), n;
}(Q),
    It = function (t) {
  function n() {
    return t.apply(this, arguments) || this;
  }

  return r(n, t), n.prototype._process = function (t) {
    var e = Z.fromArray(t.data);
    return e.length = t.total, e;
  }, e(n, [{
    key: "type",
    get: function () {
      return K.Transformer;
    }
  }]), n;
}(Q),
    At = function (t) {
  function i() {
    return t.apply(this, arguments) || this;
  }

  return r(i, t), i.prototype._process = function () {
    return Object.entries(this.props.serverStorageOptions).filter(function (t) {
      return "function" != typeof t[1];
    }).reduce(function (t, e) {
      var r;
      return n({}, t, ((r = {})[e[0]] = e[1], r));
    }, {});
  }, e(i, [{
    key: "type",
    get: function () {
      return K.Initiator;
    }
  }]), i;
}(Q),
    Ut = function (t) {
  function n() {
    return t.apply(this, arguments) || this;
  }

  r(n, t);
  var i = n.prototype;
  return i.castData = function (t) {
    if (!t || !t.length) return [];
    if (!this.props.header || !this.props.header.columns) return t;
    var e = wt.leafColumns(this.props.header.columns);
    return t[0] instanceof Array ? t.map(function (t) {
      var n = 0;
      return e.map(function (e, r) {
        return void 0 !== e.data ? (n++, "function" == typeof e.data ? e.data(t) : e.data) : t[r - n];
      });
    }) : "object" != typeof t[0] || t[0] instanceof Array ? [] : t.map(function (t) {
      return e.map(function (e, n) {
        return void 0 !== e.data ? "function" == typeof e.data ? e.data(t) : e.data : e.id ? t[e.id] : (lt.error("Could not find the correct cell for column at position " + n + ".\n                          Make sure either 'id' or 'selector' is defined for all columns."), null);
      });
    });
  }, i._process = function (t) {
    return {
      data: this.castData(t.data),
      total: t.total
    };
  }, e(n, [{
    key: "type",
    get: function () {
      return K.Transformer;
    }
  }]), n;
}(Q),
    Ht = function () {
  function t() {}

  return t.createFromConfig = function (t) {
    var e = new Rt();
    return t.storage instanceof Pt && e.register(new At({
      serverStorageOptions: t.server
    })), e.register(new Lt({
      storage: t.storage
    })), e.register(new Ut({
      header: t.header
    })), e.register(new It()), e;
  }, t;
}(),
    Mt = function () {
  function t(e) {
    this._userConfig = void 0, Object.assign(this, n({}, t.defaultConfig(), e)), this._userConfig = {};
  }

  var e = t.prototype;
  return e.assign = function (t) {
    for (var e = 0, n = Object.keys(t); e < n.length; e++) {
      var r = n[e];
      "_userConfig" !== r && (this[r] = t[r]);
    }

    return this;
  }, e.update = function (e) {
    return e ? (this._userConfig = n({}, this._userConfig, e), this.assign(t.fromUserConfig(this._userConfig)), this) : this;
  }, t.defaultConfig = function () {
    return {
      plugin: new pt(),
      dispatcher: new kt(),
      tableRef: {
        current: null
      },
      tempRef: {
        current: null
      },
      width: "100%",
      height: "auto",
      autoWidth: !0,
      style: {},
      className: {}
    };
  }, t.fromUserConfig = function (e) {
    var r = new t(e);
    return r._userConfig = e, "boolean" == typeof e.sort && e.sort && r.assign({
      sort: {
        multiColumn: !0
      }
    }), r.assign({
      header: wt.fromUserConfig(r)
    }), r.assign({
      storage: xt.createFromUserConfig(e)
    }), r.assign({
      pipeline: Ht.createFromConfig(r)
    }), r.assign({
      translator: new q(e.language)
    }), r.plugin.add({
      id: "search",
      position: rt.Header,
      component: ft,
      props: n({
        enabled: !0 === e.search || e.search instanceof Object
      }, e.search)
    }), r.plugin.add({
      id: "pagination",
      position: rt.Footer,
      component: mt,
      props: n({
        enabled: !0 === e.pagination || e.pagination instanceof Object
      }, e.pagination)
    }), e.plugins && e.plugins.forEach(function (t) {
      return r.plugin.add(t);
    }), r;
  }, t;
}();

!function (t) {
  t[t.Init = 0] = "Init", t[t.Loading = 1] = "Loading", t[t.Loaded = 2] = "Loaded", t[t.Rendered = 3] = "Rendered", t[t.Error = 4] = "Error";
}(Dt || (Dt = {}));

var Ot,
    jt,
    Wt,
    Bt = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var i = e.prototype;
  return i.content = function () {
    return this.props.column && "function" == typeof this.props.column.formatter ? this.props.column.formatter(this.props.cell.data, this.props.row, this.props.column) : this.props.column && this.props.column.plugin ? y(ht, {
      pluginId: this.props.column.id,
      props: {
        column: this.props.column,
        cell: this.props.cell,
        row: this.props.row
      }
    }) : this.props.cell.data;
  }, i.handleClick = function (t) {
    this.props.messageCell || this.config.eventEmitter.emit("cellClick", t, this.props.cell, this.props.column, this.props.row);
  }, i.getCustomAttributes = function (t) {
    return t ? "function" == typeof t.attributes ? t.attributes(this.props.cell.data, this.props.row, this.props.column) : t.attributes : {};
  }, i.render = function () {
    return y("td", n({
      role: this.props.role,
      colSpan: this.props.colSpan,
      "data-column-id": this.props.column && this.props.column.id,
      className: nt(et("td"), this.props.className, this.config.className.td),
      style: n({}, this.props.style, this.config.style.td),
      onClick: this.handleClick.bind(this)
    }, this.getCustomAttributes(this.props.column)), this.content());
  }, e;
}(G),
    zt = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var n = e.prototype;
  return n.getColumn = function (t) {
    if (this.props.header) {
      var e = wt.leafColumns(this.props.header.columns);
      if (e) return e[t];
    }

    return null;
  }, n.handleClick = function (t) {
    this.props.messageRow || this.config.eventEmitter.emit("rowClick", t, this.props.row);
  }, n.getChildren = function () {
    var t = this;
    return this.props.children ? this.props.children : y(k, null, this.props.row.cells.map(function (e, n) {
      var r = t.getColumn(n);
      return r && r.hidden ? null : y(Bt, {
        key: e.id,
        cell: e,
        row: t.props.row,
        column: r
      });
    }));
  }, n.render = function () {
    return y("tr", {
      className: nt(et("tr"), this.config.className.tr),
      onClick: this.handleClick.bind(this)
    }, this.getChildren());
  }, e;
}(G),
    qt = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  return r(e, t), e.prototype.render = function () {
    return y(zt, {
      messageRow: !0
    }, y(Bt, {
      role: "alert",
      colSpan: this.props.colSpan,
      messageCell: !0,
      cell: new V(this.props.message),
      className: nt(et("message"), this.props.className ? this.props.className : null)
    }));
  }, e;
}(G),
    Gt = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var n = e.prototype;
  return n.headerLength = function () {
    return this.props.header ? this.props.header.visibleColumns.length : 0;
  }, n.render = function () {
    var t = this;
    return y("tbody", {
      className: nt(et("tbody"), this.config.className.tbody)
    }, this.props.data && this.props.data.rows.map(function (e) {
      return y(zt, {
        key: e.id,
        row: e,
        header: t.props.header
      });
    }), this.props.status === Dt.Loading && (!this.props.data || 0 === this.props.data.length) && y(qt, {
      message: this._("loading"),
      colSpan: this.headerLength(),
      className: nt(et("loading"), this.config.className.loading)
    }), this.props.status === Dt.Rendered && this.props.data && 0 === this.props.data.length && y(qt, {
      message: this._("noRecordsFound"),
      colSpan: this.headerLength(),
      className: nt(et("notfound"), this.config.className.notfound)
    }), this.props.status === Dt.Error && y(qt, {
      message: this._("error"),
      colSpan: this.headerLength(),
      className: nt(et("error"), this.config.className.error)
    }));
  }, e;
}(G),
    Xt = function (t) {
  function n() {
    return t.apply(this, arguments) || this;
  }

  r(n, t);
  var i = n.prototype;
  return i.validateProps = function () {
    for (var t, e = a(this.props.columns); !(t = e()).done;) {
      var n = t.value;
      void 0 === n.direction && (n.direction = 1), 1 !== n.direction && -1 !== n.direction && lt.error("Invalid sort direction " + n.direction);
    }
  }, i.compare = function (t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }, i.compareWrapper = function (t, e) {
    for (var n, r = 0, i = a(this.props.columns); !(n = i()).done;) {
      var o = n.value;
      if (0 !== r) break;
      var s = t.cells[o.index].data,
          u = e.cells[o.index].data;
      r |= "function" == typeof o.compare ? o.compare(s, u) * o.direction : this.compare(s, u) * o.direction;
    }

    return r;
  }, i._process = function (t) {
    var e = [].concat(t.rows);
    e.sort(this.compareWrapper.bind(this));
    var n = new Z(e);
    return n.length = t.length, n;
  }, e(n, [{
    key: "type",
    get: function () {
      return K.Sort;
    }
  }]), n;
}(Q),
    $t = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var n = e.prototype;
  return n.getInitialState = function () {
    return [];
  }, n.handle = function (t, e) {
    "SORT_COLUMN" === t ? this.sortColumn(e.index, e.direction, e.multi, e.compare) : "SORT_COLUMN_TOGGLE" === t && this.sortToggle(e.index, e.multi, e.compare);
  }, n.sortToggle = function (t, e, n) {
    var r = [].concat(this.state).find(function (e) {
      return e.index === t;
    });
    this.sortColumn(t, r && 1 === r.direction ? -1 : 1, e, n);
  }, n.sortColumn = function (t, e, n, r) {
    var i = [].concat(this.state),
        o = i.length,
        s = i.find(function (e) {
      return e.index === t;
    }),
        a = !1,
        u = !1,
        l = !1,
        c = !1;
    if (void 0 !== s ? n ? -1 === s.direction ? l = !0 : c = !0 : 1 === o ? c = !0 : o > 1 && (u = !0, a = !0) : 0 === o ? a = !0 : o > 0 && !n ? (a = !0, u = !0) : o > 0 && n && (a = !0), u && (i = []), a) i.push({
      index: t,
      direction: e,
      compare: r
    });else if (c) {
      var p = i.indexOf(s);
      i[p].direction = e;
    } else if (l) {
      var h = i.indexOf(s);
      i.splice(h, 1);
    }
    this.setState(i);
  }, e;
}(it),
    Kt = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var n = e.prototype;
  return n.sortColumn = function (t, e, n, r) {
    this.dispatch("SORT_COLUMN", {
      index: t,
      direction: e,
      multi: n,
      compare: r
    });
  }, n.sortToggle = function (t, e, n) {
    this.dispatch("SORT_COLUMN_TOGGLE", {
      index: t,
      multi: e,
      compare: n
    });
  }, e;
}(st),
    Vt = function (t) {
  function i() {
    return t.apply(this, arguments) || this;
  }

  return r(i, t), i.prototype._process = function (t) {
    var e = {};
    return this.props.url && (e.url = this.props.url(t.url, this.props.columns)), this.props.body && (e.body = this.props.body(t.body, this.props.columns)), n({}, t, e);
  }, e(i, [{
    key: "type",
    get: function () {
      return K.ServerSort;
    }
  }]), i;
}(Q),
    Yt = function (t) {
  function e(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).sortProcessor = void 0, r.actions = void 0, r.store = void 0, r.updateStateFn = void 0, r.updateSortProcessorFn = void 0, r.actions = new Kt(r.config.dispatcher), r.store = new $t(r.config.dispatcher), e.enabled && (r.sortProcessor = r.getOrCreateSortProcessor(), r.updateStateFn = r.updateState.bind(o(r)), r.store.on("updated", r.updateStateFn), r.state = {
      direction: 0
    }), r;
  }

  r(e, t);
  var i = e.prototype;
  return i.componentWillUnmount = function () {
    this.config.pipeline.unregister(this.sortProcessor), this.store.off("updated", this.updateStateFn), this.updateSortProcessorFn && this.store.off("updated", this.updateSortProcessorFn);
  }, i.updateState = function () {
    var t = this,
        e = this.store.state.find(function (e) {
      return e.index === t.props.index;
    });
    this.setState(e ? {
      direction: e.direction
    } : {
      direction: 0
    });
  }, i.updateSortProcessor = function (t) {
    this.sortProcessor.setProps({
      columns: t
    });
  }, i.getOrCreateSortProcessor = function () {
    var t = K.Sort;
    this.config.sort && "object" == typeof this.config.sort.server && (t = K.ServerSort);
    var e,
        r = this.config.pipeline.getStepsByType(t);
    return r.length > 0 ? e = r[0] : (this.updateSortProcessorFn = this.updateSortProcessor.bind(this), this.store.on("updated", this.updateSortProcessorFn), e = t === K.ServerSort ? new Vt(n({
      columns: this.store.state
    }, this.config.sort.server)) : new Xt({
      columns: this.store.state
    }), this.config.pipeline.register(e)), e;
  }, i.changeDirection = function (t) {
    t.preventDefault(), t.stopPropagation(), this.actions.sortToggle(this.props.index, !0 === t.shiftKey && this.config.sort.multiColumn, this.props.compare);
  }, i.render = function () {
    if (!this.props.enabled) return null;
    var t = this.state.direction,
        e = "neutral";
    return 1 === t ? e = "asc" : -1 === t && (e = "desc"), y("button", {
      tabIndex: -1,
      "aria-label": this._("sort.sort" + (1 === t ? "Desc" : "Asc")),
      title: this._("sort.sort" + (1 === t ? "Desc" : "Asc")),
      className: nt(et("sort"), et("sort", e), this.config.className.sort),
      onClick: this.changeDirection.bind(this)
    });
  }, e;
}(G),
    Zt = function (t) {
  function e() {
    for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];

    return (e = t.call.apply(t, [this].concat(r)) || this).moveFn = void 0, e.upFn = void 0, e;
  }

  r(e, t);
  var n = e.prototype;
  return n.getPageX = function (t) {
    return t instanceof MouseEvent ? Math.floor(t.pageX) : Math.floor(t.changedTouches[0].pageX);
  }, n.start = function (t) {
    var e, n, r, i, o;
    t.stopPropagation(), this.setState({
      offsetStart: parseInt(this.props.thRef.current.style.width, 10) - this.getPageX(t)
    }), this.upFn = this.end.bind(this), this.moveFn = (e = this.move.bind(this), void 0 === (n = 10) && (n = 100), function () {
      var t = [].slice.call(arguments);
      r ? (clearTimeout(i), i = setTimeout(function () {
        Date.now() - o >= n && (e.apply(void 0, t), o = Date.now());
      }, Math.max(n - (Date.now() - o), 0))) : (e.apply(void 0, t), o = Date.now(), r = !0);
    }), document.addEventListener("mouseup", this.upFn), document.addEventListener("touchend", this.upFn), document.addEventListener("mousemove", this.moveFn), document.addEventListener("touchmove", this.moveFn);
  }, n.move = function (t) {
    t.stopPropagation();
    var e = this.props.thRef.current;
    this.state.offsetStart + this.getPageX(t) >= parseInt(e.style.minWidth, 10) && (e.style.width = this.state.offsetStart + this.getPageX(t) + "px");
  }, n.end = function (t) {
    t.stopPropagation(), document.removeEventListener("mouseup", this.upFn), document.removeEventListener("mousemove", this.moveFn), document.removeEventListener("touchmove", this.moveFn), document.removeEventListener("touchend", this.upFn);
  }, n.render = function () {
    return y("div", {
      className: nt(et("th"), et("resizable")),
      onMouseDown: this.start.bind(this),
      onTouchStart: this.start.bind(this),
      onClick: function (t) {
        return t.stopPropagation();
      }
    });
  }, e;
}(G),
    Jt = function (t) {
  function e(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).sortRef = {
      current: null
    }, r.thRef = {
      current: null
    }, r.state = {
      style: {}
    }, r;
  }

  r(e, t);
  var i = e.prototype;
  return i.isSortable = function () {
    return this.props.column.sort.enabled;
  }, i.isResizable = function () {
    return this.props.column.resizable;
  }, i.onClick = function (t) {
    t.stopPropagation(), this.isSortable() && this.sortRef.current.changeDirection(t);
  }, i.keyDown = function (t) {
    this.isSortable() && 13 === t.which && this.onClick(t);
  }, i.componentDidMount = function () {
    var t = this;
    setTimeout(function () {
      if (t.props.column.fixedHeader && t.thRef.current) {
        var e = t.thRef.current.offsetTop;
        "number" == typeof e && t.setState({
          style: {
            top: e
          }
        });
      }
    }, 0);
  }, i.content = function () {
    return void 0 !== this.props.column.name ? this.props.column.name : void 0 !== this.props.column.plugin ? y(ht, {
      pluginId: this.props.column.plugin.id,
      props: {
        column: this.props.column
      }
    }) : null;
  }, i.getCustomAttributes = function () {
    var t = this.props.column;
    return t ? "function" == typeof t.attributes ? t.attributes(null, null, this.props.column) : t.attributes : {};
  }, i.render = function () {
    var t = {};
    return this.isSortable() && (t.tabIndex = 0), y("th", n({
      ref: this.thRef,
      "data-column-id": this.props.column && this.props.column.id,
      className: nt(et("th"), this.isSortable() ? et("th", "sort") : null, this.props.column.fixedHeader ? et("th", "fixed") : null, this.config.className.th),
      onClick: this.onClick.bind(this),
      style: n({}, this.config.style.th, {
        minWidth: this.props.column.minWidth,
        width: this.props.column.width
      }, this.state.style, this.props.style),
      onKeyDown: this.keyDown.bind(this),
      rowSpan: this.props.rowSpan > 1 ? this.props.rowSpan : void 0,
      colSpan: this.props.colSpan > 1 ? this.props.colSpan : void 0
    }, this.getCustomAttributes(), t), y("div", {
      className: et("th", "content")
    }, this.content()), this.isSortable() && y(Yt, n({
      ref: this.sortRef,
      index: this.props.index
    }, this.props.column.sort)), this.isResizable() && this.props.index < this.config.header.visibleColumns.length - 1 && y(Zt, {
      column: this.props.column,
      thRef: this.thRef
    }));
  }, e;
}(G),
    Qt = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  r(e, t);
  var n = e.prototype;
  return n.renderColumn = function (t, e, n, r) {
    var i = function (t, e, n) {
      var r = wt.maximumDepth(t),
          i = n - e;
      return {
        rowSpan: Math.floor(i - r - r / i),
        colSpan: t.columns && t.columns.length || 1
      };
    }(t, e, r);

    return y(Jt, {
      column: t,
      index: n,
      colSpan: i.colSpan,
      rowSpan: i.rowSpan
    });
  }, n.renderRow = function (t, e, n) {
    var r = this,
        i = wt.leafColumns(this.props.header.columns);
    return y(zt, null, t.map(function (t) {
      return t.hidden ? null : r.renderColumn(t, e, i.indexOf(t), n);
    }));
  }, n.renderRows = function () {
    var t = this,
        e = wt.tabularFormat(this.props.header.columns);
    return e.map(function (n, r) {
      return t.renderRow(n, r, e.length);
    });
  }, n.render = function () {
    return this.props.header ? y("thead", {
      key: this.props.header.id,
      className: nt(et("thead"), this.config.className.thead)
    }, this.renderRows()) : null;
  }, e;
}(G),
    te = function (t) {
  function e() {
    return t.apply(this, arguments) || this;
  }

  return r(e, t), e.prototype.render = function () {
    return y("table", {
      role: "grid",
      className: nt(et("table"), this.config.className.table),
      style: n({}, this.config.style.table, {
        height: this.props.height
      })
    }, y(Qt, {
      header: this.props.header
    }), y(Gt, {
      data: this.props.data,
      status: this.props.status,
      header: this.props.header
    }));
  }, e;
}(G),
    ee = function (t) {
  function e(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).headerRef = {
      current: null
    }, r.state = {
      isActive: !0
    }, r;
  }

  r(e, t);
  var i = e.prototype;
  return i.componentDidMount = function () {
    0 === this.headerRef.current.children.length && this.setState({
      isActive: !1
    });
  }, i.render = function () {
    return this.state.isActive ? y("div", {
      ref: this.headerRef,
      className: nt(et("head"), this.config.className.header),
      style: n({}, this.config.style.header)
    }, y(ht, {
      position: rt.Header
    })) : null;
  }, e;
}(G),
    ne = function (t) {
  function e(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).footerRef = {
      current: null
    }, r.state = {
      isActive: !0
    }, r;
  }

  r(e, t);
  var i = e.prototype;
  return i.componentDidMount = function () {
    0 === this.footerRef.current.children.length && this.setState({
      isActive: !1
    });
  }, i.render = function () {
    return this.state.isActive ? y("div", {
      ref: this.footerRef,
      className: nt(et("footer"), this.config.className.footer),
      style: n({}, this.config.style.footer)
    }, y(ht, {
      position: rt.Footer
    })) : null;
  }, e;
}(G),
    re = function (t) {
  function e(e, n) {
    var r;
    return (r = t.call(this, e, n) || this).configContext = void 0, r.processPipelineFn = void 0, r.configContext = function (t, e) {
      var n = {
        __c: e = "__cC" + f++,
        __: null,
        Consumer: function (t, e) {
          return t.children(e);
        },
        Provider: function (t) {
          var n, r;
          return this.getChildContext || (n = [], (r = {})[e] = this, this.getChildContext = function () {
            return r;
          }, this.shouldComponentUpdate = function (t) {
            this.props.value !== t.value && n.some(x);
          }, this.sub = function (t) {
            n.push(t);
            var e = t.componentWillUnmount;

            t.componentWillUnmount = function () {
              n.splice(n.indexOf(t), 1), e && e.call(t);
            };
          }), t.children;
        }
      };
      return n.Provider.__ = n.Consumer.contextType = n;
    }(), r.state = {
      status: Dt.Loading,
      header: e.header,
      data: null
    }, r;
  }

  r(e, t);
  var i = e.prototype;
  return i.processPipeline = function () {
    try {
      var t = this;
      t.props.config.eventEmitter.emit("beforeLoad"), t.setState({
        status: Dt.Loading
      });

      var e = function (e, n) {
        try {
          var r = Promise.resolve(t.props.pipeline.process()).then(function (e) {
            t.setState({
              data: e,
              status: Dt.Loaded
            }), t.props.config.eventEmitter.emit("load", e);
          });
        } catch (t) {
          return n(t);
        }

        return r && r.then ? r.then(void 0, n) : r;
      }(0, function (e) {
        lt.error(e), t.setState({
          status: Dt.Error,
          data: null
        });
      });

      return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);
    } catch (t) {
      return Promise.reject(t);
    }
  }, i.componentDidMount = function () {
    try {
      var t = this,
          e = t.props.config;
      return Promise.resolve(t.processPipeline()).then(function () {
        e.header && t.state.data && t.state.data.length && t.setState({
          header: e.header.adjustWidth(e)
        }), t.processPipelineFn = t.processPipeline.bind(t), t.props.pipeline.on("updated", t.processPipelineFn);
      });
    } catch (t) {
      return Promise.reject(t);
    }
  }, i.componentWillUnmount = function () {
    this.props.pipeline.off("updated", this.processPipelineFn);
  }, i.componentDidUpdate = function (t, e) {
    e.status != Dt.Rendered && this.state.status == Dt.Loaded && (this.setState({
      status: Dt.Rendered
    }), this.props.config.eventEmitter.emit("ready"));
  }, i.render = function () {
    return y(this.configContext.Provider, {
      value: this.props.config
    }, y("div", {
      role: "complementary",
      className: nt("gridjs", et("container"), this.state.status === Dt.Loading ? et("loading") : null, this.props.config.className.container),
      style: n({}, this.props.config.style.container, {
        width: this.props.width
      })
    }, this.state.status === Dt.Loading && y("div", {
      className: et("loading-bar")
    }), y(ee, null), y("div", {
      className: et("wrapper"),
      style: {
        height: this.props.height
      }
    }, y(te, {
      ref: this.props.config.tableRef,
      data: this.state.data,
      header: this.state.header,
      width: this.props.width,
      height: this.props.height,
      status: this.state.status
    })), y(ne, null), y("div", {
      ref: this.props.config.tempRef,
      id: "gridjs-temp",
      className: et("temp")
    })));
  }, e;
}(G),
    ie = function (t) {
  function e(e) {
    var n;
    return (n = t.call(this) || this).config = void 0, n.plugin = void 0, n.config = new Mt({
      instance: o(n),
      eventEmitter: o(n)
    }).update(e), n.plugin = n.config.plugin, n;
  }

  r(e, t);
  var n = e.prototype;
  return n.updateConfig = function (t) {
    return this.config.update(t), this;
  }, n.createElement = function () {
    return y(re, {
      config: this.config,
      pipeline: this.config.pipeline,
      header: this.config.header,
      width: this.config.width,
      height: this.config.height
    });
  }, n.forceRender = function () {
    return this.config && this.config.container || lt.error("Container is empty. Make sure you call render() before forceRender()", !0), this.config.pipeline.clearCache(), j(null, this.config.container), j(this.createElement(), this.config.container), this;
  }, n.render = function (t) {
    return t || lt.error("Container element cannot be null", !0), t.childNodes.length > 0 ? (lt.error("The container element " + t + " is not empty. Make sure the container is empty and call render() again"), this) : (this.config.container = t, j(this.createElement(), t), this);
  }, e;
}(J),
    se = [],
    ae = u.__b,
    ue = u.__r,
    le = u.diffed,
    ce = u.__c,
    pe = u.unmount;

function _e() {
  se.forEach(function (t) {
    if (t.__P) try {
      t.__H.__h.forEach(ge), t.__H.__h.forEach(ve), t.__H.__h = [];
    } catch (e) {
      t.__H.__h = [], u.__e(e, t.__v);
    }
  }), se = [];
}

u.__b = function (t) {
  jt = null, ae && ae(t);
}, u.__r = function (t) {
  ue && ue(t), Ot = 0;
  var e = (jt = t.__c).__H;
  e && (e.__h.forEach(ge), e.__h.forEach(ve), e.__h = []);
}, u.diffed = function (t) {
  le && le(t);
  var e = t.__c;
  e && e.__H && e.__H.__h.length && (1 !== se.push(e) && Wt === u.requestAnimationFrame || ((Wt = u.requestAnimationFrame) || function (t) {
    var e,
        n = function () {
      clearTimeout(r), me && cancelAnimationFrame(e), setTimeout(t);
    },
        r = setTimeout(n, 100);

    me && (e = requestAnimationFrame(n));
  })(_e)), jt = void 0;
}, u.__c = function (t, e) {
  e.some(function (t) {
    try {
      t.__h.forEach(ge), t.__h = t.__h.filter(function (t) {
        return !t.__ || ve(t);
      });
    } catch (n) {
      e.some(function (t) {
        t.__h && (t.__h = []);
      }), e = [], u.__e(n, t.__v);
    }
  }), ce && ce(t, e);
}, u.unmount = function (t) {
  pe && pe(t);
  var e = t.__c;
  if (e && e.__H) try {
    e.__H.__.forEach(ge);
  } catch (t) {
    u.__e(t, e.__v);
  }
};
var me = "function" == typeof requestAnimationFrame;

function ge(t) {
  var e = jt;
  "function" == typeof t.__c && t.__c(), jt = e;
}

function ve(t) {
  var e = jt;
  t.__c = t.__(), jt = e;
}

/**
 * Defines a column within `pb-table-grid`.
 */

class PbTableColumn extends LitElement {
  static get properties() {
    return Object.assign({
      /**
       * Column heading to display
       */
      label: {
        type: String
      },

      /**
       * Name of the JSON property containing the data
       */
      property: {
        type: String
      },

      /**
       * Should the column support sorting?
       */
      sort: {
        type: Boolean
      },

      /**
       * Optional fixed width of the column (e.g. '200px' or '30%')
       */
      width: {
        type: String
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.label = 'no-label';
    this.property = null;
    this.sort = false;
    this.width = null;
  }

  connectedCallback() {
    super.connectedCallback();
  }

  data() {
    const config = {
      name: this.label,
      sort: {
        enabled: this.sort
      },
      formatter: cell => $(cell)
    };

    if (this.property) {
      config.id = this.property;
    }

    if (this.width) {
      config.width = this.width;
    }

    return config;
  }

}
customElements.define('pb-table-column', PbTableColumn);

/**
 * A table grid based on [gridjs](https://gridjs.io/), which loads its data from a server endpoint
 * specified in `source`. If `source` is a relative URI, it will be resolved relative to the
 * TEI Publisher endpoint.
 * 
 * The JSON data returned by the endpoint should be an object with two properties:
 * 
 * * `count`: the overall number of rows available on the server
 * * `results`: an array containing each record as an object
 * 
 * The parameters send to the server are as follows:
 * 
 * 
 * Parameter | Description
 * ---------|----------
 * limit | number of records to return for each page
 * start | start offset from which to return records
 * order | the id of the column to sort by
 * dir | sort direction: either 'asc' or 'desc'
 * search | an optional search string entered by the user
 * 
 * Table columns are configured via nested `<pb-table-column>` elements:
 * 
 * ```html
 * <pb-table-column label="Name" property="name" sort width="33%"></pb-table-column>
 * <pb-table-column label="Born" property="birth"></pb-table-column>
 * <pb-table-column label="Died" property="death"></pb-table-column>
 * ```
 */

class PbTableGrid extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * URI of the server-side endpoint to retrieve data from.
       * Relative URIs are resolved relative to the configured TEI Publisher endpoint.
       */
      source: {
        type: String
      },

      /**
       * Path to the gridjs theme CSS files.
       */
      cssPath: {
        type: String,
        attribute: 'css-path'
      },

      /**
       * If specified, columns (without a fixed width) will be resizable.
       */
      resizable: {
        type: Boolean
      },
      perPage: {
        type: Number,
        attribute: 'per-page'
      },
      height: {
        type: String
      },

      /**
       * If specified, enable server-side search.
       */
      search: {
        type: Boolean
      },
      _params: {
        type: Object
      }
    }, super.properties);
  }

  constructor() {
    super();
    this.cssPath = '../css/gridjs';
    this._params = {};
    this.resizable = false;
    this.search = false;
    this.perPage = 10;
    this.height = null;
    this.fixedHeader = false;
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-search-resubmit', ev => {
      this._params = Object.assign({}, ev.detail.params);

      this._submit();
    });
    window.addEventListener('popstate', ev => {
      this._params = ev.state;

      this._submit();
    });

    if (!this.height) {
      const property = getComputedStyle(this).getPropertyValue('--pb-table-grid-height');

      if (property) {
        this.height = property;
      } else {
        this.height = 'auto';
      }
    }
  }

  firstUpdated() {
    const table = this.shadowRoot.getElementById('table');
    const pbColumns = this.querySelectorAll('pb-table-column');
    const columns = [];
    pbColumns.forEach(column => columns.push(column.data()));
    PbTableGrid.waitOnce('pb-page-ready', () => {
      this._params = this.getParameters();
      const url = this.toAbsoluteURL(this.source);
      const config = {
        height: this.height,
        fixedHeader: true,
        columns,
        resizable: this.resizable,
        server: {
          url,
          then: data => data.results,
          total: data => data.count
        },
        sort: {
          multiColumn: false,
          enabled: true,
          server: {
            url: (prev, cols) => {
              if (!cols.length) return prev;
              const col = cols[0];
              return `${prev}${prev.indexOf('?') > -1 ? '&' : '?'}order=${columns[col.index].id}&dir=${col.direction === 1 ? 'asc' : 'desc'}`;
            }
          }
        },
        pagination: {
          enabled: true,
          limit: this.perPage,
          server: {
            url: (prev, page, limit) => {
              const form = this.shadowRoot.getElementById('form');

              if (form) {
                Object.assign(this._params, form.serializeForm());
              }

              this._params.limit = limit;
              this._params.start = page * limit + 1;
              this.setParameters(this._params);
              this.pushHistory('grid', this._params);
              return `${prev}${prev.indexOf('?') > -1 ? '&' : '?'}${new URLSearchParams(this._params).toString()}`;
            }
          }
        }
      };
      this.grid = new ie(config);
      this.grid.on('load', () => {
        this.emitTo('pb-results-received', {
          "params": this._params
        });
      });
      this.grid.render(table);
    });
  }

  _submit() {
    this.grid.forceRender();
  }

  render() {
    const themes = resolveURL(this.cssPath);
    return html$1`
            <link href="${themes}/mermaid.min.css" rel="stylesheet">
            ${this.search ? html$1`
                    <iron-form id="form">
                        <form action="">
                            <paper-input id="search" name="search" label="Search" @keyup="${e => e.keyCode == 13 ? this._submit() : null}">
                                <paper-icon-button icon="search" @click="${this._submit}" slot="suffix"></paper-icon-button>
                            </paper-input>
                        </form>
                    </iron-form>
                ` : null}
            <div id="table"></div>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }
            button {
                border: 0;
            }
        `;
  }

}
customElements.define('pb-table-grid', PbTableGrid);

/**
 * Implements a list which is split into different categories 
 * (e.g. letters of the alphabet, countries ...).
 * Only one category is shown at a time unless the server reports
 * no categories (e.g. if the number of items to display goes below
 * a defined threshold).
 *
 * The server-side API endpoint should return a JSON object with two
 * properties:
 * 
 * + `categories`: an array of category descriptions: each item should 
 *  be an object with two properties: `category` - containing the name of the category
 *  and `count` - containing a count of items available under this category.
 * + `items`: an array with the items to be shown for the currently selected
 *  category. Those may contain HTML markup.
 * 
 * Sample JSON object for pb-split-list
 * ```javascript
 * {
 *    "items": [
 *        "<span><a href='Abegg-Arter Carl?category=A&amp;view=correspondents&amp;search='>Abegg-Arter, Carl</a><span class='dates'> (18361912)</span></span>",
 *        "<span><a href='Abegg Hans Heinrich?category=A&amp;view=correspondents&amp;search='>Abegg, Hans Heinrich</a><span class='dates'> (18051874)</span></span>",
 *        "<span><a href='Abegg Jakob?category=A&amp;view=correspondents&amp;search='>Abegg, Jakob</a><span class='dates'> (18011871)</span></span>",
 *        "<span><a href='Abys Raget?category=A&amp;view=correspondents&amp;search='>Abys, Raget</a><span class='dates'> (17901861)</span></span>",
 *        "<span><a href='Aebli Johann Peter?category=A&amp;view=correspondents&amp;search='>Aebli, Johann Peter</a><span class='dates'> (18041879)</span></span>",
 *        "<span><a href='Aepli Arnold Otto?category=A&amp;view=correspondents&amp;search='>Aepli, Arnold Otto</a><span class='dates'> (18161897)</span></span>",
 *        ...
 *    ],
 *    "categories": [
 *        {
 *            "category": "A",
 *            "count": 22
 *        },
 *        {
 *            "category": "B",
 *            "count": 77
 *        },
 *        {
 *            "category": "C",
 *            "count": 19
 *        },
 *      ...
 *    ]
 * }
 * ```
 * 
 * Sample Usage 
 * ```xml
 * <pb-split-list url="api/people" subforms="#options" selected="A" emit="transcription" subscribe="transcription"></pb-split-list>
 * ```
 * See https://www.briefedition.alfred-escher.ch/kontexte/personen/?category=A&search=&view=correspondents for a running sample. The source code of the webpage is here: https://github.com/stazh/briefedition-escher. Relevant files are: 
 * - [templates/index.html](https://github.com/stazh/briefedition-escher/blob/master/templates/index.html#L223) - usage of pb-timeline
 * - [modules/custom-api.json](https://github.com/stazh/briefedition-escher/blob/master/modules/custom-api.json#L1098) - `/api/people` endpoint delivering required JSON object
 * 
 * @cssprop --pb-categorized-list-columns - the number of columns to display (default: 2)
 * @fires pb-submit - when received, submit a request to the server and refresh
 * @fires pb-start-update - sent before the element sends the request to the server
 * @fires pb-end-update - sent after new content has been received
 */

class PbSplitList extends pbMixin(LitElement) {
  static get properties() {
    return Object.assign({
      /**
       * Server-side API endpoint to retrieve items from
       */
      url: {
        type: String
      },

      /**
       * The initially selected category
       */
      selected: {
        type: String
      },

      /**
       * A CSS selector pointing to one or more `pb-custom-form`
       * instances. The element will collect additional parameters
       * from those forms and includes them in the request to the server
       */
      subforms: {
        type: String
      },
      _categories: {
        type: Array
      }
    }, super.properties);
  }

  constructor() {
    super();
    this._categories = [];
    this._params = {};
    this.selected = null;
    this.subforms = null;
  }

  connectedCallback() {
    super.connectedCallback();
    this.selected = this.getParameter('category', this.selected);
    window.addEventListener('popstate', ev => {
      console.log('<pb-split-list> popstate: %o', ev);
      this.selected = ev.state.category;
      this.submit();
    });
    this.subscribeTo('pb-submit', this.load.bind(this));
  }

  firstUpdated() {
    super.firstUpdated();
    PbSplitList.waitOnce('pb-page-ready', () => {
      this.load();
    });
  }

  submit() {
    this.load();
  }

  load() {
    const formParams = this._paramsFromSubforms({
      category: this.selected
    });

    this.setParameters(formParams);
    this.pushHistory('pb-split-list', formParams);
    const params = new URLSearchParams(formParams);
    const url = `${this.toAbsoluteURL(this.url)}?${params.toString()}`;
    console.log(`<pb-split-list> Fetching from URL: ${url}`);
    this.emitTo('pb-start-update');
    fetch(url).then(response => {
      if (response.ok) {
        return response.json();
      }

      return Promise.reject(response.status);
    }).then(json => {
      this._categories = json.categories;
      this.innerHTML = json.items.join('');
      this.emitTo('pb-end-update');
    }).catch(error => {
      console.error(`<pb-split-list> Error caught: ${error}`);
      this.emitTo('pb-end-update');
    });
  }

  _selectCategory(ev, category) {
    ev.preventDefault();
    this.selected = category;
    this.load();
  }

  _paramsFromSubforms(params) {
    if (this.subforms) {
      document.querySelectorAll(this.subforms).forEach(form => {
        if (form.serializeForm) {
          Object.assign(params, form.serializeForm());
        }
      });
    }

    return params;
  }

  render() {
    return html$1`
            <header>
            ${this._categories.map(cat => html$1`
                        <a part="${this.selected === cat.category ? 'active-category' : 'category'}" href="#${cat.category}" title="${cat.count}" class="${this.selected === cat.category ? 'active' : ''}"
                            @click="${ev => this._selectCategory(ev, cat.category)}">
                            ${cat.category}
                        </a>
                    `)}
            </header>
            <div id="items" part="items"><slot></slot></div>
        `;
  }

  static get styles() {
    return css`
            :host {
                display: block;
            }

            header {
                display: flex;
                flex-wrap: wrap;
                column-gap: 10px;
                width: 100%;
            }

            #items {
                display: grid;
                grid-template-columns: repeat(var(--pb-categorized-list-columns, 2), auto);
                grid-auto-rows: 1fr;
                column-gap: 10px;
                width: 100%;
            }

            [part=category], #items a {
                text-decoration: none;
                color: var(--pb-link-color);
            }

            [part=active-category] {
                text-decoration: none;
                color: var(--pb-highlight-color);
            }
        `;
  }

}
customElements.define('pb-split-list', PbSplitList);

class SearchResultService {
  /*
  * SEARCH RESULT OBJECT
  * Service that loads initial data from a datasource,
  * can be a database or an API, and converts it in
  * a format that can be used by the pb-timeline component.
  *
  * public methods:
  *   getMinDateStr()
  *   getMaxDateStr()
  *   getMinDate()
  *   getMaxDate()
  *   export()
  *   getIntervalSizes()
  */

  /*
  * CONSRTUCTOR INPUTS EXPLAINED
  * jsonData: data to load, object with
  *   keys => valid datestrings formatted YYYY-MM-DD
  *   values => number of results for this day
  * maxInterval: max amount of bins allowed
  * scopes: array of all 6 possible values for scope
  */
  constructor(jsonData = {}, maxInterval = 60, scopes = ["D", "W", "M", "Y", "5Y", "10Y"]) {
    this.data = {
      invalid: {},
      valid: {}
    };
    this.maxInterval = maxInterval;
    this.scopes = scopes;

    this._validateJsonData(jsonData);
  }
  /*
  * based on the loaded jsonData, compute
  * - min date as dateStr or utc-date-object
  * - max date as dateStr or utc-date-object
  */


  getMinDateStr() {
    return Object.keys(this.data.valid).sort()[0];
  }

  getMaxDateStr() {
    let days = Object.keys(this.data.valid);
    return days.sort()[days.length - 1];
  }

  getMinDate() {
    return this._dateStrToUTCDate(this.getMinDateStr());
  }

  getMaxDate() {
    return this._dateStrToUTCDate(this.getMaxDateStr());
  }

  getEndOfRangeDate(scope, date) {
    return this._UTCDateToDateStr(this._increaseDateBy(scope, date));
  }
  /*
  * exports data for each scope
  * when no argument is provided, the optimal scope based
  * on the maxInterval (default 60) will be assigned
  */


  export(scope) {
    // auto assign scope when no argument provided
    scope = scope || this._autoAssignScope(); // validate scope

    if (!this.scopes.includes(scope)) {
      throw new Error(`invalid scope provided, expected: ["10Y", "5Y", "Y", "M", "W", "D"]. Got: "${scope}"`);
    } // initialize object to export


    const exportData = {
      data: [],
      scope: scope,
      binTitleRotated: this._binTitleRotatedLookup(scope)
    };

    if (Object.keys(this.data.valid).length === 0) {
      return exportData;
    } // get start and end date


    const startCategory = this._classify(this.getMinDateStr(), scope);

    const startDateStr = this._getFirstDay(startCategory);

    let currentDate = this._dateStrToUTCDate(startDateStr);

    const endDate = this.getMaxDate(); // iterate until end of intervall reached, add binObject for each step

    while (currentDate <= endDate) {
      const currentDateStr = this._UTCDateToDateStr(currentDate);

      const currentCategory = this._classify(currentDateStr, scope);

      exportData.data.push(this._buildBinObject(currentDateStr, currentCategory, scope));
      currentDate = this._increaseDateBy(scope, currentDate);
    } // count all values


    Object.keys(this.data.valid).sort().forEach(dateStr => {
      const currentCategory = this._classify(dateStr, scope);

      const targetBinObject = exportData.data.find(it => it.category === currentCategory);

      try {
        const value = this.data.valid[dateStr];

        if (typeof value === 'object') {
          targetBinObject.value += value.count || 0;

          if (value.info) {
            targetBinObject.info = targetBinObject.info.concat(value.info);
          }
        } else {
          targetBinObject.value += this.data.valid[dateStr] || 0;
        }
      } catch (e) {
        console.log(e);
        console.log("currentCategory");
        console.log(currentCategory);
      }
    });

    if (this.data.invalid) {
      let invalid = 0;
      let info = [];
      Object.values(this.data.invalid).forEach(value => {
        if (typeof value === 'object') {
          invalid += value.count || 0;
          info = info.concat(value.info);
        } else {
          invalid += value;
        }
      });

      if (invalid > 0) {
        exportData.data.push({
          tooltip: get$1('timeline.unknown'),
          title: get$1('timeline.unknown'),
          // binTitle: i18n('timeline.unknown'),
          category: '?',
          separator: true,
          value: invalid,
          info
        });
      }
    }

    return exportData;
  }
  /*
  * returns optimal scope based on the maxInterval
  * by computing the scope that meets the criteria
  * nbr of bins <= maxInterval
  */


  _autoAssignScope() {
    for (let i = 0; i < this.scopes.length; i++) {
      if (this._computeIntervalSize(this.scopes[i]) <= this.maxInterval) {
        return this.scopes[i];
      }
    }

    throw new Error(`Interval too big! Computed: ${this._computeIntervalSize(this.scopes[i])}. Allowed: ${this.maxInterval}. Try to increase maxInterval.`);
  }
  /*
  * splits input data in 2 sections
  * => valid data
  * => invalid (if not a vaid date, for example 2012-00-00 is invalid)
  */


  _validateJsonData(jsonData) {
    Object.keys(jsonData).sort().forEach(key => {
      if (this._isValidDateStr(key)) {
        this.data.valid[key] = jsonData[key];
      } else {
        this.data.invalid[key] = jsonData[key];
      }
    });
  }
  /*
  * lookup table which bin titles should be rotated
  */


  _binTitleRotatedLookup(scope) {
    const lookup = {
      "10Y": true,
      "5Y": true,
      "Y": true,
      "M": false,
      // only exception not to rotate in monthly scope
      "W": true,
      "D": true
    };
    return lookup[scope];
  }
  /*
  * Helper method that builds a binObject that
  * can be read by the pb-timeline component
  */


  _buildBinObject(dateStr, category, scope) {
    const split = dateStr.split("-");
    const yearStr = split[0];
    const monthStr = split[1];
    const dayStr = split[2]; // for all scopes this remains the same

    const binObject = {
      dateStr: dateStr,
      category: category,
      value: 0,
      info: []
    }; // scope specific bin data

    if (scope === "10Y") {
      binObject.tooltip = `${category} - ${Number(category) + 9}`; // 1900 - 1999

      binObject.selectionStart = `${category}`;
      binObject.selectionEnd = `${Number(category) + 9}`; // seperator every 100 years (10 bins)

      if (Number(category) % 100 === 0) {
        binObject.title = `${category} - ${Number(category) + 99}`;
        binObject.binTitle = category;
        binObject.seperator = true;
      }
    } else if (scope === "5Y") {
      binObject.tooltip = `${category} - ${Number(category) + 4}`; // 1995 - 1999

      binObject.selectionStart = `${category}`;
      binObject.selectionEnd = `${Number(category) + 4}`; // seperator every 50 years (10 bins)

      if (Number(category) % 50 === 0) {
        binObject.title = `${category} - ${Number(category) + 49}`;
        binObject.binTitle = category;
        binObject.seperator = true;
      }
    } else if (scope === "Y") {
      binObject.tooltip = category;
      binObject.selectionStart = category;
      binObject.selectionEnd = category; // seperator every 10 years (10 bins)

      if (Number(category) % 10 === 0) {
        binObject.title = `${category} - ${Number(category) + 9}`;
        binObject.binTitle = `${category}`;
        binObject.seperator = true;
      }
    } else if (scope === "M") {
      const monthNum = Number(monthStr);

      const month = this._monthLookup(monthNum); // Jan,Feb,Mar,...,Nov,Dez


      binObject.binTitle = month[0]; // J,F,M,A,M,J,J,..N,D

      binObject.tooltip = `${month} ${yearStr}`; // May 1996

      binObject.selectionStart = `${month} ${yearStr}`;
      binObject.selectionEnd = `${month} ${yearStr}`; // every first of the month

      if (monthNum === 1) {
        binObject.title = yearStr; // YYYY

        binObject.seperator = true;
      }
    } else if (scope === "W") {
      const week = category.split("-")[1];

      binObject.tooltip = `${yearStr} ${week}`; // 1996 W52

      binObject.selectionStart = `${yearStr} ${week}`; // 1996 W52

      binObject.selectionEnd = `${yearStr} ${week}`; // 1996 W52

      let currentDate = this._dateStrToUTCDate(dateStr);

      let lastWeek = this._addDays(currentDate, -7); // title and binTitle every first monday of the month


      if (currentDate.getUTCMonth() !== lastWeek.getUTCMonth()) {
        binObject.binTitle = week;
        binObject.title = this._monthLookup(currentDate.getUTCMonth() + 1);
      } // seperator every start of the year


      binObject.seperator = week === "W1";
    } else if (scope === "D") {
      binObject.tooltip = dateStr;
      binObject.selectionStart = dateStr;
      binObject.selectionEnd = dateStr; // every monday

      if (this._dateStrToUTCDate(dateStr).getUTCDay() === 1) {
        binObject.binTitle = `${Number(dayStr)}.${Number(monthStr)}`;
        binObject.title = `${this._classify(dateStr, "W").replace("-", " ")}`;
        binObject.seperator = true;
      }
    } else {
      throw new Error(`invalid scope provided, expected: ["10Y", "5Y", "Y", "M", "W", "D"]. Got: "${scope}"`);
    }

    return binObject;
  }
  /*
  * ...classifies dateStr into category (based on scope)
  * EXAMPLES:
  * _classify("2016-01-12", "10Y") // => "2010"
  * _classify("2016-01-12", "5Y") // => "2015"
  * _classify("2016-01-12", "Y") // => "2016"
  * _classify("2016-01-12", "M") // => "2010-01"
  * _classify("2016-01-12", "W") // => "2016-W2"
  * _classify("2016-01-12", "D") // => "2016-01-12"
  */


  _classify(dateStr, scope) {
    // returns category (as string)
    if (!dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
      // quick validate dateStr
      throw new Error(`invalid dateStr format, expected "YYYY-MM-DD", got: "${dateStr}".`);
    }

    if (!dateStr || !scope) {
      // both inputs provided
      throw new Error(`both inputs must be provided. Got dateStr=${dateStr}, scope=${scope}`);
    }

    switch (scope) {
      case "10Y":
      case "5Y":
        const intervalSize = Number(scope.replace("Y", ""));
        const startYear = Math.floor(Number(dateStr.split("-")[0]) / intervalSize) * intervalSize;
        return startYear.toString();

      case "Y":
        return dateStr.substr(0, 4);

      case "M":
        return dateStr.substr(0, 7);

      case "W":
        const UTCDate = this._dateStrToUTCDate(dateStr);

        return this._UTCDateToWeekFormat(UTCDate);

      case "D":
        return dateStr;
    }
  }
  /*
  * ...gets first day as UTC Date, based on the category
  * EXAMPLES:
  * _getFirstDay("2010")     // => 2010-01-01
  * _getFirstDay("2010-12")  // => 2010-12-01
  * _getFirstDay("2010-W10") // => 2010-03-08
  */


  _getFirstDay(categoryStr) {
    if (categoryStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
      // YYYY-MM-DD => return same value
      return categoryStr;
    }

    if (categoryStr.match(/^\d{4}-\d{2}$/)) {
      // YYYY-MM
      return `${categoryStr}-01`; // add    -01
    }

    if (categoryStr.match(/^\d{4}$/)) {
      // YYYY
      return `${categoryStr}-01-01`; // add -01-01
    }

    if (categoryStr.match(/^\d{4}-W([1-9]|[1-4][0-9]|5[0-3])$/)) {
      // YYYY-W?  // ? => [1-53]
      //                    |YYYY-W |1-9 | 10-49    | 50-53 |
      const split = categoryStr.split("-");
      const year = Number(split[0]);
      const weekNumber = Number(split[1].replace("W", ""));
      return this._getDateStrOfISOWeek(year, weekNumber);
    }

    throw new Error("invalid categoryStr");
  }
  /*
  * converts dateStr (YYYY-MM-DD) to a date object in UTC time
  */


  _dateStrToUTCDate(dateStr) {
    if (!this._isValidDateStr(dateStr)) {
      throw new Error(`invalid dateStr, expected "YYYY-MM-DD" with month[1-12] and day[1-31], got: "${dateStr}".`);
    }

    const split = dateStr.split("-");
    const year = Number(split[0]);
    const month = Number(split[1]);
    const day = Number(split[2]);
    return new Date(Date.UTC(year, month - 1, day));
  }
  /*
  * converts a UTC date object to a dateStr (YYYY-MM-DD)
  */


  _UTCDateToDateStr(UTCDate) {
    return UTCDate.toISOString().split("T")[0];
  }
  /*
  * example:
  * 1 Jan 2020 => 2020-W1
  */


  _UTCDateToWeekFormat(UTCDate) {
    const year = this._getISOWeekYear(UTCDate);

    const weekNbr = this._getISOWeek(UTCDate);

    return `${year}-W${weekNbr}`;
  }
  /*
   * returns the ISO week (_getISOWeek) or year (_getISOWeekYear)
   * as number based on a UTC date.
   */


  _getISOWeek(UTCDate) {
    // https://weeknumber.net/how-to/javascript
    let date = new Date(UTCDate.getTime());
    date.setHours(0, 0, 0, 0); // Thursday in current week decides the year.

    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7); // January 4 is always in week 1.

    let week1 = new Date(date.getFullYear(), 0, 4); // Adjust to Thursday in week 1 and count number of weeks from date to week1.

    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
  }
  /*
  * returns the ISO week year as number based on a UTC date
  * this is only needed for rollovers, for example:
  * => 1.jan 2011 is in W52 of year 2010.
  */


  _getISOWeekYear(UTCDate) {
    // https://weeknumber.net/how-to/javascript
    var date = new Date(UTCDate.getTime());
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    return date.getFullYear();
  }
  /*
  * given the year and weeknumber -> return dateStr (YYYY-MM-DD)
  */


  _getDateStrOfISOWeek(year, weekNumber) {
    // https://stackoverflow.com/a/16591175/6272061
    let simple = new Date(Date.UTC(year, 0, 1 + (weekNumber - 1) * 7));
    let dow = simple.getUTCDay();
    let ISOweekStart = simple;
    if (dow <= 4) ISOweekStart.setDate(simple.getDate() - simple.getUTCDay() + 1);else ISOweekStart.setDate(simple.getDate() + 8 - simple.getUTCDay());
    return ISOweekStart.toISOString().split("T")[0];
  }
  /*
  * compute the interval sizes based on the scope
  * prediction only, not the actuall export of the data
  */


  getIntervalSizes() {
    return {
      "D": this._computeIntervalSize("D"),
      "W": this._computeIntervalSize("W"),
      "M": this._computeIntervalSize("M"),
      "Y": this._computeIntervalSize("Y"),
      "5Y": this._computeIntervalSize("5Y"),
      "10Y": this._computeIntervalSize("10Y")
    };
  }

  _computeIntervalSize(scope) {
    const maxDate = this.getMaxDateStr();

    if (!maxDate) {
      return 0;
    }

    const endDate = this._dateStrToUTCDate(maxDate);

    const firstDayDateStr = this._getFirstDay(this._classify(this.getMinDateStr(), scope));

    let currentDate = this._dateStrToUTCDate(firstDayDateStr);

    let count = 0;

    while (currentDate <= endDate) {
      count++;
      currentDate = this._increaseDateBy(scope, currentDate);
    }

    return count;
  }

  _increaseDateBy(scope, date) {
    switch (scope) {
      case "D":
        return this._addDays(date, 1);

      case "W":
        return this._addDays(date, 7);

      case "M":
        return this._addMonths(date, 1);

      case "Y":
        return this._addYears(date, 1);

      case "5Y":
        return this._addYears(date, 5);

      case "10Y":
        return this._addYears(date, 10);
    }
  }
  /*
  * functions that add n days (_addDays), months (_addMonths)
  * or years (_addYears) to a UTC date object
  * returns the computed new UTC date
  */


  _addDays(UTCDate, days) {
    let newUTCDate = new Date(UTCDate.valueOf());
    newUTCDate.setUTCDate(newUTCDate.getUTCDate() + days);
    return newUTCDate;
  }

  _addMonths(UTCdate, months) {
    let newUTCDate = new Date(UTCdate.valueOf());
    let d = newUTCDate.getUTCDate();
    newUTCDate.setUTCMonth(newUTCDate.getUTCMonth() + +months);

    if (newUTCDate.getUTCDate() != d) {
      newUTCDate.setUTCDate(0);
    }

    return newUTCDate;
  }

  _addYears(UTCdate, years) {
    let newUTCDate = new Date(UTCdate.valueOf());
    newUTCDate.setUTCFullYear(newUTCDate.getUTCFullYear() + years);
    return newUTCDate;
  }
  /*
  * Validates dateStr. rules:
  * => year: 4 digit number
  * => month: [1-12]
  * => day: [1-31]
  */


  _isValidDateStr(str) {
    if (!str) {
      return false;
    }

    let split = str.split("-");
    if (split.length !== 3) return false;
    let year = split[0];
    let month = split[1];
    let day = split[2];
    if (year === "0000" || day === "00" || month === "00") return false;
    if (Number(day) < 1 || Number(day) > 31) return false;
    if (Number(month) < 1 || Number(month) > 12) return false; // if all checks are passed => valid datestring!

    return true;
  }
  /*
  * Converts month number (str or number) to a 3 char
  * abbreviation of the month (in english)
  */


  _monthLookup(num) {
    if (num > 12 || num < 1) {
      throw new Error(`invalid 'num' provided, expected 1-12. Got: ${num}`);
    }

    const lookup = {
      "1": "Jan",
      "2": "Feb",
      "3": "Mar",
      "4": "Apr",
      "5": "May",
      "6": "Jun",
      "7": "Jul",
      "8": "Aug",
      "9": "Sep",
      "10": "Oct",
      "11": "Nov",
      "12": "Dec"
    };
    return lookup[num.toString()];
  }

}

class ParseDateService {
  /*
  * PARSE DATE SERVICE
  * whenever the user types a date, it should be allowed
  * to type in a lot of dirrerent date formats. This service
  * should detect all of the supported formats. Some supported formats:
  * - 1. April 1970 => 1970-04-01
  * - 1970          => 1970-01-01
  * - 1970-12-23    => 1970-12-23
  * - 1900 12 23    => 1900-12-23
  * - 1 jan 1970    => 1970-01-01
  * - 2020-W12      => 2020-03-16
  * - 2020-01       => 2020-01-01
  * For all formats check the tests written in AVA `test/parse-date-service-test.js`
  *
  * public methods
  *   run()
  */
  constructor() {}

  run(input) {
    this.input = input;
    this.day = "??";
    this.month = "??";
    this.year = "????";
    const resultIsoMatch = this.input.match(this._isoMatchRegex());
    const resultCustomMatch = this.input.match(this._customRegex());
    const resultWeekMatch = this.input.match(this._weekMatchRegex());
    const resultYearAndMonthMatch = this.input.match(this._yearAndMonthRegex());

    if (resultIsoMatch) {
      const split = resultIsoMatch[1].split(/-|\/|\s/);
      this.year = split[0];
      this.month = this._setWithLeadingZero(split[1]);
      this.day = this._setWithLeadingZero(split[2]);
    } else if (resultYearAndMonthMatch) {
      const split = resultYearAndMonthMatch[1].split("-");
      this.year = split[0];
      this.month = this._setWithLeadingZero(split[1]);
      this.day = "01";
    } else if (resultCustomMatch) {
      const split = resultCustomMatch[0].split(/\.|\s|\/|-/);
      this.day = this._setWithLeadingZero(split[0]);
      this.month = this._setWithLeadingZero(split[1]);
      this.year = split[2];
    } else if (resultWeekMatch) {
      const split = resultWeekMatch[0].split(/\.|\s|\/|-/);
      const year = Number(split[0]);
      const week = Number(split[1].replace("W0", "").replace("W", ""));
      return this._getDateStrOfISOWeek(year, week);
    } else {
      this._findYear();

      this._findMonth();

      this._findDay();
    }

    return this._buildResult();
  }

  _buildResult() {
    if (this.year != "????" && this.month === "??") {
      this.month = "01";
    }

    if (this.month != "??" && this.day === "??") {
      this.day = "01";
    }

    return `${this.year}-${this.month}-${this.day}`;
  }
  /*
  * matches ISO string format (with some extensions)
  * | 2012-01-31 | 2012-1-31 | 2012/01/31 |
  * | 2012/1/31  | 2012 1 31 | 2012 01 31 |
  */


  _isoMatchRegex() {
    return /(?:\s|^)(\d{4}(-|\s|\/)([0][1-9]|[1-9]|10|11|12)(-|\s|\/)([0][1-9]|[1-2][0-9]|3[01]|[1-9]))(?=\s|$|\.)/;
    /*      |        | year         | 01-09 | 1-9 | 10-12   |         |01-09  |10-29     |30,31| 1-9  |
    *       |             | dash or slash                   | dash or slash                           |
    *       |preceding with space or start of string                 end with space endofstr or dot <-|*/
  }
  /*
  * matches a custom date string format (reversed order, day-month-year)
  * | 12.3.2000 | 1.2.2012 | 1-2-2012 |
  * | 12/3/2000 | 1 2 2012 | 1/2/2012 |
  */


  _customRegex() {
    return /\d{1,2}(\.|\s|\/|-)\d{1,2}(\.|\s|\/|-)\d{4}/;
    /*      | day  |           | month |          | year
    *              |___________________|
    *                        |
    *        seperated by dot, space, slash or dash */
  }
  /*
  * matches a date format that specifies the week
  * | 2012-W1 | 2012 W1  | 2012 W01 |
  * | 2020.W2 | 2020-W53 | 2012/W1  |
  */


  _weekMatchRegex() {
    return /\d{4}(\.|\s|\/|-)W\d{1,2}(?=\s|$|\.)/;
    /*      |year |         |W1-W53   |
    *             |___________________|
    *                      |
    *     seperated by dot, space, slash or dash */
  }
  /*
  * matches a date format with only year and month
  * YYYY-MM (1-12)
  * | 2020-01 | 2020-12 | 2012-1 |
  */


  _yearAndMonthRegex() {
    return /(?:\s|^)(\d{4}-([0][1-9]|[1-9]|10|11|12))(?=\s|$)/;
  }

  _findYear() {
    let regex = /[1-9]{1}[0-9]{3}/;
    const result = this.input.match(regex);

    if (result) {
      this.year = result[0];

      this._removeMatchFromInput(result);
    }
  }

  _findMonth() {
    const months = this._monthDictionaryValues();

    months.forEach(month => {
      const re = new RegExp(`(?:\\s|^)(${month})(?=\\s|$|\\.)`, "i");
      const result = this.input.match(re);

      if (result) {
        // yes => get dict and value + return
        this.month = this._monthDictionary()[result[1].toLowerCase()];

        this._removeMatchFromInput(result);

        return this.month;
      }
    });
    return undefined;
  }
  /*
  * find single numbers from 1-31
  */


  _findDay() {
    const regex = /(?:\s|^)([0][1-9]|[1-2][0-9]|3[01]|[1-9])(?=\s|$|\.|st|nd|rd|th)/;
    /*           |         | 01-09 | 10-29    |30,31|1-9    | ends with whitespace, endofstr or dot.
    *            | starts with whitepace or startoftr       | won't be included in match (lookbehind operator)
    *            | look behind operator (not included)
    *            | https://stackoverflow.com/a/6713378/6272061 */

    const result = this.input.match(regex);

    if (result) {
      this.day = this._setWithLeadingZero(result[1]);
    }
  }
  /*
  * if a string or number has only 1 digit or char
  * a leading zro is added
  * returns a string
  */


  _setWithLeadingZero(input) {
    input = input.toString();

    if (input.length == 1) {
      return "0" + input;
    } else {
      return input;
    }
  }

  _removeMatchFromInput(matchObj) {
    if (matchObj && matchObj[0] && matchObj.index) {
      let len = matchObj[0].length;
      let charArr = this.input.split('');
      charArr.splice(matchObj.index, len);
      this.input = charArr.join("");
    }
  }

  _monthDictionaryValues() {
    return Object.keys(this._monthDictionary());
  }

  _monthDictionary() {
    return {
      // german
      "jan": "01",
      "januar": "01",
      "feb": "02",
      "februar": "02",
      "mr": "03",
      "mrz": "03",
      "apr": "04",
      "april": "04",
      "mai": "05",
      "mai": "05",
      "jun": "06",
      "juni": "06",
      "jul": "07",
      "juli": "07",
      "aug": "08",
      "august": "08",
      "sep": "09",
      "september": "09",
      "okt": "10",
      "oktober": "10",
      "nov": "11",
      "november": "11",
      "dez": "12",
      "dezember": "12",
      // english
      "jan": "01",
      "january": "01",
      "feb": "02",
      "february": "02",
      "mar": "03",
      "march": "03",
      "apr": "04",
      "april": "04",
      "may": "05",
      "may": "05",
      "jun": "06",
      "june": "06",
      "jul": "07",
      "july": "07",
      "aug": "08",
      "august": "08",
      "sep": "09",
      "september": "09",
      "oct": "10",
      "october": "10",
      "nov": "11",
      "november": "11",
      "dec": "12",
      "december": "12",
      // french
      "janv": "01",
      "janvier": "01",
      "fvr": "02",
      "fvrier'": "02",
      "mars": "03",
      "mars": "03",
      "avr": "04",
      "avril": "04",
      "mai": "05",
      "mai": "05",
      "juin": "06",
      "juin": "06",
      "juil": "07",
      "juillet": "07",
      "aot": "08",
      "aot": "08",
      "sept": "09",
      "septembre": "09",
      "oct": "10",
      "octobre": "10",
      "nov": "11",
      "novembre": "11",
      "dc": "12",
      "dcembre": "12",
      //italian
      "gen": "01",
      "gennaio": "01",
      "feb": "02",
      "febbraio": "02",
      "mar": "03",
      "marzo": "03",
      "apr": "04",
      "aprile": "04",
      "mag": "05",
      "maggio": "05",
      "giu": "06",
      "giugno": "06",
      "lug": "07",
      "luglio": "07",
      "ago": "08",
      "agosto": "08",
      "set": "09",
      "settembre": "09",
      "ott": "10",
      "ottobre": "10",
      "nov": "11",
      "novembre": "11",
      "dic": "12",
      "dicembre": "12"
    };
  }

  _getDateStrOfISOWeek(y, w) {
    let simple = new Date(y, 0, 1 + (w - 1) * 7);
    let dow = simple.getDay();
    let ISOweekStart = simple;

    if (dow <= 4) {
      ISOweekStart.setDate(simple.getDate() - simple.getDay() + 1);
    } else {
      ISOweekStart.setDate(simple.getDate() + 8 - simple.getDay());
    } // do not rollover to next or previous year


    if (ISOweekStart.getFullYear() > y) {
      return `${y}-12-31`;
    } else if (ISOweekStart.getFullYear() < y) {
      return `${y}-01-01`;
    }

    return this._dateToDateStr(ISOweekStart);
  }
  /*
  * formats date object to dateStr YYYY-MM-DD
  */


  _dateToDateStr(date) {
    let d = new Date(date);

    let month = this._setWithLeadingZero(d.getMonth() + 1);

    let day = this._setWithLeadingZero(d.getDate());

    let year = d.getFullYear();
    return `${year}-${month}-${day}`;
  }

}

/**
 * A timeline component to display time series data in a bar chart like view.
 *
 * Time series data can be displayed in one of 6 different scales:
 * 
 * - by decade (10Y)
 * - by 5 years (5Y)
 * - by years (Y)
 * - by month (M)
 * - by week (W)
 * - by day (D)
 * 
 * The endpoint is expected to return a JSON object. Each property should either be a date or the special
 * marker `?`, which indicates undated resources.
 * The value associated with each entry
 * should either correspond to a count of resources or an object with properties `count` and `info`. 
 * `info` should be an array, containing HTML to be shown in a list within the tooltips.
 * Expected JSON: 
 * ```javascript
 * {
 *  "1852-01-14": {
 *      "count": 1,
 *      "info": [
 *        "<a href='/briefe/B0977' part='tooltip-link'>Alfred Escher an Joseph Wolfgang von Deschwanden, Belvoir (Enge, Zrich), Mittwoch, 14. Januar 1852</a>"
 *     ]
 *   },
 * "1874-01-25": {
 *    "count": 3,
 *     "info": [
 *         "<a href='/briefe/B8140' part='tooltip-link'>Alfred Escher an Gustav von Mevissen, Zrich, Sonntag, 25. Januar 1874</a>",
 *         "<a href='/briefe/B8139' part='tooltip-link'>Alfred Escher an Theodor Weishaupt, Zrich, Sonntag, 25. Januar 1874</a>",
 *         "<a href='/briefe/B8143' part='tooltip-link'>Alfred Escher an Ludwig August Parcus, Zrich, Sonntag, 25. Januar 1874</a>"
 *     ]
 *  }
 * }
 * ```
 * Sample Usage:
 * ```xml
 * <pb-timeline url="api/timeline" scopes="['D', 'M', 'Y', '5Y', '10Y']"
 *      resettable=""
 *      subscribe="docs" emit="timeline">
 *   <span slot="label">Angezeigter Zeitraum:</span>
 * </pb-timeline>
 * ```
 * See https://www.briefedition.alfred-escher.ch/briefe/ for a running sample. The source code of the webpage is here: https://github.com/stazh/briefedition-escher. Relevant files are: 
 * - [templates/people.html](https://github.com/stazh/briefedition-escher/blob/master/templates/people.html#L91) - usage of pb-timeline
 * - [modules/custom-api.json](https://github.com/stazh/briefedition-escher/blob/master/modules/custom-api.json#L1080) - `/api/timeline` endpoint delivering required JSON object
 * 
 * @slot label - Inserted before the label showing the currently displayed time range
 * 
 * @fires pb-timeline-date-changed - Triggered when user clicks on a single entry
 * @fires pb-timeline-daterange-changed - Triggered when user selects a range of entries
 * @fires pb-timeline-reset-selection - Requests that the timeline is reset to initial state
 * @fires pb-timeline-loaded - Timeline was loaded
 * 
 * @cssprop --pb-timeline-height
 * @cssprop --pb-timeline-padding
 * @cssprop --pb-timeline-color-highlight
 * @cssprop --pb-timeline-color-light
 * @cssprop --pb-timeline-color-dark
 * @cssprop --pb-timeline-color-selected
 * @cssprop --pb-timeline-color-bin
 * @cssprop --pb-timeline-title-font-size
 * @cssprop --pb-timeline-tooltip-font-size
 * 
 * @csspart label
 * @csspart tooltip
 * @csspart title
 */

class PbTimeline extends pbMixin(LitElement) {
  static get styles() {
    return css`
      :host{
        display: block;
      }
      .hidden {
        visibility: hidden;
      }
      .draggable {
        cursor: grab;
        user-select: none;
        padding-right: 30px !important;
      }
      .wrapper {
        margin: 0 auto;
        padding: var(--pb-timeline-padding);
        width: auto;
        height: var(--pb-timeline-height, 80px);
        display: flex;
        position: relative;
      }
      .wrapper.empty {
        display: none;
      }

      .label {
        display: flex;
        align-items: center;
      }
      .bin-container {
        cursor: crosshair;
        margin-top: 20px;
        min-width: var(--pb-timeline-min-width, 14px);
        max-width: var(--pb-timeline-max-width, 20px);
        flex-grow: 1;
        flex-basis: 0;
        display: flex;
        align-items: flex-end;
        // justify-content: center;
        position: relative;
      }
      .bin-container.border-left, .bin-container.unknown {
        border-left: 1px solid rgba(0,0,0,0.4);
      }
      .bin-container.unknown {
        margin-left: 40px;
      }
      .bin-container:hover .bin {
        background-color: var(--pb-timeline-color-highlight, #3f52b5);
      }
      .bin-container.selected > .bin {
        background-color: var(--pb-timeline-color-highlight, #3f52b5);
      }
      .bin-container.selected p {
        font-weight: bold;
      }
      .bin-container.white {
        background-color: var(--pb-timeline-color-light, white);
      }
      .bin-container.grey {
        background-color: var(--pb-timeline-color-dark, #f1f1f1);
      }
      .bin-container.selected {
        background-color: var(--pb-timeline-color-selected, #e6eaff) !important;
      }
      .bin {
        width: 80%;
        background-color: var(--pb-timeline-color-bin, #ccc);
        border-radius: 2px;
        user-select: none;
      }
      p.bin-title {
        pointer-events: none;
        position: absolute;
        top: 5px;
        z-index: 10;
        margin: 0;
        font-size: var(--pb-timeline-title-font-size, 12px);
        user-select: none;
        white-space: nowrap;
      }
      p.bin-title.months {
        top: -1px;
      }
      p.bin-title.weeks {
        top: 3px;
      }
      p.bin-title.days {
        top: -1px;
      }
      p.bin-title.rotated {
        transform: rotate(-90deg);
      }
      .bins-title {
        cursor: auto;
        font-weight: normal !important;
        margin: 0;
        white-space: nowrap;
        z-index: 200;
        position: absolute;
        left: 0;
        top: -20px;
        font-size: var(--pb-timeline-title-font-size, 12px);
        background-color: var(--pb-timeline-background-color-title, #535353);
        color: var(--pb-timeline-color-title, #ffffff);
        padding: 2px 4px;
        border-radius: 5px;
        height: var(--pb-timeline-title-font-size, 12px);
        line-height: var(--pb-timeline-title-font-size, 12px);
        user-select: none;
      }
      .info {
        display: none;
      }

      /* TOOLTIP */
      #tooltip {
        display: inline-block;
        position: absolute;
        min-width: var(--pb-timeline-tooltip-min-width, 200px);
        font-size: var(--pb-timeline-tooltip-font-size, 11px);
        line-height: 1.25;
        background: var(--pb-timeline-background-color-title, #535353);
        color: var(--pb-timeline-color-title, #ffffff);
        text-align: left;
        border-radius: 6px;
        padding: 5px 10px;
        top: var(--pb-timeline-height, 80px);
        left: 0;
        z-index: 1000;
      }
      #tooltip ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }
      #tooltip-close {
        position: absolute;
        top: -13px;
        right: -10px;
      }
      #tooltip::after { /* small triangle that points to top */
        content: "";
        position: absolute;
        bottom: 100%;
        left: 10px;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent transparent black transparent;
      }
      #tooltip.right::after {
        right: 10px;
        left: auto;
      }
      /* pure css close button for tooltip */
      .close{
        position: relative;
        display: inline-block;
        width: 50px;
        height: 50px;
        overflow: hidden;
        transform: scale(0.25);
      }
      .close.rounded.black {
        cursor: pointer;
      }
      .close::before, .close::after {
        content: '';
        position: absolute;
        height: 2px;
        width: 100%;
        top: 50%;
        left: 0;
        margin-top: -1px;
        background: #fff;
      }
      .close::before {
        transform: rotate(45deg);
      }
      .close::after {
        transform: rotate(-45deg);
      }
      .close.thick::before, .close.thick::after {
        height: 4px;
        margin-top: -2px;
      }
      .close.black::before, .close.black::after {
        height: 8px;
        margin-top: -4px;
      }
      .close.rounded::before, .close.rounded::after {
        border-radius: 5px;
      }
    `;
  }

  static get properties() {
    return Object.assign(Object.assign({}, super.properties), {}, {
      /**
       * start date for timeline to display
       */
      startDate: {
        type: String,
        reflect: true,
        attribute: 'start-date'
      },

      /**
       * endDate for timeline to display
       */
      endDate: {
        type: String,
        reflect: true,
        attribute: 'end-date'
      },

      /**
       * The scope for the timeline. Must be one of the pre-defined scopes.
       * If not set, the component automatically tries to determine the best scope fitting the
       * given time series.
       */
      scope: {
        type: String
      },

      /**
       * The scopes to consider for automatic scoping.
       * 
       * Defaults to ["D", "W", "M", "Y", "5Y", "10Y"]
       */
      scopes: {
        type: Array
      },
      maxInterval: {
        type: Number,
        attribute: 'max-interval'
      },

      /**
       * Endpoint to load timeline data from. Expects response to be an
       * object with key value pairs for (date, hits).
       *
       * Will be reloaded whenever 'start-date' or 'end-date' attributes change.
       */
      url: {
        type: String
      },

      /**
       * If set, data will be retrieved automatically on first load.
       */
      auto: {
        type: Boolean
      },
      resettable: {
        type: Boolean
      },
      _language: {
        type: String
      }
    });
  }

  constructor() {
    super();
    this.maxHeight = 80; // in pixels, has to be identical to the max-height specified in CSS

    this.multiplier = 0.75; // max percentage of bin compared to the bin-conainer. Set 1 for full height (not recommended)

    this.mousedown = false;
    this.startDate = '';
    this.endDate = '';
    this.scope = '';
    this.scopes = ["D", "W", "M", "Y", "5Y", "10Y"];
    this.maxInterval = 60;
    this.url = '';
    this.auto = false;
    this.resettable = false;
    this._language = 'en';

    this._resetSelectionProperty();
  }

  connectedCallback() {
    super.connectedCallback();
    this.subscribeTo('pb-results-received', () => {
      const loader = this.shadowRoot.getElementById('loadData');
      const url = this.toAbsoluteURL(this.url, this.getEndpoint());
      loader.url = url;
      loader.generateRequest();
    });
    this.subscribeTo('pb-i18n-update', ev => {
      this._language = ev.detail.language;
    });
  }

  firstUpdated() {
    this.bins = this.shadowRoot.querySelectorAll(".bin-container");
    this.tooltip = this.shadowRoot.getElementById("tooltip"); // global mouseup event

    document.addEventListener("mouseup", () => {
      this._mouseUp();
    }); // pb-timeline-daterange-changed event:
    // changes daterange selection (marks bins on histogram)
    // is triggered by the componeent itself but can be also triggered
    // from outside by another component

    document.addEventListener("pb-timeline-daterange-changed", event => {
      const startDateStr = event.detail.startDateStr;
      const endDateStr = event.detail.endDateStr;

      if (this._fullRangeSelected(startDateStr, endDateStr)) {
        // do not mark the whole histogram, reset selection instead
        console.log("_fullRangeSelected() is true");
        this.resetSelection();
        return;
      }

      this.select(startDateStr, endDateStr);
    }); // pb-timeline-reset-selection:
    // resets selection (remove marking of all selected bins)
    // is triggered by the componeent itself but can be also triggered
    // from outside by another component

    document.addEventListener("pb-timeline-reset-selection", () => {
      this.resetSelection();

      this._hideTooltip();
    });
  }
  /**
   * checks if 'scope' has changed and re-applies dataset accordingly
   *
   * @param changedProperties
   */


  updated(changedProperties) {
    if (changedProperties.has('scope')) {
      if (this.searchResult) {
        if (this.scopes.includes(this.scope)) {
          this.setData(this.searchResult.export(this.scope));
        } else {
          console.error('unknown scope ', this.scope);
        }
      }
    }
  }

  setData(dataObj) {
    this.dataObj = dataObj;
    this.maxValue = Math.max(...this.dataObj.data.map(binObj => binObj.value));
    this.requestUpdate();
    this.updateComplete.then(() => {
      this.bins = this.shadowRoot.querySelectorAll(".bin-container");
      this.resetSelection();

      this._resetTooltip();
    });
  }

  get label() {
    if (!this.dataObj || this.dataObj.data.length === 0) {
      return '';
    }

    if (this.dataObj.data.length === 1) {
      return this.dataObj.data[0].category;
    }

    return `${this.dataObj.data[0].category}  ${this.dataObj.data[this.dataObj.data.length - 1].category}`;
  }

  getSelectedStartDateStr() {
    return this.shadowRoot.querySelectorAll(".bin-container.selected")[0].dataset.selectionstart;
  }

  getSelectedEndDateStr() {
    const selectedBins = this.shadowRoot.querySelectorAll(".bin-container.selected");
    return selectedBins[selectedBins.length - 1].dataset.selectionend;
  }

  getSelectedCategories() {
    const selectedBins = this.shadowRoot.querySelectorAll(".bin-container.selected");
    const categories = [];
    selectedBins.forEach(bin => categories.push(bin.dataset.category));
    return categories;
  }

  getSelectedItemCount() {
    const selectedBins = this.shadowRoot.querySelectorAll(".bin-container.selected");
    let count = 0;
    selectedBins.forEach(bin => {
      count += parseInt(bin.dataset.value);
    });
    return count;
  }

  resetSelection() {
    this.bins.forEach(bin => {
      bin.classList.remove("selected");
    });

    this._resetSelectionProperty();

    this._hideTooltip();
  }

  select(startDateStr, endDateStr) {
    this.bins.forEach(bin => {
      if (bin.dataset.isodatestr >= startDateStr && bin.dataset.isodatestr <= endDateStr) {
        bin.classList.add("selected");
      } else {
        bin.classList.remove("selected");
      }
    });

    this._displayTooltip();

    this._showtooltipSelection();
  }

  _fullRangeSelected(startDateStr, endDateStr) {
    const matchingStartDate = startDateStr = this.bins[0].dataset.isodatestr;
    const matchingEndDate = endDateStr === this.bins[this.bins.length - 1].dataset.isodatestr;
    return matchingStartDate && matchingEndDate;
  }

  _mouseDown(event) {
    this.resetSelection();
    this.mousedown = true;
    this.selection.start = this._getMousePosition(event).x;

    this._applySelectionToBins();
  }

  _mouseUp() {
    if (this.mousedown) {
      this.mousedown = false;
      const start = this.getSelectedStartDateStr();
      const end = this.getSelectedEndDateStr();

      if (start) {
        const startDateStr = new ParseDateService().run(start);
        const endDateStr = new ParseDateService().run(end);
        const itemCount = this.getSelectedItemCount();

        this._dispatchTimelineDaterangeChangedEvent(startDateStr, endDateStr, this.getSelectedCategories(), itemCount);
      }
    }
  }

  _mouseMove(event) {
    if (this.mousedown) {
      this._brushing(event);

      this._showtooltipSelection();
    } else if (this.selection.start === undefined) {
      // no selection currently made
      this._showtooltip(event);
    }
  }

  _mouseenter() {
    if (this.dataObj) {
      // if data is loaded
      this._displayTooltip();
    }
  }

  _getMousePosition(mouseEvent) {
    let rect = this.shadowRoot.querySelector(".wrapper").getBoundingClientRect();
    let x = mouseEvent.clientX - rect.left + 1; //x position within the element.

    let y = mouseEvent.clientY - rect.top + 1; //y position within the element.

    return {
      x: x,
      y: y
    };
  }

  _brushing(event) {
    this.selection.end = this._getMousePosition(event).x;

    this._applySelectionToBins();
  }

  _dispatchTimelineDaterangeChangedEvent(startDateStr, endDateStr, categories, itemCount) {
    if (startDateStr === '????-??-??') {
      this.emitTo('pb-timeline-date-changed', {
        startDateStr: null,
        endDateStr: null,
        categories: ['?'],
        count: itemCount
      });
    } else if (startDateStr === endDateStr) {
      if (this.dataObj.scope !== 'D') {
        this.emitTo('pb-timeline-daterange-changed', {
          startDateStr,
          endDateStr: this.searchResult.getEndOfRangeDate(this.dataObj.scope, endDateStr),
          scope: this.dataObj.scope,
          categories,
          count: itemCount,
          label: this.label
        });
      } else {
        this.emitTo('pb-timeline-date-changed', {
          startDateStr,
          endDateStr: null,
          scope: this.dataObj.scope,
          categories,
          count: itemCount,
          label: this.label
        });
      }
    } else {
      this.emitTo('pb-timeline-daterange-changed', {
        startDateStr,
        endDateStr,
        categories,
        scope: this.dataObj.scope,
        count: itemCount,
        label: this.label
      });
    }
  }

  _dispatchPbTimelineResetSelectionEvent() {
    this.emitTo('pb-timeline-reset-selection');
  }

  _showtooltip(event) {
    const interval = this._getElementInterval(event.currentTarget);

    let offset;

    if (interval[0] < interval[2]) {
      offset = Math.round((interval[0] + interval[1]) / 2 - 10);
      this.tooltip.classList.remove('right');
    } else {
      offset = Math.round((interval[0] + interval[1]) / 2 - this.tooltip.offsetWidth) + 10;
      this.tooltip.classList.add('right');
    }

    this.tooltip.style.left = offset + "px";
    const datestr = event.currentTarget.dataset.tooltip;

    const value = this._numberWithCommas(event.currentTarget.dataset.value);

    const info = event.currentTarget.querySelector('.info');
    this.tooltip.querySelector("#tooltip-text").innerHTML = `<div><strong>${datestr}</strong>: ${value}</div><ul>${info ? info.innerHTML : ''}</ul>`;
  }

  _showtooltipSelection() {
    const selectedBins = this._getSelectedBins();

    const intervalStart = this._getElementInterval(selectedBins[0])[0]; // get first selected element left boundary


    const intervalEnd = this._getElementInterval(selectedBins[selectedBins.length - 1])[1]; // get last selected element right boundary


    const interval = [intervalStart, intervalEnd];
    const label = `${selectedBins[0].dataset.selectionstart} - ${selectedBins[selectedBins.length - 1].dataset.selectionend}`;
    const value = selectedBins.map(bin => Number(bin.dataset.value)).reduce((a, b) => a + b);

    const valueFormatted = this._numberWithCommas(value);

    this.tooltip.querySelector("#tooltip-text").innerHTML = `<strong>${label}</strong>: ${valueFormatted}`;
    this.tooltip.querySelector("#tooltip-close").classList.remove("hidden");
    this.tooltip.classList.add("draggable");
    const offset = Math.round((interval[0] + interval[1]) / 2 - this.tooltip.offsetWidth / 2);
    this.tooltip.style.left = offset + "px";
  }

  _resetTooltip() {
    this._hideTooltip();

    this.tooltip.style.left = '-1000px';
    this.tooltip.querySelector("#tooltip-text").innerHTML = "";
  }

  _hideTooltip() {
    if (this.selection.start === undefined) {
      this.tooltip.classList.add("hidden");
      this.tooltip.classList.remove("draggable");
      this.tooltip.querySelector("#tooltip-close").classList.add("hidden");
    }
  }

  _displayTooltip() {
    this.tooltip.classList.remove("hidden");
  }

  _getElementInterval(nodeElement) {
    let rect = this.shadowRoot.querySelector(".wrapper").getBoundingClientRect();
    let bin = nodeElement;
    let interval = [bin.getBoundingClientRect().x, bin.getBoundingClientRect().x + bin.getBoundingClientRect().width];
    let x1 = interval[0] - rect.left + 1; //x position within the element.

    let x2 = interval[1] - rect.left + 1; //x position within the element.

    return [x1, x2, rect.width / 2];
  }

  _getSelectionInterval() {
    return [this.selection.start, this.selection.end].sort((a, b) => a - b);
  }

  _getSelectedBins() {
    return Array.prototype.slice.call(this.bins).filter(binContainer => {
      return binContainer.classList.contains("selected");
    });
  }

  _resetSelectionProperty() {
    this.selection = {
      start: undefined,
      end: undefined
    };
  }

  _applySelectionToBins() {
    const selectionInterval = this._getSelectionInterval();

    this.bins.forEach(bin => {
      const elInterval = this._getElementInterval(bin); // if (this.intervalsOverlapping(elInterval, selectionInterval)) {


      if (this._areOverlapping(elInterval, selectionInterval)) {
        bin.classList.add("selected");
      } else {
        bin.classList.remove("selected");
      }
    });
  }

  _numberWithCommas(input) {
    return new Intl.NumberFormat(this._language, {
      style: 'decimal'
    }).format(input);
  }

  _areOverlapping(A, B) {
    // check if 2 intervals are overlapping
    return B[0] < A[0] ? B[1] > A[0] : B[0] < A[1];
  }

  render() {
    return html$1`
      <div class="label" part="label">
        <span class="label"><slot name="label"></slot>${this.label}</span>
        ${this.resettable ? html$1`
            <paper-icon-button id="clear" icon="icons:clear" title="${translate('timeline.clear')}"
            @click="${this._dispatchPbTimelineResetSelectionEvent}"></paper-icon-button>
          ` : null}
      </div>
      <div class="wrapper ${!this.dataObj || this.dataObj.data.length <= 1 ? 'empty' : ''}"
        @mouseenter="${this._mouseenter}"
        @mouseleave="${this._hideTooltip}">
        ${this.dataObj ? this.renderBins() : ""}
        ${this.renderTooltip()}
        <iron-ajax
            id="loadData"
            verbose
            handle-as="json"
            method="get"
            with-credentials
            @response="${this._handleResponse}"
            url="${this.url}?start=${this.startDate}&end=${this.endDate}"
            ?auto="${this.auto}"></iron-ajax>
      </div>
    `;
  }

  renderTooltip() {
    return html$1`
      <div id="tooltip" class="hidden" part="tooltip">
        <div id="tooltip-text"></div>
        <div
          id="tooltip-close"
          class="hidden"
          @click="${this._dispatchPbTimelineResetSelectionEvent}"
          ><span class="close rounded black"></span>
        </div>
      </div>
    `;
  }

  renderBins() {
    return html$1`
      ${this.dataObj.data.map((binObj, indx) => {
      return html$1`
          <div class="bin-container ${binObj.seperator ? "border-left" : ""}
            ${indx % 2 === 0 ? "grey" : "white"} ${binObj.category === '?' ? 'unknown' : ''}"
            data-tooltip="${binObj.tooltip}"
            data-category="${binObj.category}"
            data-selectionstart="${binObj.selectionStart}"
            data-selectionend="${binObj.selectionEnd}"
            data-isodatestr="${binObj.dateStr}"
            data-datestr="${binObj.dateStr}"
            data-value="${binObj.value}"
            @mousemove="${this._mouseMove}"
            @mousedown="${this._mouseDown}">
            <div class="bin" style="height: ${binObj.value / this.maxValue * this.maxHeight * this.multiplier}px"></div>
            <p class="bin-title
              ${this.dataObj.binTitleRotated ? "rotated" : ""}
              ${this.scope}"
              >${binObj.binTitle ? binObj.binTitle : ""}
            </p>
            ${binObj.title ? html$1`
              <p class="bins-title" part="title">${binObj.title}</p>
            ` : ""}
            ${this.renderInfo(binObj)}
          </div>
        `;
    })}
    `;
  }

  renderInfo(binObj) {
    if (binObj.info && binObj.info.length > 0 && binObj.info.length <= 10) {
      return html$1`
        <ul class="info">
        ${binObj.info.map(info => html$1`<li>${unsafeHTML(info)}</li>`)}
        </ul>
      `;
    }

    return null;
  }

  async _handleResponse() {
    await this.updateComplete;
    const loader = this.shadowRoot.getElementById('loadData');
    const data = loader.lastResponse;
    let newJsonData = {};

    if (this.startDate && this.endDate) {
      Object.keys(data).filter(key => key >= this.startDate && key < this.endDate).forEach(key => {
        newJsonData[key] = data[key];
      });
    } else {
      newJsonData = data;
    }

    this.searchResult = new SearchResultService(newJsonData, this.maxInterval, this.scopes);
    this.setData(this.searchResult.export(this.scope));
    this.emitTo('pb-timeline-loaded', {
      value: true,
      label: this.label
    });
  }

}
customElements.define('pb-timeline', PbTimeline);

/**
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template$3 = html`<iron-iconset-svg name="editor" size="24">
<svg><defs>
<g id="attach-file"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"></path></g>
<g id="attach-money"><path d="M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z"></path></g>
<g id="border-all"><path d="M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z"></path></g>
<g id="border-bottom"><path d="M9 11H7v2h2v-2zm4 4h-2v2h2v-2zM9 3H7v2h2V3zm4 8h-2v2h2v-2zM5 3H3v2h2V3zm8 4h-2v2h2V7zm4 4h-2v2h2v-2zm-4-8h-2v2h2V3zm4 0h-2v2h2V3zm2 10h2v-2h-2v2zm0 4h2v-2h-2v2zM5 7H3v2h2V7zm14-4v2h2V3h-2zm0 6h2V7h-2v2zM5 11H3v2h2v-2zM3 21h18v-2H3v2zm2-6H3v2h2v-2z"></path></g>
<g id="border-clear"><path d="M7 5h2V3H7v2zm0 8h2v-2H7v2zm0 8h2v-2H7v2zm4-4h2v-2h-2v2zm0 4h2v-2h-2v2zm-8 0h2v-2H3v2zm0-4h2v-2H3v2zm0-4h2v-2H3v2zm0-4h2V7H3v2zm0-4h2V3H3v2zm8 8h2v-2h-2v2zm8 4h2v-2h-2v2zm0-4h2v-2h-2v2zm0 8h2v-2h-2v2zm0-12h2V7h-2v2zm-8 0h2V7h-2v2zm8-6v2h2V3h-2zm-8 2h2V3h-2v2zm4 16h2v-2h-2v2zm0-8h2v-2h-2v2zm0-8h2V3h-2v2z"></path></g>
<g id="border-color"><path d="M17.75 7L14 3.25l-10 10V17h3.75l10-10zm2.96-2.96c.39-.39.39-1.02 0-1.41L18.37.29c-.39-.39-1.02-.39-1.41 0L15 2.25 18.75 6l1.96-1.96z"></path><path fill-opacity=".36" d="M0 20h24v4H0z"></path></g>
<g id="border-horizontal"><path d="M3 21h2v-2H3v2zM5 7H3v2h2V7zM3 17h2v-2H3v2zm4 4h2v-2H7v2zM5 3H3v2h2V3zm4 0H7v2h2V3zm8 0h-2v2h2V3zm-4 4h-2v2h2V7zm0-4h-2v2h2V3zm6 14h2v-2h-2v2zm-8 4h2v-2h-2v2zm-8-8h18v-2H3v2zM19 3v2h2V3h-2zm0 6h2V7h-2v2zm-8 8h2v-2h-2v2zm4 4h2v-2h-2v2zm4 0h2v-2h-2v2z"></path></g>
<g id="border-inner"><path d="M3 21h2v-2H3v2zm4 0h2v-2H7v2zM5 7H3v2h2V7zM3 17h2v-2H3v2zM9 3H7v2h2V3zM5 3H3v2h2V3zm12 0h-2v2h2V3zm2 6h2V7h-2v2zm0-6v2h2V3h-2zm-4 18h2v-2h-2v2zM13 3h-2v8H3v2h8v8h2v-8h8v-2h-8V3zm6 18h2v-2h-2v2zm0-4h2v-2h-2v2z"></path></g>
<g id="border-left"><path d="M11 21h2v-2h-2v2zm0-4h2v-2h-2v2zm0-12h2V3h-2v2zm0 4h2V7h-2v2zm0 4h2v-2h-2v2zm-4 8h2v-2H7v2zM7 5h2V3H7v2zm0 8h2v-2H7v2zm-4 8h2V3H3v18zM19 9h2V7h-2v2zm-4 12h2v-2h-2v2zm4-4h2v-2h-2v2zm0-14v2h2V3h-2zm0 10h2v-2h-2v2zm0 8h2v-2h-2v2zm-4-8h2v-2h-2v2zm0-8h2V3h-2v2z"></path></g>
<g id="border-outer"><path d="M13 7h-2v2h2V7zm0 4h-2v2h2v-2zm4 0h-2v2h2v-2zM3 3v18h18V3H3zm16 16H5V5h14v14zm-6-4h-2v2h2v-2zm-4-4H7v2h2v-2z"></path></g>
<g id="border-right"><path d="M7 21h2v-2H7v2zM3 5h2V3H3v2zm4 0h2V3H7v2zm0 8h2v-2H7v2zm-4 8h2v-2H3v2zm8 0h2v-2h-2v2zm-8-8h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm8 8h2v-2h-2v2zm4-4h2v-2h-2v2zm4-10v18h2V3h-2zm-4 18h2v-2h-2v2zm0-16h2V3h-2v2zm-4 8h2v-2h-2v2zm0-8h2V3h-2v2zm0 4h2V7h-2v2z"></path></g>
<g id="border-style"><path d="M15 21h2v-2h-2v2zm4 0h2v-2h-2v2zM7 21h2v-2H7v2zm4 0h2v-2h-2v2zm8-4h2v-2h-2v2zm0-4h2v-2h-2v2zM3 3v18h2V5h16V3H3zm16 6h2V7h-2v2z"></path></g>
<g id="border-top"><path d="M7 21h2v-2H7v2zm0-8h2v-2H7v2zm4 0h2v-2h-2v2zm0 8h2v-2h-2v2zm-8-4h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2v-2H3v2zm0-4h2V7H3v2zm8 8h2v-2h-2v2zm8-8h2V7h-2v2zm0 4h2v-2h-2v2zM3 3v2h18V3H3zm16 14h2v-2h-2v2zm-4 4h2v-2h-2v2zM11 9h2V7h-2v2zm8 12h2v-2h-2v2zm-4-8h2v-2h-2v2z"></path></g>
<g id="border-vertical"><path d="M3 9h2V7H3v2zm0-4h2V3H3v2zm4 16h2v-2H7v2zm0-8h2v-2H7v2zm-4 0h2v-2H3v2zm0 8h2v-2H3v2zm0-4h2v-2H3v2zM7 5h2V3H7v2zm12 12h2v-2h-2v2zm-8 4h2V3h-2v18zm8 0h2v-2h-2v2zm0-8h2v-2h-2v2zm0-10v2h2V3h-2zm0 6h2V7h-2v2zm-4-4h2V3h-2v2zm0 16h2v-2h-2v2zm0-8h2v-2h-2v2z"></path></g>
<g id="bubble-chart"><circle cx="7.2" cy="14.4" r="3.2"></circle><circle cx="14.8" cy="18" r="2"></circle><circle cx="15.2" cy="8.8" r="4.8"></circle></g>
<g id="drag-handle"><path d="M20 9H4v2h16V9zM4 15h16v-2H4v2z"></path></g>
<g id="format-align-center"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"></path></g>
<g id="format-align-justify"><path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"></path></g>
<g id="format-align-left"><path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"></path></g>
<g id="format-align-right"><path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"></path></g>
<g id="format-bold"><path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"></path></g>
<g id="format-clear"><path d="M3.27 5L2 6.27l6.97 6.97L6.5 19h3l1.57-3.66L16.73 21 18 19.73 3.55 5.27 3.27 5zM6 5v.18L8.82 8h2.4l-.72 1.68 2.1 2.1L14.21 8H20V5H6z"></path></g>
<g id="format-color-fill"><path d="M16.56 8.94L7.62 0 6.21 1.41l2.38 2.38-5.15 5.15c-.59.59-.59 1.54 0 2.12l5.5 5.5c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12zM5.21 10L10 5.21 14.79 10H5.21zM19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5z"></path><path fill-opacity=".36" d="M0 20h24v4H0z"></path></g>
<g id="format-color-reset"><path d="M18 14c0-4-6-10.8-6-10.8s-1.33 1.51-2.73 3.52l8.59 8.59c.09-.42.14-.86.14-1.31zm-.88 3.12L12.5 12.5 5.27 5.27 4 6.55l3.32 3.32C6.55 11.32 6 12.79 6 14c0 3.31 2.69 6 6 6 1.52 0 2.9-.57 3.96-1.5l2.63 2.63 1.27-1.27-2.74-2.74z"></path></g>
<g id="format-color-text"><path fill-opacity=".36" d="M0 20h24v4H0z"></path><path d="M11 3L5.5 17h2.25l1.12-3h6.25l1.12 3h2.25L13 3h-2zm-1.38 9L12 5.67 14.38 12H9.62z"></path></g>
<g id="format-indent-decrease"><path d="M11 17h10v-2H11v2zm-8-5l4 4V8l-4 4zm0 9h18v-2H3v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"></path></g>
<g id="format-indent-increase"><path d="M3 21h18v-2H3v2zM3 8v8l4-4-4-4zm8 9h10v-2H11v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z"></path></g>
<g id="format-italic"><path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"></path></g>
<g id="format-line-spacing"><path d="M6 7h2.5L5 3.5 1.5 7H4v10H1.5L5 20.5 8.5 17H6V7zm4-2v2h12V5H10zm0 14h12v-2H10v2zm0-6h12v-2H10v2z"></path></g>
<g id="format-list-bulleted"><path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"></path></g>
<g id="format-list-numbered"><path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"></path></g>
<g id="format-paint"><path d="M18 4V3c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6h1v4H9v11c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-9h8V4h-3z"></path></g>
<g id="format-quote"><path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"></path></g>
<g id="format-shapes"><path d="M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2zm-5.27 9h-3.49l-.73 2H7.89l3.4-9h1.4l3.41 9h-1.63l-.74-2zm-3.04-1.26h2.61L12 8.91l-1.31 3.83z"></path></g>
<g id="format-size"><path d="M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z"></path></g>
<g id="format-strikethrough"><path d="M10 19h4v-3h-4v3zM5 4v3h5v3h4V7h5V4H5zM3 14h18v-2H3v2z"></path></g>
<g id="format-textdirection-l-to-r"><path d="M9 10v5h2V4h2v11h2V4h2V2H9C6.79 2 5 3.79 5 6s1.79 4 4 4zm12 8l-4-4v3H5v2h12v3l4-4z"></path></g>
<g id="format-textdirection-r-to-l"><path d="M10 10v5h2V4h2v11h2V4h2V2h-8C7.79 2 6 3.79 6 6s1.79 4 4 4zm-2 7v-3l-4 4 4 4v-3h12v-2H8z"></path></g>
<g id="format-underlined"><path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"></path></g>
<g id="functions"><path d="M18 4H6v2l6.5 6L6 18v2h12v-3h-7l5-5-5-5h7z"></path></g>
<g id="highlight"><path d="M6 14l3 3v5h6v-5l3-3V9H6zm5-12h2v3h-2zM3.5 5.875L4.914 4.46l2.12 2.122L5.62 7.997zm13.46.71l2.123-2.12 1.414 1.414L18.375 8z"></path></g>
<g id="insert-chart"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="insert-comment"><path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path></g>
<g id="insert-drive-file"><path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"></path></g>
<g id="insert-emoticon"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
<g id="insert-invitation"><path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path></g>
<g id="insert-link"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"></path></g>
<g id="insert-photo"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"></path></g>
<g id="linear-scale"><path d="M19.5 9.5c-1.03 0-1.9.62-2.29 1.5h-2.92c-.39-.88-1.26-1.5-2.29-1.5s-1.9.62-2.29 1.5H6.79c-.39-.88-1.26-1.5-2.29-1.5C3.12 9.5 2 10.62 2 12s1.12 2.5 2.5 2.5c1.03 0 1.9-.62 2.29-1.5h2.92c.39.88 1.26 1.5 2.29 1.5s1.9-.62 2.29-1.5h2.92c.39.88 1.26 1.5 2.29 1.5 1.38 0 2.5-1.12 2.5-2.5s-1.12-2.5-2.5-2.5z"></path></g>
<g id="merge-type"><path d="M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z"></path></g>
<g id="mode-comment"><path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z"></path></g>
<g id="mode-edit"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
<g id="monetization-on"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16z"></path></g>
<g id="money-off"><path d="M12.5 6.9c1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-.53.12-1.03.3-1.48.54l1.47 1.47c.41-.17.91-.27 1.51-.27zM5.33 4.06L4.06 5.33 7.5 8.77c0 2.08 1.56 3.21 3.91 3.91l3.51 3.51c-.34.48-1.05.91-2.42.91-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c.96-.18 1.82-.55 2.45-1.12l2.22 2.22 1.27-1.27L5.33 4.06z"></path></g>
<g id="multiline-chart"><path d="M22 6.92l-1.41-1.41-2.85 3.21C15.68 6.4 12.83 5 9.61 5 6.72 5 4.07 6.16 2 8l1.42 1.42C5.12 7.93 7.27 7 9.61 7c2.74 0 5.09 1.26 6.77 3.24l-2.88 3.24-4-4L2 16.99l1.5 1.5 6-6.01 4 4 4.05-4.55c.75 1.35 1.25 2.9 1.44 4.55H21c-.22-2.3-.95-4.39-2.04-6.14L22 6.92z"></path></g>
<g id="pie-chart"><path d="M11 2v20c-5.07-.5-9-4.79-9-10s3.93-9.5 9-10zm2.03 0v8.99H22c-.47-4.74-4.24-8.52-8.97-8.99zm0 11.01V22c4.74-.47 8.5-4.25 8.97-8.99h-8.97z"></path></g>
<g id="pie-chart-outlined"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm1 2.07c3.61.45 6.48 3.33 6.93 6.93H13V4.07zM4 12c0-4.06 3.07-7.44 7-7.93v15.87c-3.93-.5-7-3.88-7-7.94zm9 7.93V13h6.93c-.45 3.61-3.32 6.48-6.93 6.93z"></path></g>
<g id="publish"><path d="M5 4v2h14V4H5zm0 10h4v6h6v-6h4l-7-7-7 7z"></path></g>
<g id="short-text"><path d="M4 9h16v2H4zm0 4h10v2H4z"></path></g>
<g id="show-chart"><path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"></path></g>
<g id="space-bar"><path d="M18 9v4H6V9H4v6h16V9z"></path></g>
<g id="strikethrough-s"><path d="M7.24 8.75c-.26-.48-.39-1.03-.39-1.67 0-.61.13-1.16.4-1.67.26-.5.63-.93 1.11-1.29.48-.35 1.05-.63 1.7-.83.66-.19 1.39-.29 2.18-.29.81 0 1.54.11 2.21.34.66.22 1.23.54 1.69.94.47.4.83.88 1.08 1.43.25.55.38 1.15.38 1.81h-3.01c0-.31-.05-.59-.15-.85-.09-.27-.24-.49-.44-.68-.2-.19-.45-.33-.75-.44-.3-.1-.66-.16-1.06-.16-.39 0-.74.04-1.03.13-.29.09-.53.21-.72.36-.19.16-.34.34-.44.55-.1.21-.15.43-.15.66 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.05-.08-.11-.17-.15-.25zM21 12v-2H3v2h9.62c.18.07.4.14.55.2.37.17.66.34.87.51.21.17.35.36.43.57.07.2.11.43.11.69 0 .23-.05.45-.14.66-.09.2-.23.38-.42.53-.19.15-.42.26-.71.35-.29.08-.63.13-1.01.13-.43 0-.83-.04-1.18-.13s-.66-.23-.91-.42c-.25-.19-.45-.44-.59-.75-.14-.31-.25-.76-.25-1.21H6.4c0 .55.08 1.13.24 1.58.16.45.37.85.65 1.21.28.35.6.66.98.92.37.26.78.48 1.22.65.44.17.9.3 1.38.39.48.08.96.13 1.44.13.8 0 1.53-.09 2.18-.28s1.21-.45 1.67-.79c.46-.34.82-.77 1.07-1.27s.38-1.07.38-1.71c0-.6-.1-1.14-.31-1.61-.05-.11-.11-.23-.17-.33H21z"></path></g>
<g id="text-fields"><path d="M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z"></path></g>
<g id="title"><path d="M5 4v3h5.5v12h3V7H19V4z"></path></g>
<g id="vertical-align-bottom"><path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"></path></g>
<g id="vertical-align-center"><path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"></path></g>
<g id="vertical-align-top"><path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"></path></g>
<g id="wrap-text"><path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></g>
</defs></svg>
</iron-iconset-svg>`;
document.head.appendChild(template$3.content);

/**
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template$4 = html`<iron-iconset-svg name="social" size="24">
<svg><defs>
<g id="cake"><path d="M12 6c1.11 0 2-.9 2-2 0-.38-.1-.73-.29-1.03L12 0l-1.71 2.97c-.19.3-.29.65-.29 1.03 0 1.1.9 2 2 2zm4.6 9.99l-1.07-1.07-1.08 1.07c-1.3 1.3-3.58 1.31-4.89 0l-1.07-1.07-1.09 1.07C6.75 16.64 5.88 17 4.96 17c-.73 0-1.4-.23-1.96-.61V21c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-4.61c-.56.38-1.23.61-1.96.61-.92 0-1.79-.36-2.44-1.01zM18 9h-5V7h-2v2H6c-1.66 0-3 1.34-3 3v1.54c0 1.08.88 1.96 1.96 1.96.52 0 1.02-.2 1.38-.57l2.14-2.13 2.13 2.13c.74.74 2.03.74 2.77 0l2.14-2.13 2.13 2.13c.37.37.86.57 1.38.57 1.08 0 1.96-.88 1.96-1.96V12C21 10.34 19.66 9 18 9z"></path></g>
<g id="domain"><path d="M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z"></path></g>
<g id="group"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g>
<g id="group-add"><path d="M8 10H5V7H3v3H0v2h3v3h2v-3h3v-2zm10 1c1.66 0 2.99-1.34 2.99-3S19.66 5 18 5c-.32 0-.63.05-.91.14.57.81.9 1.79.9 2.86s-.34 2.04-.9 2.86c.28.09.59.14.91.14zm-5 0c1.66 0 2.99-1.34 2.99-3S14.66 5 13 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm6.62 2.16c.83.73 1.38 1.66 1.38 2.84v2h3v-2c0-1.54-2.37-2.49-4.38-2.84zM13 13c-2 0-6 1-6 3v2h12v-2c0-2-4-3-6-3z"></path></g>
<g id="location-city"><path d="M15 11V5l-3-3-3 3v2H3v14h18V11h-6zm-8 8H5v-2h2v2zm0-4H5v-2h2v2zm0-4H5V9h2v2zm6 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V9h2v2zm0-4h-2V5h2v2zm6 12h-2v-2h2v2zm0-4h-2v-2h2v2z"></path></g>
<g id="mood"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
<g id="mood-bad"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 3c-2.33 0-4.31 1.46-5.11 3.5h10.22c-.8-2.04-2.78-3.5-5.11-3.5z"></path></g>
<g id="notifications"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"></path></g>
<g id="notifications-active"><path d="M7.58 4.08L6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2c.15-2.65 1.51-4.97 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43c2.02 1.45 3.39 3.77 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z"></path></g>
<g id="notifications-none"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z"></path></g>
<g id="notifications-off"><path d="M20 18.69L7.84 6.14 5.27 3.49 4 4.76l2.8 2.8v.01c-.52.99-.8 2.16-.8 3.42v5l-2 2v1h13.73l2 2L21 19.72l-1-1.03zM12 22c1.11 0 2-.89 2-2h-4c0 1.11.89 2 2 2zm6-7.32V11c0-3.08-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-.15.03-.29.08-.42.12-.1.03-.2.07-.3.11h-.01c-.01 0-.01 0-.02.01-.23.09-.46.2-.68.31 0 0-.01 0-.01.01L18 14.68z"></path></g>
<g id="notifications-paused"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.93 6 11v5l-2 2v1h16v-1l-2-2zm-3.5-6.2l-2.8 3.4h2.8V15h-5v-1.8l2.8-3.4H9.5V8h5v1.8z"></path></g>
<g id="pages"><path d="M3 5v6h5L7 7l4 1V3H5c-1.1 0-2 .9-2 2zm5 8H3v6c0 1.1.9 2 2 2h6v-5l-4 1 1-4zm9 4l-4-1v5h6c1.1 0 2-.9 2-2v-6h-5l1 4zm2-14h-6v5l4-1-1 4h5V5c0-1.1-.9-2-2-2z"></path></g>
<g id="party-mode"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 3c1.63 0 3.06.79 3.98 2H12c-1.66 0-3 1.34-3 3 0 .35.07.69.18 1H7.1c-.06-.32-.1-.66-.1-1 0-2.76 2.24-5 5-5zm0 10c-1.63 0-3.06-.79-3.98-2H12c1.66 0 3-1.34 3-3 0-.35-.07-.69-.18-1h2.08c.07.32.1.66.1 1 0 2.76-2.24 5-5 5z"></path></g>
<g id="people"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g>
<g id="people-outline"><path d="M16.5 13c-1.2 0-3.07.34-4.5 1-1.43-.67-3.3-1-4.5-1C5.33 13 1 14.08 1 16.25V19h22v-2.75c0-2.17-4.33-3.25-6.5-3.25zm-4 4.5h-10v-1.25c0-.54 2.56-1.75 5-1.75s5 1.21 5 1.75v1.25zm9 0H14v-1.25c0-.46-.2-.86-.52-1.22.88-.3 1.96-.53 3.02-.53 2.44 0 5 1.21 5 1.75v1.25zM7.5 12c1.93 0 3.5-1.57 3.5-3.5S9.43 5 7.5 5 4 6.57 4 8.5 5.57 12 7.5 12zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 5.5c1.93 0 3.5-1.57 3.5-3.5S18.43 5 16.5 5 13 6.57 13 8.5s1.57 3.5 3.5 3.5zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z"></path></g>
<g id="person"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"></path></g>
<g id="person-add"><path d="M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm-9-2V7H4v3H1v2h3v3h2v-3h3v-2H6zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"></path></g>
<g id="person-outline"><path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></g>
<g id="plus-one"><path d="M10 8H8v4H4v2h4v4h2v-4h4v-2h-4zm4.5-1.92V7.9l2.5-.5V18h2V5z"></path></g>
<g id="poll"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="public"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"></path></g>
<g id="school"><path d="M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z"></path></g>
<g id="sentiment-dissatisfied"><circle cx="15.5" cy="9.5" r="1.5"></circle><circle cx="8.5" cy="9.5" r="1.5"></circle><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-6c-2.33 0-4.32 1.45-5.12 3.5h1.67c.69-1.19 1.97-2 3.45-2s2.75.81 3.45 2h1.67c-.8-2.05-2.79-3.5-5.12-3.5z"></path></g>
<g id="sentiment-neutral"><path d="M9 14h6v1.5H9z"></path><circle cx="15.5" cy="9.5" r="1.5"></circle><circle cx="8.5" cy="9.5" r="1.5"></circle><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="sentiment-satisfied"><circle cx="15.5" cy="9.5" r="1.5"></circle><circle cx="8.5" cy="9.5" r="1.5"></circle><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-4c-1.48 0-2.75-.81-3.45-2H6.88c.8 2.05 2.79 3.5 5.12 3.5s4.32-1.45 5.12-3.5h-1.67c-.7 1.19-1.97 2-3.45 2z"></path></g>
<g id="sentiment-very-dissatisfied"><path d="M11.99 2C6.47 2 2 6.47 2 12s4.47 10 9.99 10S22 17.53 22 12 17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm4.18-12.24l-1.06 1.06-1.06-1.06L13 8.82l1.06 1.06L13 10.94 14.06 12l1.06-1.06L16.18 12l1.06-1.06-1.06-1.06 1.06-1.06zM7.82 12l1.06-1.06L9.94 12 11 10.94 9.94 9.88 11 8.82 9.94 7.76 8.88 8.82 7.82 7.76 6.76 8.82l1.06 1.06-1.06 1.06zM12 14c-2.33 0-4.31 1.46-5.11 3.5h10.22c-.8-2.04-2.78-3.5-5.11-3.5z"></path></g>
<g id="sentiment-very-satisfied"><path d="M11.99 2C6.47 2 2 6.47 2 12s4.47 10 9.99 10S22 17.53 22 12 17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm1-10.06L14.06 11l1.06-1.06L16.18 11l1.06-1.06-2.12-2.12zm-4.12 0L9.94 11 11 9.94 8.88 7.82 6.76 9.94 7.82 11zM12 17.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
<g id="share"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"></path></g>
<g id="whatshot"><path d="M13.5.67s.74 2.65.74 4.8c0 2.06-1.35 3.73-3.41 3.73-2.07 0-3.63-1.67-3.63-3.73l.03-.36C5.21 7.51 4 10.62 4 14c0 4.42 3.58 8 8 8s8-3.58 8-8C20 8.61 17.41 3.8 13.5.67zM11.71 19c-1.78 0-3.22-1.4-3.22-3.14 0-1.62 1.05-2.76 2.81-3.12 1.77-.36 3.6-1.21 4.62-2.58.39 1.29.59 2.65.59 4.04 0 2.65-2.15 4.8-4.8 4.8z"></path></g>
</defs></svg>
</iron-iconset-svg>`;
document.head.appendChild(template$4.content);

/**
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template$5 = html`<iron-iconset-svg name="maps" size="24">
<svg><defs>
<g id="add-location"><path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm4 8h-3v3h-2v-3H8V8h3V5h2v3h3v2z"></path></g>
<g id="beenhere"><path d="M19 1H5c-1.1 0-1.99.9-1.99 2L3 15.93c0 .69.35 1.3.88 1.66L12 23l8.11-5.41c.53-.36.88-.97.88-1.66L21 3c0-1.1-.9-2-2-2zm-9 15l-5-5 1.41-1.41L10 13.17l7.59-7.59L19 7l-9 9z"></path></g>
<g id="directions"><path d="M21.71 11.29l-9-9c-.39-.39-1.02-.39-1.41 0l-9 9c-.39.39-.39 1.02 0 1.41l9 9c.39.39 1.02.39 1.41 0l9-9c.39-.38.39-1.01 0-1.41zM14 14.5V12h-4v3H8v-4c0-.55.45-1 1-1h5V7.5l3.5 3.5-3.5 3.5z"></path></g>
<g id="directions-bike"><path d="M15.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM5 12c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 8.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5zm5.8-10l2.4-2.4.8.8c1.3 1.3 3 2.1 5.1 2.1V9c-1.5 0-2.7-.6-3.6-1.5l-1.9-1.9c-.5-.4-1-.6-1.6-.6s-1.1.2-1.4.6L7.8 8.4c-.4.4-.6.9-.6 1.4 0 .6.2 1.1.6 1.4L11 14v5h2v-6.2l-2.2-2.3zM19 12c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 8.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5z"></path></g>
<g id="directions-boat"><path d="M20 21c-1.39 0-2.78-.47-4-1.32-2.44 1.71-5.56 1.71-8 0C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 2.52 1.29 5.48 1.29 8 0 1.26.65 2.62.99 4 .99h2v-2h-2zM3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19zM6 6h12v3.97L12 8 6 9.97V6z"></path></g>
<g id="directions-bus"><path d="M4 16c0 .88.39 1.67 1 2.22V20c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h8v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.78c.61-.55 1-1.34 1-2.22V6c0-3.5-3.58-4-8-4s-8 .5-8 4v10zm3.5 1c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm9 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6H6V6h12v5z"></path></g>
<g id="directions-car"><path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z"></path></g>
<g id="directions-railway"><path d="M4 15.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V5c0-3.5-3.58-4-8-4s-8 .5-8 4v10.5zm8 1.5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6-7H6V5h12v5z"></path></g>
<g id="directions-run"><path d="M13.49 5.48c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-3.6 13.9l1-4.4 2.1 2v6h2v-7.5l-2.1-2 .6-3c1.3 1.5 3.3 2.5 5.5 2.5v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1l-5.2 2.2v4.7h2v-3.4l1.8-.7-1.6 8.1-4.9-1-.4 2 7 1.4z"></path></g>
<g id="directions-subway"><path d="M12 2c-4.42 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-6H6V6h5v5zm5.5 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6h-5V6h5v5z"></path></g>
<g id="directions-transit"><path d="M12 2c-4.42 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-6H6V6h5v5zm5.5 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6h-5V6h5v5z"></path></g>
<g id="directions-walk"><path d="M13.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM9.8 8.9L7 23h2.1l1.8-8 2.1 2v6h2v-7.5l-2.1-2 .6-3C14.8 12 16.8 13 19 13v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1L6 8.3V13h2V9.6l1.8-.7"></path></g>
<g id="edit-location"><path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm-1.56 10H9v-1.44l3.35-3.34 1.43 1.43L10.44 12zm4.45-4.45l-.7.7-1.44-1.44.7-.7c.15-.15.39-.15.54 0l.9.9c.15.15.15.39 0 .54z"></path></g>
<g id="ev-station"><path d="M19.77 7.23l.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33 0 1.38 1.12 2.5 2.5 2.5.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V9c0-.69-.28-1.32-.73-1.77zM18 10c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM8 18v-4.5H6L10 6v5h2l-4 7z"></path></g>
<g id="flight"><path d="M10.18 9"></path><path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"></path></g>
<g id="hotel"><path d="M7 13c1.66 0 3-1.34 3-3S8.66 7 7 7s-3 1.34-3 3 1.34 3 3 3zm12-6h-8v7H3V5H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4z"></path></g>
<g id="layers"><path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z"></path></g>
<g id="layers-clear"><path d="M19.81 14.99l1.19-.92-1.43-1.43-1.19.92 1.43 1.43zm-.45-4.72L21 9l-9-7-2.91 2.27 7.87 7.88 2.4-1.88zM3.27 1L2 2.27l4.22 4.22L3 9l1.63 1.27L12 16l2.1-1.63 1.43 1.43L12 18.54l-7.37-5.73L3 14.07l9 7 4.95-3.85L20.73 21 22 19.73 3.27 1z"></path></g>
<g id="local-activity"><path d="M20 12c0-1.1.9-2 2-2V6c0-1.1-.9-2-2-2H4c-1.1 0-1.99.9-1.99 2v4c1.1 0 1.99.9 1.99 2s-.89 2-2 2v4c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-4c-1.1 0-2-.9-2-2zm-4.42 4.8L12 14.5l-3.58 2.3 1.08-4.12-3.29-2.69 4.24-.25L12 5.8l1.54 3.95 4.24.25-3.29 2.69 1.09 4.11z"></path></g>
<g id="local-airport"><path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z"></path></g>
<g id="local-atm"><path d="M11 17h2v-1h1c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1h-3v-1h4V8h-2V7h-2v1h-1c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h3v1H9v2h2v1zm9-13H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4V6h16v12z"></path></g>
<g id="local-bar"><path d="M21 5V3H3v2l8 9v5H6v2h12v-2h-5v-5l8-9zM7.43 7L5.66 5h12.69l-1.78 2H7.43z"></path></g>
<g id="local-cafe"><path d="M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2c1.11 0 2-.89 2-2V5c0-1.11-.89-2-2-2zm0 5h-2V5h2v3zM2 21h18v-2H2v2z"></path></g>
<g id="local-car-wash"><path d="M17 5c.83 0 1.5-.67 1.5-1.5 0-1-1.5-2.7-1.5-2.7s-1.5 1.7-1.5 2.7c0 .83.67 1.5 1.5 1.5zm-5 0c.83 0 1.5-.67 1.5-1.5 0-1-1.5-2.7-1.5-2.7s-1.5 1.7-1.5 2.7c0 .83.67 1.5 1.5 1.5zM7 5c.83 0 1.5-.67 1.5-1.5C8.5 2.5 7 .8 7 .8S5.5 2.5 5.5 3.5C5.5 4.33 6.17 5 7 5zm11.92 3.01C18.72 7.42 18.16 7 17.5 7h-11c-.66 0-1.21.42-1.42 1.01L3 14v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 18c-.83 0-1.5-.67-1.5-1.5S5.67 15 6.5 15s1.5.67 1.5 1.5S7.33 18 6.5 18zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 13l1.5-4.5h11L19 13H5z"></path></g>
<g id="local-convenience-store"><path d="M19 7V4H5v3H2v13h8v-4h4v4h8V7h-3zm-8 3H9v1h2v1H8V9h2V8H8V7h3v3zm5 2h-1v-2h-2V7h1v2h1V7h1v5z"></path></g>
<g id="local-dining"><path d="M8.1 13.34l2.83-2.83L3.91 3.5c-1.56 1.56-1.56 4.09 0 5.66l4.19 4.18zm6.78-1.81c1.53.71 3.68.21 5.27-1.38 1.91-1.91 2.28-4.65.81-6.12-1.46-1.46-4.2-1.1-6.12.81-1.59 1.59-2.09 3.74-1.38 5.27L3.7 19.87l1.41 1.41L12 14.41l6.88 6.88 1.41-1.41L13.41 13l1.47-1.47z"></path></g>
<g id="local-drink"><path d="M3 2l2.01 18.23C5.13 21.23 5.97 22 7 22h10c1.03 0 1.87-.77 1.99-1.77L21 2H3zm9 17c-1.66 0-3-1.34-3-3 0-2 3-5.4 3-5.4s3 3.4 3 5.4c0 1.66-1.34 3-3 3zm6.33-11H5.67l-.44-4h13.53l-.43 4z"></path></g>
<g id="local-florist"><path d="M12 22c4.97 0 9-4.03 9-9-4.97 0-9 4.03-9 9zM5.6 10.25c0 1.38 1.12 2.5 2.5 2.5.53 0 1.01-.16 1.42-.44l-.02.19c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5l-.02-.19c.4.28.89.44 1.42.44 1.38 0 2.5-1.12 2.5-2.5 0-1-.59-1.85-1.43-2.25.84-.4 1.43-1.25 1.43-2.25 0-1.38-1.12-2.5-2.5-2.5-.53 0-1.01.16-1.42.44l.02-.19C14.5 2.12 13.38 1 12 1S9.5 2.12 9.5 3.5l.02.19c-.4-.28-.89-.44-1.42-.44-1.38 0-2.5 1.12-2.5 2.5 0 1 .59 1.85 1.43 2.25-.84.4-1.43 1.25-1.43 2.25zM12 5.5c1.38 0 2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8s1.12-2.5 2.5-2.5zM3 13c0 4.97 4.03 9 9 9 0-4.97-4.03-9-9-9z"></path></g>
<g id="local-gas-station"><path d="M19.77 7.23l.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33 0 1.38 1.12 2.5 2.5 2.5.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V9c0-.69-.28-1.32-.73-1.77zM12 10H6V5h6v5zm6 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path></g>
<g id="local-grocery-store"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="local-hospital"><path d="M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4v4z"></path></g>
<g id="local-hotel"><path d="M7 13c1.66 0 3-1.34 3-3S8.66 7 7 7s-3 1.34-3 3 1.34 3 3 3zm12-6h-8v7H3V5H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4z"></path></g>
<g id="local-laundry-service"><path d="M9.17 16.83c1.56 1.56 4.1 1.56 5.66 0 1.56-1.56 1.56-4.1 0-5.66l-5.66 5.66zM18 2.01L6 2c-1.11 0-2 .89-2 2v16c0 1.11.89 2 2 2h12c1.11 0 2-.89 2-2V4c0-1.11-.89-1.99-2-1.99zM10 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM7 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm5 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"></path></g>
<g id="local-library"><path d="M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z"></path></g>
<g id="local-mall"><path d="M19 6h-2c0-2.76-2.24-5-5-5S7 3.24 7 6H5c-1.1 0-1.99.9-1.99 2L3 20c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-7-3c1.66 0 3 1.34 3 3H9c0-1.66 1.34-3 3-3zm0 10c-2.76 0-5-2.24-5-5h2c0 1.66 1.34 3 3 3s3-1.34 3-3h2c0 2.76-2.24 5-5 5z"></path></g>
<g id="local-movies"><path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"></path></g>
<g id="local-offer"><path d="M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z"></path></g>
<g id="local-parking"><path d="M13 3H6v18h4v-6h3c3.31 0 6-2.69 6-6s-2.69-6-6-6zm.2 8H10V7h3.2c1.1 0 2 .9 2 2s-.9 2-2 2z"></path></g>
<g id="local-pharmacy"><path d="M21 5h-2.64l1.14-3.14L17.15 1l-1.46 4H3v2l2 6-2 6v2h18v-2l-2-6 2-6V5zm-5 9h-3v3h-2v-3H8v-2h3V9h2v3h3v2z"></path></g>
<g id="local-phone"><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"></path></g>
<g id="local-pizza"><path d="M12 2C8.43 2 5.23 3.54 3.01 6L12 22l8.99-16C18.78 3.55 15.57 2 12 2zM7 7c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm5 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="local-play"><path d="M20 12c0-1.1.9-2 2-2V6c0-1.1-.9-2-2-2H4c-1.1 0-1.99.9-1.99 2v4c1.1 0 1.99.9 1.99 2s-.89 2-2 2v4c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-4c-1.1 0-2-.9-2-2zm-4.42 4.8L12 14.5l-3.58 2.3 1.08-4.12-3.29-2.69 4.24-.25L12 5.8l1.54 3.95 4.24.25-3.29 2.69 1.09 4.11z"></path></g>
<g id="local-post-office"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="local-printshop"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"></path></g>
<g id="local-see"><circle cx="12" cy="12" r="3.2"></circle><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"></path></g>
<g id="local-shipping"><path d="M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-3-4zM6 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm13.5-9l1.96 2.5H17V9.5h2.5zm-1.5 9c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="local-taxi"><path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5H15V3H9v2H6.5c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z"></path></g>
<g id="map"><path d="M20.5 3l-.16.03L15 5.1 9 3 3.36 4.9c-.21.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.21-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5zM15 19l-6-2.11V5l6 2.11V19z"></path></g>
<g id="my-location"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path></g>
<g id="navigation"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"></path></g>
<g id="near-me"><path d="M21 3L3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z"></path></g>
<g id="person-pin"><path d="M19 2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h4l3 3 3-3h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 3.3c1.49 0 2.7 1.21 2.7 2.7 0 1.49-1.21 2.7-2.7 2.7-1.49 0-2.7-1.21-2.7-2.7 0-1.49 1.21-2.7 2.7-2.7zM18 16H6v-.9c0-2 4-3.1 6-3.1s6 1.1 6 3.1v.9z"></path></g>
<g id="person-pin-circle"><path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm0 2c1.1 0 2 .9 2 2 0 1.11-.9 2-2 2s-2-.89-2-2c0-1.1.9-2 2-2zm0 10c-1.67 0-3.14-.85-4-2.15.02-1.32 2.67-2.05 4-2.05s3.98.73 4 2.05c-.86 1.3-2.33 2.15-4 2.15z"></path></g>
<g id="pin-drop"><path d="M18 8c0-3.31-2.69-6-6-6S6 4.69 6 8c0 4.5 6 11 6 11s6-6.5 6-11zm-8 0c0-1.1.9-2 2-2s2 .9 2 2-.89 2-2 2c-1.1 0-2-.9-2-2zM5 20v2h14v-2H5z"></path></g>
<g id="place"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="rate-review"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 14v-2.47l6.88-6.88c.2-.2.51-.2.71 0l1.77 1.77c.2.2.2.51 0 .71L8.47 14H6zm12 0h-7.5l2-2H18v2z"></path></g>
<g id="restaurant"><path d="M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7zm5-3v8h2.5v8H21V2c-2.76 0-5 2.24-5 4z"></path></g>
<g id="restaurant-menu"><path d="M8.1 13.34l2.83-2.83L3.91 3.5c-1.56 1.56-1.56 4.09 0 5.66l4.19 4.18zm6.78-1.81c1.53.71 3.68.21 5.27-1.38 1.91-1.91 2.28-4.65.81-6.12-1.46-1.46-4.2-1.1-6.12.81-1.59 1.59-2.09 3.74-1.38 5.27L3.7 19.87l1.41 1.41L12 14.41l6.88 6.88 1.41-1.41L13.41 13l1.47-1.47z"></path></g>
<g id="satellite"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5 4.99h3C8 6.65 6.66 8 5 8V4.99zM5 12v-2c2.76 0 5-2.25 5-5.01h2C12 8.86 8.87 12 5 12zm0 6l3.5-4.5 2.5 3.01L14.5 12l4.5 6H5z"></path></g>
<g id="store-mall-directory"><path d="M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z"></path></g>
<g id="streetview"><path d="M12.56 14.33c-.34.27-.56.7-.56 1.17V21h7c1.1 0 2-.9 2-2v-5.98c-.94-.33-1.95-.52-3-.52-2.03 0-3.93.7-5.44 1.83z"></path><circle cx="18" cy="6" r="5"></circle><path d="M11.5 6c0-1.08.27-2.1.74-3H5c-1.1 0-2 .9-2 2v14c0 .55.23 1.05.59 1.41l9.82-9.82C12.23 9.42 11.5 7.8 11.5 6z"></path></g>
<g id="subway"><circle cx="15.5" cy="16" r="1"></circle><circle cx="8.5" cy="16" r="1"></circle><path d="M7.01 9h10v5h-10zM17.8 2.8C16 2.09 13.86 2 12 2c-1.86 0-4 .09-5.8.8C3.53 3.84 2 6.05 2 8.86V22h20V8.86c0-2.81-1.53-5.02-4.2-6.06zm.2 13.08c0 1.45-1.18 2.62-2.63 2.62l1.13 1.12V20H15l-1.5-1.5h-2.83L9.17 20H7.5v-.38l1.12-1.12C7.18 18.5 6 17.32 6 15.88V9c0-2.63 3-3 6-3 3.32 0 6 .38 6 3v6.88z"></path></g>
<g id="terrain"><path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"></path></g>
<g id="traffic"><path d="M20 10h-3V8.86c1.72-.45 3-2 3-3.86h-3V4c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v1H4c0 1.86 1.28 3.41 3 3.86V10H4c0 1.86 1.28 3.41 3 3.86V15H4c0 1.86 1.28 3.41 3 3.86V20c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-1.14c1.72-.45 3-2 3-3.86h-3v-1.14c1.72-.45 3-2 3-3.86zm-8 9c-1.11 0-2-.9-2-2s.89-2 2-2c1.1 0 2 .9 2 2s-.89 2-2 2zm0-5c-1.11 0-2-.9-2-2s.89-2 2-2c1.1 0 2 .9 2 2s-.89 2-2 2zm0-5c-1.11 0-2-.9-2-2 0-1.11.89-2 2-2 1.1 0 2 .89 2 2 0 1.1-.89 2-2 2z"></path></g>
<g id="train"><path d="M12 2c-4 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h2.23l2-2H14l2 2h2v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-7H6V6h5v4zm2 0V6h5v4h-5zm3.5 7c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="tram"><path d="M19 16.94V8.5c0-2.79-2.61-3.4-6.01-3.49l.76-1.51H17V2H7v1.5h4.75l-.76 1.52C7.86 5.11 5 5.73 5 8.5v8.44c0 1.45 1.19 2.66 2.59 2.97L6 21.5v.5h2.23l2-2H14l2 2h2v-.5L16.5 20h-.08c1.69 0 2.58-1.37 2.58-3.06zm-7 1.56c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm5-4.5H7V9h10v5z"></path></g>
<g id="transfer-within-a-station"><path d="M16.49 15.5v-1.75L14 16.25l2.49 2.5V17H22v-1.5zm3.02 4.25H14v1.5h5.51V23L22 20.5 19.51 18zM9.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM5.75 8.9L3 23h2.1l1.75-8L9 17v6h2v-7.55L8.95 13.4l.6-3C10.85 12 12.8 13 15 13v-2c-1.85 0-3.45-1-4.35-2.45l-.95-1.6C9.35 6.35 8.7 6 8 6c-.25 0-.5.05-.75.15L2 8.3V13h2V9.65l1.75-.75"></path></g>
<g id="zoom-out-map"><path d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z"></path></g>
</defs></svg>
</iron-iconset-svg>`;
document.head.appendChild(template$5.content);

/**
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template$6 = html`<iron-iconset-svg name="image" size="24">
<svg><defs>
<g id="add-a-photo"><path d="M3 4V1h2v3h3v2H5v3H3V6H0V4h3zm3 6V7h3V4h7l1.83 2H21c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V10h3zm7 9c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-3.2-5c0 1.77 1.43 3.2 3.2 3.2s3.2-1.43 3.2-3.2-1.43-3.2-3.2-3.2-3.2 1.43-3.2 3.2z"></path></g>
<g id="add-to-photos"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z"></path></g>
<g id="adjust"><path d="M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3-8c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3z"></path></g>
<g id="assistant"><path d="M19 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h4l3 3 3-3h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5.12 10.88L12 17l-1.88-4.12L6 11l4.12-1.88L12 5l1.88 4.12L18 11l-4.12 1.88z"></path></g>
<g id="assistant-photo"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></g>
<g id="audiotrack"><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z"></path></g>
<g id="blur-circular"><path d="M10 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM7 9.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm3 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-3-3c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm3-6c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-1.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm3 6c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-4c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm2-3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-3.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"></path></g>
<g id="blur-linear"><path d="M5 17.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 13c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zM3 21h18v-2H3v2zM5 9.5c.83 0 1.5-.67 1.5-1.5S5.83 6.5 5 6.5 3.5 7.17 3.5 8 4.17 9.5 5 9.5zm0 4c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 17c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8-.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM3 3v2h18V3H3zm14 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm0 4c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM13 9c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1z"></path></g>
<g id="blur-off"><path d="M14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm-.2 4.48l.2.02c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5l.02.2c.09.67.61 1.19 1.28 1.28zM14 3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-4 0c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm11 7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8 8c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm-4 13.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM2.5 5.27l3.78 3.78L6 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.03-.19-.06-.28l2.81 2.81c-.71.11-1.25.73-1.25 1.47 0 .83.67 1.5 1.5 1.5.74 0 1.36-.54 1.47-1.25l2.81 2.81c-.09-.03-.18-.06-.28-.06-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.03-.19-.06-.28l3.78 3.78L20 20.23 3.77 4 2.5 5.27zM10 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm11-3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM3 9.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 11c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3-3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5z"></path></g>
<g id="blur-on"><path d="M6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3 .5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-11 10c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-17c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 5.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm8 .5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3 8.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM14 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-4-12c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 8.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-4.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-4c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path></g>
<g id="brightness-1"><circle cx="12" cy="12" r="10"></circle></g>
<g id="brightness-2"><path d="M10 2c-1.82 0-3.53.5-5 1.35C7.99 5.08 10 8.3 10 12s-2.01 6.92-5 8.65C6.47 21.5 8.18 22 10 22c5.52 0 10-4.48 10-10S15.52 2 10 2z"></path></g>
<g id="brightness-3"><path d="M9 2c-1.05 0-2.05.16-3 .46 4.06 1.27 7 5.06 7 9.54 0 4.48-2.94 8.27-7 9.54.95.3 1.95.46 3 .46 5.52 0 10-4.48 10-10S14.52 2 9 2z"></path></g>
<g id="brightness-4"><path d="M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6c3.31 0 6 2.69 6 6s-2.69 6-6 6z"></path></g>
<g id="brightness-5"><path d="M20 15.31L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"></path></g>
<g id="brightness-6"><path d="M20 15.31L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18V6c3.31 0 6 2.69 6 6s-2.69 6-6 6z"></path></g>
<g id="brightness-7"><path d="M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></g>
<g id="broken-image"><path d="M21 5v6.59l-3-3.01-4 4.01-4-4-4 4-3-3.01V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2zm-3 6.42l3 3.01V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-6.58l3 2.99 4-4 4 4 4-3.99z"></path></g>
<g id="brush"><path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"></path></g>
<g id="burst-mode"><path d="M1 5h2v14H1zm4 0h2v14H5zm17 0H10c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM11 17l2.5-3.15L15.29 16l2.5-3.22L21 17H11z"></path></g>
<g id="camera"><path d="M9.4 10.5l4.77-8.26C13.47 2.09 12.75 2 12 2c-2.4 0-4.6.85-6.32 2.25l3.66 6.35.06-.1zM21.54 9c-.92-2.92-3.15-5.26-6-6.34L11.88 9h9.66zm.26 1h-7.49l.29.5 4.76 8.25C21 16.97 22 14.61 22 12c0-.69-.07-1.35-.2-2zM8.54 12l-3.9-6.75C3.01 7.03 2 9.39 2 12c0 .69.07 1.35.2 2h7.49l-1.15-2zm-6.08 3c.92 2.92 3.15 5.26 6 6.34L12.12 15H2.46zm11.27 0l-3.9 6.76c.7.15 1.42.24 2.17.24 2.4 0 4.6-.85 6.32-2.25l-3.66-6.35-.93 1.6z"></path></g>
<g id="camera-alt"><circle cx="12" cy="12" r="3.2"></circle><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"></path></g>
<g id="camera-front"><path d="M10 20H5v2h5v2l3-3-3-3v2zm4 0v2h5v-2h-5zM12 8c1.1 0 2-.9 2-2s-.9-2-2-2-1.99.9-1.99 2S10.9 8 12 8zm5-8H7C5.9 0 5 .9 5 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zM7 2h10v10.5c0-1.67-3.33-2.5-5-2.5s-5 .83-5 2.5V2z"></path></g>
<g id="camera-rear"><path d="M10 20H5v2h5v2l3-3-3-3v2zm4 0v2h5v-2h-5zm3-20H7C5.9 0 5 .9 5 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zm-5 6c-1.11 0-2-.9-2-2s.89-2 1.99-2 2 .9 2 2C14 5.1 13.1 6 12 6z"></path></g>
<g id="camera-roll"><path d="M14 5c0-1.1-.9-2-2-2h-1V2c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v1H4c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2h8V5h-8zm-2 13h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2z"></path></g>
<g id="center-focus-strong"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm-7 7H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4z"></path></g>
<g id="center-focus-weak"><path d="M5 15H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="collections"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"></path></g>
<g id="collections-bookmark"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 10l-2.5-1.5L15 12V4h5v8z"></path></g>
<g id="color-lens"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="colorize"><path d="M20.71 5.63l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42zM6.92 19L5 17.08l8.06-8.06 1.92 1.92L6.92 19z"></path></g>
<g id="compare"><path d="M10 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h5v2h2V1h-2v2zm0 15H5l5-6v6zm9-15h-5v2h5v13l-5-6v9h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="control-point"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="control-point-duplicate"><path d="M16 8h-2v3h-3v2h3v3h2v-3h3v-2h-3zM2 12c0-2.79 1.64-5.2 4.01-6.32V3.52C2.52 4.76 0 8.09 0 12s2.52 7.24 6.01 8.48v-2.16C3.64 17.2 2 14.79 2 12zm13-9c-4.96 0-9 4.04-9 9s4.04 9 9 9 9-4.04 9-9-4.04-9-9-9zm0 16c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7z"></path></g>
<g id="crop"><path d="M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z"></path></g>
<g id="crop-16-9"><path d="M19 6H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H5V8h14v8z"></path></g>
<g id="crop-3-2"><path d="M19 4H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H5V6h14v12z"></path></g>
<g id="crop-5-4"><path d="M19 5H5c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 12H5V7h14v10z"></path></g>
<g id="crop-7-5"><path d="M19 7H5c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zm0 8H5V9h14v6z"></path></g>
<g id="crop-din"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"></path></g>
<g id="crop-free"><path d="M3 5v4h2V5h4V3H5c-1.1 0-2 .9-2 2zm2 10H3v4c0 1.1.9 2 2 2h4v-2H5v-4zm14 4h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zm0-16h-4v2h4v4h2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="crop-landscape"><path d="M19 5H5c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 12H5V7h14v10z"></path></g>
<g id="crop-original"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-5.04-6.71l-2.75 3.54-1.96-2.36L6.5 17h11l-3.54-4.71z"></path></g>
<g id="crop-portrait"><path d="M17 3H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H7V5h10v14z"></path></g>
<g id="crop-rotate"><path d="M7.47 21.49C4.2 19.93 1.86 16.76 1.5 13H0c.51 6.16 5.66 11 11.95 11 .23 0 .44-.02.66-.03L8.8 20.15l-1.33 1.34zM12.05 0c-.23 0-.44.02-.66.04l3.81 3.81 1.33-1.33C19.8 4.07 22.14 7.24 22.5 11H24c-.51-6.16-5.66-11-11.95-11zM16 14h2V8c0-1.11-.9-2-2-2h-6v2h6v6zm-8 2V4H6v2H4v2h2v8c0 1.1.89 2 2 2h8v2h2v-2h2v-2H8z"></path></g>
<g id="crop-square"><path d="M18 4H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H6V6h12v12z"></path></g>
<g id="dehaze"><path d="M2 15.5v2h20v-2H2zm0-5v2h20v-2H2zm0-5v2h20v-2H2z"></path></g>
<g id="details"><path d="M3 4l9 16 9-16H3zm3.38 2h11.25L12 16 6.38 6z"></path></g>
<g id="edit"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
<g id="exposure"><path d="M15 17v2h2v-2h2v-2h-2v-2h-2v2h-2v2h2zm5-15H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM5 5h6v2H5V5zm15 15H4L20 4v16z"></path></g>
<g id="exposure-neg-1"><path d="M4 11v2h8v-2H4zm15 7h-2V7.38L14 8.4V6.7L18.7 5h.3v13z"></path></g>
<g id="exposure-neg-2"><path d="M15.05 16.29l2.86-3.07c.38-.39.72-.79 1.04-1.18.32-.39.59-.78.82-1.17.23-.39.41-.78.54-1.17s.19-.79.19-1.18c0-.53-.09-1.02-.27-1.46-.18-.44-.44-.81-.78-1.11-.34-.31-.77-.54-1.26-.71-.51-.16-1.08-.24-1.72-.24-.69 0-1.31.11-1.85.32-.54.21-1 .51-1.36.88-.37.37-.65.8-.84 1.3-.18.47-.27.97-.28 1.5h2.14c.01-.31.05-.6.13-.87.09-.29.23-.54.4-.75.18-.21.41-.37.68-.49.27-.12.6-.18.96-.18.31 0 .58.05.81.15.23.1.43.25.59.43.16.18.28.4.37.65.08.25.13.52.13.81 0 .22-.03.43-.08.65-.06.22-.15.45-.29.7-.14.25-.32.53-.56.83-.23.3-.52.65-.88 1.03l-4.17 4.55V18H21v-1.71h-5.95zM2 11v2h8v-2H2z"></path></g>
<g id="exposure-plus-1"><path d="M10 7H8v4H4v2h4v4h2v-4h4v-2h-4V7zm10 11h-2V7.38L15 8.4V6.7L19.7 5h.3v13z"></path></g>
<g id="exposure-plus-2"><path d="M16.05 16.29l2.86-3.07c.38-.39.72-.79 1.04-1.18.32-.39.59-.78.82-1.17.23-.39.41-.78.54-1.17.13-.39.19-.79.19-1.18 0-.53-.09-1.02-.27-1.46-.18-.44-.44-.81-.78-1.11-.34-.31-.77-.54-1.26-.71-.51-.16-1.08-.24-1.72-.24-.69 0-1.31.11-1.85.32-.54.21-1 .51-1.36.88-.37.37-.65.8-.84 1.3-.18.47-.27.97-.28 1.5h2.14c.01-.31.05-.6.13-.87.09-.29.23-.54.4-.75.18-.21.41-.37.68-.49.27-.12.6-.18.96-.18.31 0 .58.05.81.15.23.1.43.25.59.43.16.18.28.4.37.65.08.25.13.52.13.81 0 .22-.03.43-.08.65-.06.22-.15.45-.29.7-.14.25-.32.53-.56.83-.23.3-.52.65-.88 1.03l-4.17 4.55V18H22v-1.71h-5.95zM8 7H6v4H2v2h4v4h2v-4h4v-2H8V7z"></path></g>
<g id="exposure-zero"><path d="M16.14 12.5c0 1-.1 1.85-.3 2.55-.2.7-.48 1.27-.83 1.7-.36.44-.79.75-1.3.95-.51.2-1.07.3-1.7.3-.62 0-1.18-.1-1.69-.3-.51-.2-.95-.51-1.31-.95-.36-.44-.65-1.01-.85-1.7-.2-.7-.3-1.55-.3-2.55v-2.04c0-1 .1-1.85.3-2.55.2-.7.48-1.26.84-1.69.36-.43.8-.74 1.31-.93C10.81 5.1 11.38 5 12 5c.63 0 1.19.1 1.7.29.51.19.95.5 1.31.93.36.43.64.99.84 1.69.2.7.3 1.54.3 2.55v2.04zm-2.11-2.36c0-.64-.05-1.18-.13-1.62-.09-.44-.22-.79-.4-1.06-.17-.27-.39-.46-.64-.58-.25-.13-.54-.19-.86-.19-.32 0-.61.06-.86.18s-.47.31-.64.58c-.17.27-.31.62-.4 1.06s-.13.98-.13 1.62v2.67c0 .64.05 1.18.14 1.62.09.45.23.81.4 1.09s.39.48.64.61.54.19.87.19c.33 0 .62-.06.87-.19s.46-.33.63-.61c.17-.28.3-.64.39-1.09.09-.45.13-.99.13-1.62v-2.66z"></path></g>
<g id="filter"><path d="M15.96 10.29l-2.75 3.54-1.96-2.36L8.5 15h11l-3.54-4.71zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"></path></g>
<g id="filter-1"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm11 10h2V5h-4v2h2v8zm7-14H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"></path></g>
<g id="filter-2"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-4-4h-4v-2h2c1.1 0 2-.89 2-2V7c0-1.11-.9-2-2-2h-4v2h4v2h-2c-1.1 0-2 .89-2 2v4h6v-2z"></path></g>
<g id="filter-3"><path d="M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm14 8v-1.5c0-.83-.67-1.5-1.5-1.5.83 0 1.5-.67 1.5-1.5V7c0-1.11-.9-2-2-2h-4v2h4v2h-2v2h2v2h-4v2h4c1.1 0 2-.89 2-2z"></path></g>
<g id="filter-4"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm12 10h2V5h-2v4h-2V5h-2v6h4v4zm6-14H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"></path></g>
<g id="filter-5"><path d="M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm14 8v-2c0-1.11-.9-2-2-2h-2V7h4V5h-6v6h4v2h-4v2h4c1.1 0 2-.89 2-2z"></path></g>
<g id="filter-6"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-8-2h2c1.1 0 2-.89 2-2v-2c0-1.11-.9-2-2-2h-2V7h4V5h-4c-1.1 0-2 .89-2 2v6c0 1.11.9 2 2 2zm0-4h2v2h-2v-2z"></path></g>
<g id="filter-7"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-8-2l4-8V5h-6v2h4l-4 8h2z"></path></g>
<g id="filter-8"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-8-2h2c1.1 0 2-.89 2-2v-1.5c0-.83-.67-1.5-1.5-1.5.83 0 1.5-.67 1.5-1.5V7c0-1.11-.9-2-2-2h-2c-1.1 0-2 .89-2 2v1.5c0 .83.67 1.5 1.5 1.5-.83 0-1.5.67-1.5 1.5V13c0 1.11.9 2 2 2zm0-8h2v2h-2V7zm0 4h2v2h-2v-2z"></path></g>
<g id="filter-9"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zM15 5h-2c-1.1 0-2 .89-2 2v2c0 1.11.9 2 2 2h2v2h-4v2h4c1.1 0 2-.89 2-2V7c0-1.11-.9-2-2-2zm0 4h-2V7h2v2z"></path></g>
<g id="filter-9-plus"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm11 7V8c0-1.11-.9-2-2-2h-1c-1.1 0-2 .89-2 2v1c0 1.11.9 2 2 2h1v1H9v2h3c1.1 0 2-.89 2-2zm-3-3V8h1v1h-1zm10-8H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 8h-2V7h-2v2h-2v2h2v2h2v-2h2v6H7V3h14v6z"></path></g>
<g id="filter-b-and-w"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16l-7-8v8H5l7-8V5h7v14z"></path></g>
<g id="filter-center-focus"><path d="M5 15H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zM12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
<g id="filter-drama"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.61 5.64 5.36 8.04 2.35 8.36 0 10.9 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4h2c0-2.76-1.86-5.08-4.4-5.78C8.61 6.88 10.2 6 12 6c3.03 0 5.5 2.47 5.5 5.5v.5H19c1.65 0 3 1.35 3 3s-1.35 3-3 3z"></path></g>
<g id="filter-frames"><path d="M20 4h-4l-4-4-4 4H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H4V6h4.52l3.52-3.5L15.52 6H20v14zM18 8H6v10h12"></path></g>
<g id="filter-hdr"><path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"></path></g>
<g id="filter-none"><path d="M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z"></path></g>
<g id="filter-tilt-shift"><path d="M11 4.07V2.05c-2.01.2-3.84 1-5.32 2.21L7.1 5.69c1.11-.86 2.44-1.44 3.9-1.62zm7.32.19C16.84 3.05 15.01 2.25 13 2.05v2.02c1.46.18 2.79.76 3.9 1.62l1.42-1.43zM19.93 11h2.02c-.2-2.01-1-3.84-2.21-5.32L18.31 7.1c.86 1.11 1.44 2.44 1.62 3.9zM5.69 7.1L4.26 5.68C3.05 7.16 2.25 8.99 2.05 11h2.02c.18-1.46.76-2.79 1.62-3.9zM4.07 13H2.05c.2 2.01 1 3.84 2.21 5.32l1.43-1.43c-.86-1.1-1.44-2.43-1.62-3.89zM15 12c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3 3-1.34 3-3zm3.31 4.9l1.43 1.43c1.21-1.48 2.01-3.32 2.21-5.32h-2.02c-.18 1.45-.76 2.78-1.62 3.89zM13 19.93v2.02c2.01-.2 3.84-1 5.32-2.21l-1.43-1.43c-1.1.86-2.43 1.44-3.89 1.62zm-7.32-.19C7.16 20.95 9 21.75 11 21.95v-2.02c-1.46-.18-2.79-.76-3.9-1.62l-1.42 1.43z"></path></g>
<g id="filter-vintage"><path d="M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"></path></g>
<g id="flare"><path d="M7 11H1v2h6v-2zm2.17-3.24L7.05 5.64 5.64 7.05l2.12 2.12 1.41-1.41zM13 1h-2v6h2V1zm5.36 6.05l-1.41-1.41-2.12 2.12 1.41 1.41 2.12-2.12zM17 11v2h6v-2h-6zm-5-2c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm2.83 7.24l2.12 2.12 1.41-1.41-2.12-2.12-1.41 1.41zm-9.19.71l1.41 1.41 2.12-2.12-1.41-1.41-2.12 2.12zM11 23h2v-6h-2v6z"></path></g>
<g id="flash-auto"><path d="M3 2v12h3v9l7-12H9l4-9H3zm16 0h-2l-3.2 9h1.9l.7-2h3.2l.7 2h1.9L19 2zm-2.15 5.65L18 4l1.15 3.65h-2.3z"></path></g>
<g id="flash-off"><path d="M3.27 3L2 4.27l5 5V13h3v9l3.58-6.14L17.73 20 19 18.73 3.27 3zM17 10h-4l4-8H7v2.18l8.46 8.46L17 10z"></path></g>
<g id="flash-on"><path d="M7 2v11h3v9l7-12h-4l4-8z"></path></g>
<g id="flip"><path d="M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"></path></g>
<g id="gradient"><path d="M11 9h2v2h-2zm-2 2h2v2H9zm4 0h2v2h-2zm2-2h2v2h-2zM7 9h2v2H7zm12-6H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 18H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm2-7h-2v2h2v2h-2v-2h-2v2h-2v-2h-2v2H9v-2H7v2H5v-2h2v-2H5V5h14v6z"></path></g>
<g id="grain"><path d="M10 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-4 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="grid-off"><path d="M8 4v1.45l2 2V4h4v4h-3.45l2 2H14v1.45l2 2V10h4v4h-3.45l2 2H20v1.45l2 2V4c0-1.1-.9-2-2-2H4.55l2 2H8zm8 0h4v4h-4V4zM1.27 1.27L0 2.55l2 2V20c0 1.1.9 2 2 2h15.46l2 2 1.27-1.27L1.27 1.27zM10 12.55L11.45 14H10v-1.45zm-6-6L5.45 8H4V6.55zM8 20H4v-4h4v4zm0-6H4v-4h3.45l.55.55V14zm6 6h-4v-4h3.45l.55.54V20zm2 0v-1.46L17.46 20H16z"></path></g>
<g id="grid-on"><path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"></path></g>
<g id="hdr-off"><path d="M17.5 15v-2h1.1l.9 2H21l-.9-2.1c.5-.2.9-.8.9-1.4v-1c0-.8-.7-1.5-1.5-1.5H16v4.9l1.1 1.1h.4zm0-4.5h2v1h-2v-1zm-4.5 0v.4l1.5 1.5v-1.9c0-.8-.7-1.5-1.5-1.5h-1.9l1.5 1.5h.4zm-3.5-1l-7-7-1.1 1L6.9 9h-.4v2h-2V9H3v6h1.5v-2.5h2V15H8v-4.9l1.5 1.5V15h3.4l7.6 7.6 1.1-1.1-12.1-12z"></path></g>
<g id="hdr-on"><path d="M21 11.5v-1c0-.8-.7-1.5-1.5-1.5H16v6h1.5v-2h1.1l.9 2H21l-.9-2.1c.5-.3.9-.8.9-1.4zm-1.5 0h-2v-1h2v1zm-13-.5h-2V9H3v6h1.5v-2.5h2V15H8V9H6.5v2zM13 9H9.5v6H13c.8 0 1.5-.7 1.5-1.5v-3c0-.8-.7-1.5-1.5-1.5zm0 4.5h-2v-3h2v3z"></path></g>
<g id="hdr-strong"><path d="M17 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zM5 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="hdr-weak"><path d="M5 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm12-2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"></path></g>
<g id="healing"><path d="M17.73 12.02l3.98-3.98c.39-.39.39-1.02 0-1.41l-4.34-4.34c-.39-.39-1.02-.39-1.41 0l-3.98 3.98L8 2.29C7.8 2.1 7.55 2 7.29 2c-.25 0-.51.1-.7.29L2.25 6.63c-.39.39-.39 1.02 0 1.41l3.98 3.98L2.25 16c-.39.39-.39 1.02 0 1.41l4.34 4.34c.39.39 1.02.39 1.41 0l3.98-3.98 3.98 3.98c.2.2.45.29.71.29.26 0 .51-.1.71-.29l4.34-4.34c.39-.39.39-1.02 0-1.41l-3.99-3.98zM12 9c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-4.71 1.96L3.66 7.34l3.63-3.63 3.62 3.62-3.62 3.63zM10 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm2 2c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm2-4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2.66 9.34l-3.63-3.62 3.63-3.63 3.62 3.62-3.62 3.63z"></path></g>
<g id="image"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"></path></g>
<g id="image-aspect-ratio"><path d="M16 10h-2v2h2v-2zm0 4h-2v2h2v-2zm-8-4H6v2h2v-2zm4 0h-2v2h2v-2zm8-6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V6h16v12z"></path></g>
<g id="iso"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5.5 7.5h2v-2H9v2h2V9H9v2H7.5V9h-2V7.5zM19 19H5L19 5v14zm-2-2v-1.5h-5V17h5z"></path></g>
<g id="landscape"><path d="M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z"></path></g>
<g id="leak-add"><path d="M6 3H3v3c1.66 0 3-1.34 3-3zm8 0h-2c0 4.97-4.03 9-9 9v2c6.08 0 11-4.93 11-11zm-4 0H8c0 2.76-2.24 5-5 5v2c3.87 0 7-3.13 7-7zm0 18h2c0-4.97 4.03-9 9-9v-2c-6.07 0-11 4.93-11 11zm8 0h3v-3c-1.66 0-3 1.34-3 3zm-4 0h2c0-2.76 2.24-5 5-5v-2c-3.87 0-7 3.13-7 7z"></path></g>
<g id="leak-remove"><path d="M10 3H8c0 .37-.04.72-.12 1.06l1.59 1.59C9.81 4.84 10 3.94 10 3zM3 4.27l2.84 2.84C5.03 7.67 4.06 8 3 8v2c1.61 0 3.09-.55 4.27-1.46L8.7 9.97C7.14 11.24 5.16 12 3 12v2c2.71 0 5.19-.99 7.11-2.62l2.5 2.5C10.99 15.81 10 18.29 10 21h2c0-2.16.76-4.14 2.03-5.69l1.43 1.43C14.55 17.91 14 19.39 14 21h2c0-1.06.33-2.03.89-2.84L19.73 21 21 19.73 4.27 3 3 4.27zM14 3h-2c0 1.5-.37 2.91-1.02 4.16l1.46 1.46C13.42 6.98 14 5.06 14 3zm5.94 13.12c.34-.08.69-.12 1.06-.12v-2c-.94 0-1.84.19-2.66.52l1.6 1.6zm-4.56-4.56l1.46 1.46C18.09 12.37 19.5 12 21 12v-2c-2.06 0-3.98.58-5.62 1.56z"></path></g>
<g id="lens"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"></path></g>
<g id="linked-camera"><circle cx="12" cy="14" r="3.2"></circle><path d="M16 3.33c2.58 0 4.67 2.09 4.67 4.67H22c0-3.31-2.69-6-6-6v1.33M16 6c1.11 0 2 .89 2 2h1.33c0-1.84-1.49-3.33-3.33-3.33V6"></path><path d="M17 9c0-1.11-.89-2-2-2V4H9L7.17 6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9h-5zm-5 10c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"></path></g>
<g id="looks"><path d="M12 10c-3.86 0-7 3.14-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.86-3.14-7-7-7zm0-4C5.93 6 1 10.93 1 17h2c0-4.96 4.04-9 9-9s9 4.04 9 9h2c0-6.07-4.93-11-11-11z"></path></g>
<g id="looks-3"><path d="M19.01 3h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 7.5c0 .83-.67 1.5-1.5 1.5.83 0 1.5.67 1.5 1.5V15c0 1.11-.9 2-2 2h-4v-2h4v-2h-2v-2h2V9h-4V7h4c1.1 0 2 .89 2 2v1.5z"></path></g>
<g id="looks-4"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 14h-2v-4H9V7h2v4h2V7h2v10z"></path></g>
<g id="looks-5"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h2c1.1 0 2 .89 2 2v2c0 1.11-.9 2-2 2H9v-2h4v-2H9V7h6v2z"></path></g>
<g id="looks-6"><path d="M11 15h2v-2h-2v2zm8-12H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h2c1.1 0 2 .89 2 2v2c0 1.11-.9 2-2 2h-2c-1.1 0-2-.89-2-2V9c0-1.11.9-2 2-2h4v2z"></path></g>
<g id="looks-one"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14h-2V9h-2V7h4v10z"></path></g>
<g id="looks-two"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 8c0 1.11-.9 2-2 2h-2v2h4v2H9v-4c0-1.11.9-2 2-2h2V9H9V7h4c1.1 0 2 .89 2 2v2z"></path></g>
<g id="loupe"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10h8c1.1 0 2-.9 2-2v-8c0-5.51-4.49-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="monochrome-photos"><path d="M20 5h-3.2L15 3H9L7.2 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14h-8v-1c-2.8 0-5-2.2-5-5s2.2-5 5-5V7h8v12zm-3-6c0-2.8-2.2-5-5-5v1.8c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2V18c2.8 0 5-2.2 5-5zm-8.2 0c0 1.8 1.4 3.2 3.2 3.2V9.8c-1.8 0-3.2 1.4-3.2 3.2z"></path></g>
<g id="movie-creation"><path d="M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z"></path></g>
<g id="movie-filter"><path d="M18 4l2 3h-3l-2-3h-2l2 3h-3l-2-3H8l2 3H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4zm-6.75 11.25L10 18l-1.25-2.75L6 14l2.75-1.25L10 10l1.25 2.75L14 14l-2.75 1.25zm5.69-3.31L16 14l-.94-2.06L13 11l2.06-.94L16 8l.94 2.06L19 11l-2.06.94z"></path></g>
<g id="music-note"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"></path></g>
<g id="nature"><path d="M13 16.12c3.47-.41 6.17-3.36 6.17-6.95 0-3.87-3.13-7-7-7s-7 3.13-7 7c0 3.47 2.52 6.34 5.83 6.89V20H5v2h14v-2h-6v-3.88z"></path></g>
<g id="nature-people"><path d="M22.17 9.17c0-3.87-3.13-7-7-7s-7 3.13-7 7c0 3.47 2.52 6.34 5.83 6.89V20H6v-3h1v-4c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v4h1v5h16v-2h-3v-3.88c3.47-.41 6.17-3.36 6.17-6.95zM4.5 11c.83 0 1.5-.67 1.5-1.5S5.33 8 4.5 8 3 8.67 3 9.5 3.67 11 4.5 11z"></path></g>
<g id="navigate-before"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="navigate-next"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
<g id="palette"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="panorama"><path d="M23 18V6c0-1.1-.9-2-2-2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zM8.5 12.5l2.5 3.01L14.5 11l4.5 6H5l3.5-4.5z"></path></g>
<g id="panorama-fish-eye"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="panorama-horizontal"><path d="M20 6.54v10.91c-2.6-.77-5.28-1.16-8-1.16-2.72 0-5.4.39-8 1.16V6.54c2.6.77 5.28 1.16 8 1.16 2.72.01 5.4-.38 8-1.16M21.43 4c-.1 0-.2.02-.31.06C18.18 5.16 15.09 5.7 12 5.7c-3.09 0-6.18-.55-9.12-1.64-.11-.04-.22-.06-.31-.06-.34 0-.57.23-.57.63v14.75c0 .39.23.62.57.62.1 0 .2-.02.31-.06 2.94-1.1 6.03-1.64 9.12-1.64 3.09 0 6.18.55 9.12 1.64.11.04.21.06.31.06.33 0 .57-.23.57-.63V4.63c0-.4-.24-.63-.57-.63z"></path></g>
<g id="panorama-vertical"><path d="M19.94 21.12c-1.1-2.94-1.64-6.03-1.64-9.12 0-3.09.55-6.18 1.64-9.12.04-.11.06-.22.06-.31 0-.34-.23-.57-.63-.57H4.63c-.4 0-.63.23-.63.57 0 .1.02.2.06.31C5.16 5.82 5.71 8.91 5.71 12c0 3.09-.55 6.18-1.64 9.12-.05.11-.07.22-.07.31 0 .33.23.57.63.57h14.75c.39 0 .63-.24.63-.57-.01-.1-.03-.2-.07-.31zM6.54 20c.77-2.6 1.16-5.28 1.16-8 0-2.72-.39-5.4-1.16-8h10.91c-.77 2.6-1.16 5.28-1.16 8 0 2.72.39 5.4 1.16 8H6.54z"></path></g>
<g id="panorama-wide-angle"><path d="M12 6c2.45 0 4.71.2 7.29.64.47 1.78.71 3.58.71 5.36 0 1.78-.24 3.58-.71 5.36-2.58.44-4.84.64-7.29.64s-4.71-.2-7.29-.64C4.24 15.58 4 13.78 4 12c0-1.78.24-3.58.71-5.36C7.29 6.2 9.55 6 12 6m0-2c-2.73 0-5.22.24-7.95.72l-.93.16-.25.9C2.29 7.85 2 9.93 2 12s.29 4.15.87 6.22l.25.89.93.16c2.73.49 5.22.73 7.95.73s5.22-.24 7.95-.72l.93-.16.25-.89c.58-2.08.87-4.16.87-6.23s-.29-4.15-.87-6.22l-.25-.89-.93-.16C17.22 4.24 14.73 4 12 4z"></path></g>
<g id="photo"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"></path></g>
<g id="photo-album"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4zm0 15l3-3.86 2.14 2.58 3-3.86L18 19H6z"></path></g>
<g id="photo-camera"><circle cx="12" cy="12" r="3.2"></circle><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"></path></g>
<g id="photo-filter"><path d="M19.02 10v9H5V5h9V3H5.02c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-9h-2zM17 10l.94-2.06L20 7l-2.06-.94L17 4l-.94 2.06L14 7l2.06.94zm-3.75.75L12 8l-1.25 2.75L8 12l2.75 1.25L12 16l1.25-2.75L16 12z"></path></g>
<g id="photo-library"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"></path></g>
<g id="photo-size-select-actual"><path d="M21 3H3C2 3 1 4 1 5v14c0 1.1.9 2 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2zM5 17l3.5-4.5 2.5 3.01L14.5 11l4.5 6H5z"></path></g>
<g id="photo-size-select-large"><path d="M21 15h2v2h-2v-2zm0-4h2v2h-2v-2zm2 8h-2v2c1 0 2-1 2-2zM13 3h2v2h-2V3zm8 4h2v2h-2V7zm0-4v2h2c0-1-1-2-2-2zM1 7h2v2H1V7zm16-4h2v2h-2V3zm0 16h2v2h-2v-2zM3 3C2 3 1 4 1 5h2V3zm6 0h2v2H9V3zM5 3h2v2H5V3zm-4 8v8c0 1.1.9 2 2 2h12V11H1zm2 8l2.5-3.21 1.79 2.15 2.5-3.22L13 19H3z"></path></g>
<g id="photo-size-select-small"><path d="M23 15h-2v2h2v-2zm0-4h-2v2h2v-2zm0 8h-2v2c1 0 2-1 2-2zM15 3h-2v2h2V3zm8 4h-2v2h2V7zm-2-4v2h2c0-1-1-2-2-2zM3 21h8v-6H1v4c0 1.1.9 2 2 2zM3 7H1v2h2V7zm12 12h-2v2h2v-2zm4-16h-2v2h2V3zm0 16h-2v2h2v-2zM3 3C2 3 1 4 1 5h2V3zm0 8H1v2h2v-2zm8-8H9v2h2V3zM7 3H5v2h2V3z"></path></g>
<g id="picture-as-pdf"><path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z"></path></g>
<g id="portrait"><path d="M12 12.25c1.24 0 2.25-1.01 2.25-2.25S13.24 7.75 12 7.75 9.75 8.76 9.75 10s1.01 2.25 2.25 2.25zm4.5 4c0-1.5-3-2.25-4.5-2.25s-4.5.75-4.5 2.25V17h9v-.75zM19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"></path></g>
<g id="remove-red-eye"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
<g id="rotate-90-degrees-ccw"><path d="M7.34 6.41L.86 12.9l6.49 6.48 6.49-6.48-6.5-6.49zM3.69 12.9l3.66-3.66L11 12.9l-3.66 3.66-3.65-3.66zm15.67-6.26C17.61 4.88 15.3 4 13 4V.76L8.76 5 13 9.24V6c1.79 0 3.58.68 4.95 2.05 2.73 2.73 2.73 7.17 0 9.9C16.58 19.32 14.79 20 13 20c-.97 0-1.94-.21-2.84-.61l-1.49 1.49C10.02 21.62 11.51 22 13 22c2.3 0 4.61-.88 6.36-2.64 3.52-3.51 3.52-9.21 0-12.72z"></path></g>
<g id="rotate-left"><path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z"></path></g>
<g id="rotate-right"><path d="M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z"></path></g>
<g id="slideshow"><path d="M10 8v8l5-4-5-4zm9-5H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"></path></g>
<g id="straighten"><path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H3V8h2v4h2V8h2v4h2V8h2v4h2V8h2v4h2V8h2v8z"></path></g>
<g id="style"><path d="M2.53 19.65l1.34.56v-9.03l-2.43 5.86c-.41 1.02.08 2.19 1.09 2.61zm19.5-3.7L17.07 3.98c-.31-.75-1.04-1.21-1.81-1.23-.26 0-.53.04-.79.15L7.1 5.95c-.75.31-1.21 1.03-1.23 1.8-.01.27.04.54.15.8l4.96 11.97c.31.76 1.05 1.22 1.83 1.23.26 0 .52-.05.77-.15l7.36-3.05c1.02-.42 1.51-1.59 1.09-2.6zM7.88 8.75c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-2 11c0 1.1.9 2 2 2h1.45l-3.45-8.34v6.34z"></path></g>
<g id="switch-camera"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5l3.5 3.5-3.5 3.5z"></path></g>
<g id="switch-video"><path d="M18 9.5V6c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-3.5l4 4v-13l-4 4zm-5 6V13H7v2.5L3.5 12 7 8.5V11h6V8.5l3.5 3.5-3.5 3.5z"></path></g>
<g id="tag-faces"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
<g id="texture"><path d="M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z"></path></g>
<g id="timelapse"><path d="M16.24 7.76C15.07 6.59 13.54 6 12 6v6l-4.24 4.24c2.34 2.34 6.14 2.34 8.49 0 2.34-2.34 2.34-6.14-.01-8.48zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="timer"><path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path></g>
<g id="timer-10"><path d="M0 7.72V9.4l3-1V18h2V6h-.25L0 7.72zm23.78 6.65c-.14-.28-.35-.53-.63-.74-.28-.21-.61-.39-1.01-.53s-.85-.27-1.35-.38c-.35-.07-.64-.15-.87-.23-.23-.08-.41-.16-.55-.25-.14-.09-.23-.19-.28-.3-.05-.11-.08-.24-.08-.39 0-.14.03-.28.09-.41.06-.13.15-.25.27-.34.12-.1.27-.18.45-.24s.4-.09.64-.09c.25 0 .47.04.66.11.19.07.35.17.48.29.13.12.22.26.29.42.06.16.1.32.1.49h1.95c0-.39-.08-.75-.24-1.09-.16-.34-.39-.63-.69-.88-.3-.25-.66-.44-1.09-.59C21.49 9.07 21 9 20.46 9c-.51 0-.98.07-1.39.21-.41.14-.77.33-1.06.57-.29.24-.51.52-.67.84-.16.32-.23.65-.23 1.01s.08.69.23.96c.15.28.36.52.64.73.27.21.6.38.98.53.38.14.81.26 1.27.36.39.08.71.17.95.26s.43.19.57.29c.13.1.22.22.27.34.05.12.07.25.07.39 0 .32-.13.57-.4.77-.27.2-.66.29-1.17.29-.22 0-.43-.02-.64-.08-.21-.05-.4-.13-.56-.24-.17-.11-.3-.26-.41-.44-.11-.18-.17-.41-.18-.67h-1.89c0 .36.08.71.24 1.05.16.34.39.65.7.93.31.27.69.49 1.15.66.46.17.98.25 1.58.25.53 0 1.01-.06 1.44-.19.43-.13.8-.31 1.11-.54.31-.23.54-.51.71-.83.17-.32.25-.67.25-1.06-.02-.4-.09-.74-.24-1.02zm-9.96-7.32c-.34-.4-.75-.7-1.23-.88-.47-.18-1.01-.27-1.59-.27-.58 0-1.11.09-1.59.27-.48.18-.89.47-1.23.88-.34.41-.6.93-.79 1.59-.18.65-.28 1.45-.28 2.39v1.92c0 .94.09 1.74.28 2.39.19.66.45 1.19.8 1.6.34.41.75.71 1.23.89.48.18 1.01.28 1.59.28.59 0 1.12-.09 1.59-.28.48-.18.88-.48 1.22-.89.34-.41.6-.94.78-1.6.18-.65.28-1.45.28-2.39v-1.92c0-.94-.09-1.74-.28-2.39-.18-.66-.44-1.19-.78-1.59zm-.92 6.17c0 .6-.04 1.11-.12 1.53-.08.42-.2.76-.36 1.02-.16.26-.36.45-.59.57-.23.12-.51.18-.82.18-.3 0-.58-.06-.82-.18s-.44-.31-.6-.57c-.16-.26-.29-.6-.38-1.02-.09-.42-.13-.93-.13-1.53v-2.5c0-.6.04-1.11.13-1.52.09-.41.21-.74.38-1 .16-.25.36-.43.6-.55.24-.11.51-.17.81-.17.31 0 .58.06.81.17.24.11.44.29.6.55.16.25.29.58.37.99.08.41.13.92.13 1.52v2.51z"></path></g>
<g id="timer-3"><path d="M11.61 12.97c-.16-.24-.36-.46-.62-.65-.25-.19-.56-.35-.93-.48.3-.14.57-.3.8-.5.23-.2.42-.41.57-.64.15-.23.27-.46.34-.71.08-.24.11-.49.11-.73 0-.55-.09-1.04-.28-1.46-.18-.42-.44-.77-.78-1.06-.33-.28-.73-.5-1.2-.64-.45-.13-.97-.2-1.53-.2-.55 0-1.06.08-1.52.24-.47.17-.87.4-1.2.69-.33.29-.6.63-.78 1.03-.2.39-.29.83-.29 1.29h1.98c0-.26.05-.49.14-.69.09-.2.22-.38.38-.52.17-.14.36-.25.58-.33.22-.08.46-.12.73-.12.61 0 1.06.16 1.36.47.3.31.44.75.44 1.32 0 .27-.04.52-.12.74-.08.22-.21.41-.38.57-.17.16-.38.28-.63.37-.25.09-.55.13-.89.13H6.72v1.57H7.9c.34 0 .64.04.91.11.27.08.5.19.69.35.19.16.34.36.44.61.1.24.16.54.16.87 0 .62-.18 1.09-.53 1.42-.35.33-.84.49-1.45.49-.29 0-.56-.04-.8-.13-.24-.08-.44-.2-.61-.36-.17-.16-.3-.34-.39-.56-.09-.22-.14-.46-.14-.72H4.19c0 .55.11 1.03.32 1.45.21.42.5.77.86 1.05s.77.49 1.24.63.96.21 1.48.21c.57 0 1.09-.08 1.58-.23.49-.15.91-.38 1.26-.68.36-.3.64-.66.84-1.1.2-.43.3-.93.3-1.48 0-.29-.04-.58-.11-.86-.08-.25-.19-.51-.35-.76zm9.26 1.4c-.14-.28-.35-.53-.63-.74-.28-.21-.61-.39-1.01-.53s-.85-.27-1.35-.38c-.35-.07-.64-.15-.87-.23-.23-.08-.41-.16-.55-.25-.14-.09-.23-.19-.28-.3-.05-.11-.08-.24-.08-.39s.03-.28.09-.41c.06-.13.15-.25.27-.34.12-.1.27-.18.45-.24s.4-.09.64-.09c.25 0 .47.04.66.11.19.07.35.17.48.29.13.12.22.26.29.42.06.16.1.32.1.49h1.95c0-.39-.08-.75-.24-1.09-.16-.34-.39-.63-.69-.88-.3-.25-.66-.44-1.09-.59-.43-.15-.92-.22-1.46-.22-.51 0-.98.07-1.39.21-.41.14-.77.33-1.06.57-.29.24-.51.52-.67.84-.16.32-.23.65-.23 1.01s.08.68.23.96c.15.28.37.52.64.73.27.21.6.38.98.53.38.14.81.26 1.27.36.39.08.71.17.95.26s.43.19.57.29c.13.1.22.22.27.34.05.12.07.25.07.39 0 .32-.13.57-.4.77-.27.2-.66.29-1.17.29-.22 0-.43-.02-.64-.08-.21-.05-.4-.13-.56-.24-.17-.11-.3-.26-.41-.44-.11-.18-.17-.41-.18-.67h-1.89c0 .36.08.71.24 1.05.16.34.39.65.7.93.31.27.69.49 1.15.66.46.17.98.25 1.58.25.53 0 1.01-.06 1.44-.19.43-.13.8-.31 1.11-.54.31-.23.54-.51.71-.83.17-.32.25-.67.25-1.06-.02-.4-.09-.74-.24-1.02z"></path></g>
<g id="timer-off"><path d="M19.04 4.55l-1.42 1.42C16.07 4.74 14.12 4 12 4c-1.83 0-3.53.55-4.95 1.48l1.46 1.46C9.53 6.35 10.73 6 12 6c3.87 0 7 3.13 7 7 0 1.27-.35 2.47-.94 3.49l1.45 1.45C20.45 16.53 21 14.83 21 13c0-2.12-.74-4.07-1.97-5.61l1.42-1.42-1.41-1.42zM15 1H9v2h6V1zm-4 8.44l2 2V8h-2v1.44zM3.02 4L1.75 5.27 4.5 8.03C3.55 9.45 3 11.16 3 13c0 4.97 4.02 9 9 9 1.84 0 3.55-.55 4.98-1.5l2.5 2.5 1.27-1.27-7.71-7.71L3.02 4zM12 20c-3.87 0-7-3.13-7-7 0-1.28.35-2.48.95-3.52l9.56 9.56c-1.03.61-2.23.96-3.51.96z"></path></g>
<g id="tonality"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93s3.05-7.44 7-7.93v15.86zm2-15.86c1.03.13 2 .45 2.87.93H13v-.93zM13 7h5.24c.25.31.48.65.68 1H13V7zm0 3h6.74c.08.33.15.66.19 1H13v-1zm0 9.93V19h2.87c-.87.48-1.84.8-2.87.93zM18.24 17H13v-1h5.92c-.2.35-.43.69-.68 1zm1.5-3H13v-1h6.93c-.04.34-.11.67-.19 1z"></path></g>
<g id="transform"><path d="M22 18v-2H8V4h2L7 1 4 4h2v2H2v2h4v8c0 1.1.9 2 2 2h8v2h-2l3 3 3-3h-2v-2h4zM10 8h6v6h2V8c0-1.1-.9-2-2-2h-6v2z"></path></g>
<g id="tune"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"></path></g>
<g id="view-comfy"><path d="M3 9h4V5H3v4zm0 5h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zM8 9h4V5H8v4zm5-4v4h4V5h-4zm5 9h4v-4h-4v4zM3 19h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zm5 0h4v-4h-4v4zm0-14v4h4V5h-4z"></path></g>
<g id="view-compact"><path d="M3 19h6v-7H3v7zm7 0h12v-7H10v7zM3 5v6h19V5H3z"></path></g>
<g id="vignette"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 15c-4.42 0-8-2.69-8-6s3.58-6 8-6 8 2.69 8 6-3.58 6-8 6z"></path></g>
<g id="wb-auto"><path d="M6.85 12.65h2.3L8 9l-1.15 3.65zM22 7l-1.2 6.29L19.3 7h-1.6l-1.49 6.29L15 7h-.76C12.77 5.17 10.53 4 8 4c-4.42 0-8 3.58-8 8s3.58 8 8 8c3.13 0 5.84-1.81 7.15-4.43l.1.43H17l1.5-6.1L20 16h1.75l2.05-9H22zm-11.7 9l-.7-2H6.4l-.7 2H3.8L7 7h2l3.2 9h-1.9z"></path></g>
<g id="wb-cloudy"><path d="M19.36 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.64-4.96z"></path></g>
<g id="wb-incandescent"><path d="M3.55 18.54l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8zM11 22.45h2V19.5h-2v2.95zM4 10.5H1v2h3v-2zm11-4.19V1.5H9v4.81C7.21 7.35 6 9.28 6 11.5c0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.22-1.21-4.15-3-5.19zm5 4.19v2h3v-2h-3zm-2.76 7.66l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4z"></path></g>
<g id="wb-iridescent"><path d="M5 14.5h14v-6H5v6zM11 .55V3.5h2V.55h-2zm8.04 2.5l-1.79 1.79 1.41 1.41 1.8-1.79-1.42-1.41zM13 22.45V19.5h-2v2.95h2zm7.45-3.91l-1.8-1.79-1.41 1.41 1.79 1.8 1.42-1.42zM3.55 4.46l1.79 1.79 1.41-1.41-1.79-1.79-1.41 1.41zm1.41 15.49l1.79-1.8-1.41-1.41-1.79 1.79 1.41 1.42z"></path></g>
<g id="wb-sunny"><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path></g>
</defs></svg>
</iron-iconset-svg>`;
document.head.appendChild(template$6.content);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
`iron-autogrow-textarea` is an element containing a textarea that grows in
height as more lines of input are entered. Unless an explicit height or the
`maxRows` property is set, it will never scroll.

Example:

    <iron-autogrow-textarea></iron-autogrow-textarea>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--iron-autogrow-textarea` | Mixin applied to the textarea | `{}`
`--iron-autogrow-textarea-placeholder` | Mixin applied to the textarea placeholder | `{}`

@demo demo/index.html
*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        display: inline-block;
        position: relative;
        width: 400px;
        border: 1px solid;
        padding: 2px;
        -moz-appearance: textarea;
        -webkit-appearance: textarea;
        overflow: hidden;
      }

      .mirror-text {
        visibility: hidden;
        word-wrap: break-word;
        @apply --iron-autogrow-textarea;
      }

      .fit {
        @apply --layout-fit;
      }

      textarea {
        position: relative;
        outline: none;
        border: none;
        resize: none;
        background: inherit;
        color: inherit;
        /* see comments in template */
        width: 100%;
        height: 100%;
        font-size: inherit;
        font-family: inherit;
        line-height: inherit;
        text-align: inherit;
        @apply --iron-autogrow-textarea;
      }

      textarea::-webkit-input-placeholder {
        @apply --iron-autogrow-textarea-placeholder;
      }

      textarea:-moz-placeholder {
        @apply --iron-autogrow-textarea-placeholder;
      }

      textarea::-moz-placeholder {
        @apply --iron-autogrow-textarea-placeholder;
      }

      textarea:-ms-input-placeholder {
        @apply --iron-autogrow-textarea-placeholder;
      }
    </style>

    <!-- the mirror sizes the input/textarea so it grows with typing -->
    <!-- use &#160; instead &nbsp; of to allow this element to be used in XHTML -->
    <div id="mirror" class="mirror-text" aria-hidden="true">&nbsp;</div>

    <!-- size the input/textarea with a div, because the textarea has intrinsic size in ff -->
    <div class="textarea-container fit">
      <textarea id="textarea" name$="[[name]]" aria-label$="[[label]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" autocapitalize$="[[autocapitalize]]" inputmode$="[[inputmode]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" required$="[[required]]" disabled$="[[disabled]]" rows$="[[rows]]" minlength$="[[minlength]]" maxlength$="[[maxlength]]"></textarea>
    </div>
`,
  is: 'iron-autogrow-textarea',
  behaviors: [IronValidatableBehavior, IronControlState],
  properties: {
    /**
     * Use this property instead of `bind-value` for two-way data binding.
     * @type {string|number}
     */
    value: {
      observer: '_valueChanged',
      type: String,
      notify: true
    },

    /**
     * This property is deprecated, and just mirrors `value`. Use `value`
     * instead.
     * @type {string|number}
     */
    bindValue: {
      observer: '_bindValueChanged',
      type: String,
      notify: true
    },

    /**
     * The initial number of rows.
     *
     * @attribute rows
     * @type number
     * @default 1
     */
    rows: {
      type: Number,
      value: 1,
      observer: '_updateCached'
    },

    /**
     * The maximum number of rows this element can grow to until it
     * scrolls. 0 means no maximum.
     *
     * @attribute maxRows
     * @type number
     * @default 0
     */
    maxRows: {
      type: Number,
      value: 0,
      observer: '_updateCached'
    },

    /**
     * Bound to the textarea's `autocomplete` attribute.
     */
    autocomplete: {
      type: String,
      value: 'off'
    },

    /**
     * Bound to the textarea's `autofocus` attribute.
     *
     * @type {!boolean}
     */
    autofocus: {
      type: Boolean,
      value: false
    },

    /**
     * Bound to the textarea's `autocapitalize` attribute.
     */
    autocapitalize: {
      type: String,
      value: 'none'
    },

    /**
     * Bound to the textarea's `inputmode` attribute.
     */
    inputmode: {
      type: String
    },

    /**
     * Bound to the textarea's `placeholder` attribute.
     */
    placeholder: {
      type: String
    },

    /**
     * Bound to the textarea's `readonly` attribute.
     */
    readonly: {
      type: String
    },

    /**
     * Set to true to mark the textarea as required.
     */
    required: {
      type: Boolean
    },

    /**
     * The minimum length of the input value.
     */
    minlength: {
      type: Number
    },

    /**
     * The maximum length of the input value.
     */
    maxlength: {
      type: Number
    },

    /**
     * Bound to the textarea's `aria-label` attribute.
     */
    label: {
      type: String
    }
  },
  listeners: {
    'input': '_onInput'
  },

  /**
   * Returns the underlying textarea.
   * @return {!HTMLTextAreaElement}
   */
  get textarea() {
    return this.$.textarea;
  },

  /**
   * Returns textarea's selection start.
   * @return {number}
   */
  get selectionStart() {
    return this.$.textarea.selectionStart;
  },

  /**
   * Returns textarea's selection end.
   * @return {number}
   */
  get selectionEnd() {
    return this.$.textarea.selectionEnd;
  },

  /**
   * Sets the textarea's selection start.
   */
  set selectionStart(value) {
    this.$.textarea.selectionStart = value;
  },

  /**
   * Sets the textarea's selection end.
   */
  set selectionEnd(value) {
    this.$.textarea.selectionEnd = value;
  },

  /** @override */
  attached: function () {
    /* iOS has an arbitrary left margin of 3px that isn't present
     * in any other browser, and means that the paper-textarea's cursor
     * overlaps the label.
     * See https://github.com/PolymerElements/paper-input/issues/468.
     */
    var IS_IOS = navigator.userAgent.match(/iP(?:[oa]d|hone)/) && !navigator.userAgent.match(/OS 1[3456789]/);

    if (IS_IOS) {
      this.$.textarea.style.marginLeft = '-3px';
    }
  },

  /**
   * Returns true if `value` is valid. The validator provided in `validator`
   * will be used first, if it exists; otherwise, the `textarea`'s validity
   * is used.
   * @return {boolean} True if the value is valid.
   */
  validate: function () {
    // Use the nested input's native validity.
    var valid = this.$.textarea.validity.valid; // Only do extra checking if the browser thought this was valid.

    if (valid) {
      // Empty, required input is invalid
      if (this.required && this.value === '') {
        valid = false;
      } else if (this.hasValidator()) {
        valid = IronValidatableBehavior.validate.call(this, this.value);
      }
    }

    this.invalid = !valid;
    this.fire('iron-input-validate');
    return valid;
  },
  _bindValueChanged: function (bindValue) {
    this.value = bindValue;
  },
  _valueChanged: function (value) {
    var textarea = this.textarea;

    if (!textarea) {
      return;
    } // If the bindValue changed manually, then we need to also update
    // the underlying textarea's value. Otherwise this change was probably
    // generated from the _onInput handler, and the two values are already
    // the same.


    if (textarea.value !== value) {
      textarea.value = !(value || value === 0) ? '' : value;
    }

    this.bindValue = value;
    this.$.mirror.innerHTML = this._valueForMirror(); // Manually notify because we don't want to notify until after setting
    // value.

    this.fire('bind-value-changed', {
      value: this.bindValue
    });
  },
  _onInput: function (event) {
    var eventPath = dom(event).path;
    this.value = eventPath ? eventPath[0].value : event.target.value;
  },
  _constrain: function (tokens) {
    var _tokens;

    tokens = tokens || ['']; // Enforce the min and max heights for a multiline input to avoid
    // measurement

    if (this.maxRows > 0 && tokens.length > this.maxRows) {
      _tokens = tokens.slice(0, this.maxRows);
    } else {
      _tokens = tokens.slice(0);
    }

    while (this.rows > 0 && _tokens.length < this.rows) {
      _tokens.push('');
    } // Use &#160; instead &nbsp; of to allow this element to be used in XHTML.


    return _tokens.join('<br/>') + '&#160;';
  },
  _valueForMirror: function () {
    var input = this.textarea;

    if (!input) {
      return;
    }

    this.tokens = input && input.value ? input.value.replace(/&/gm, '&amp;').replace(/"/gm, '&quot;').replace(/'/gm, '&#39;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;').split('\n') : [''];
    return this._constrain(this.tokens);
  },
  _updateCached: function () {
    this.$.mirror.innerHTML = this._constrain(this.tokens);
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/*
`<paper-textarea>` is a multi-line text field with Material Design styling.

    <paper-textarea label="Textarea label"></paper-textarea>

See `Polymer.PaperInputBehavior` for more API docs.

### Validation

Currently only `required` and `maxlength` validation is supported.

### Styling

See `Polymer.PaperInputContainer` for a list of custom properties used to
style this element.
*/

Polymer({
  /** @override */
  _template: html`
    <style>
      :host {
        display: block;
      }

      :host([hidden]) {
        display: none !important;
      }

      label {
        pointer-events: none;
      }
    </style>

    <paper-input-container no-label-float$="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

      <label hidden$="[[!label]]" aria-hidden="true" for$="[[_inputId]]" slot="label">[[label]]</label>

      <iron-autogrow-textarea class="paper-input-input" slot="input" id$="[[_inputId]]" aria-labelledby$="[[_ariaLabelledBy]]" aria-describedby$="[[_ariaDescribedBy]]" bind-value="{{value}}" invalid="{{invalid}}" validator$="[[validator]]" disabled$="[[disabled]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" required$="[[required]]" minlength$="[[minlength]]" maxlength$="[[maxlength]]" autocapitalize$="[[autocapitalize]]" rows$="[[rows]]" max-rows$="[[maxRows]]" on-change="_onChange"></iron-autogrow-textarea>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive" slot="add-on">[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter slot="add-on"></paper-input-char-counter>
      </template>

    </paper-input-container>
`,
  is: 'paper-textarea',
  behaviors: [PaperInputBehavior, IronFormElementBehavior],
  properties: {
    _ariaLabelledBy: {
      observer: '_ariaLabelledByChanged',
      type: String
    },
    _ariaDescribedBy: {
      observer: '_ariaDescribedByChanged',
      type: String
    },
    value: {
      // Required for the correct TypeScript type-generation
      type: String
    },

    /**
     * The initial number of rows.
     * @type {number}
     * @default 1
     */
    rows: {
      type: Number,
      value: 1
    },

    /**
     * The maximum number of rows this element can grow to until it
     * scrolls. 0 means no maximum.
     * @type {number}
     * @default 0
     */
    maxRows: {
      type: Number,
      value: 0
    }
  },

  /**
   * @return {number}
   */
  get selectionStart() {
    return this.$.input.textarea.selectionStart;
  },

  set selectionStart(start) {
    this.$.input.textarea.selectionStart = start;
  },

  /**
   * @return {number}
   */
  get selectionEnd() {
    return this.$.input.textarea.selectionEnd;
  },

  set selectionEnd(end) {
    this.$.input.textarea.selectionEnd = end;
  },

  _ariaLabelledByChanged: function (ariaLabelledBy) {
    this._focusableElement.setAttribute('aria-labelledby', ariaLabelledBy);
  },
  _ariaDescribedByChanged: function (ariaDescribedBy) {
    this._focusableElement.setAttribute('aria-describedby', ariaDescribedBy);
  },

  get _focusableElement() {
    return this.inputElement.textarea;
  }

});
//# sourceMappingURL=pb-components-bundle.js.map
